---
phase: 30-set-discriminant-vcgen
plan: "02"
type: execute
wave: 2
depends_on:
  - 30-01
files_modified:
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements:
  - VCGEN-06
  - MIRCONV-02
must_haves:
  truths:
    - "VCGen emits at least one VC for any Function containing a SetDiscriminant statement"
    - "The emitted VC's SMT script contains 'discriminant' and the variant index integer"
    - "The VC uses VcKind::Assertion (not MemorySafety)"
    - "Tests vcgen_06_set_discriminant_unit and vcgen_06_set_discriminant_assertion turn GREEN"
    - "All previously GREEN tests remain GREEN (no regressions)"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "generate_set_discriminant_vcs() function + wire-in to generate_vcs_with_db"
      contains: "generate_set_discriminant_vcs"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Call site in generate_vcs_with_db after generate_index_bounds_vcs"
      contains: "disc_vcs"
  key_links:
    - from: "generate_vcs_with_db"
      to: "generate_set_discriminant_vcs"
      via: "call after generate_index_bounds_vcs, conditions.append(&mut disc_vcs)"
      pattern: "generate_set_discriminant_vcs"
    - from: "generate_set_discriminant_vcs"
      to: "Statement::SetDiscriminant"
      via: "if let Statement::SetDiscriminant(place, variant_idx) = stmt"
      pattern: "SetDiscriminant"
---

<objective>
Implement `generate_set_discriminant_vcs()` in `vcgen.rs` and wire it into `generate_vcs_with_db` — turning the RED tests from plan 30-01 GREEN.

Purpose: Close the VCGEN-06 gap — VCGen currently treats `Statement::SetDiscriminant` as a no-op. After this plan, each SetDiscriminant statement emits a `discriminant(place) == variant_index` assertion VC.
Output: New `generate_set_discriminant_vcs` function (~35 lines) in vcgen.rs + one-line call site in `generate_vcs_with_db`.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-set-discriminant-vcgen/30-CONTEXT.md
@.planning/phases/30-set-discriminant-vcgen/30-RESEARCH.md

<interfaces>
<!-- Key interfaces the executor needs. Extracted from codebase. -->

From crates/analysis/src/ir.rs (Statement enum, line ~608):
```rust
#[derive(Debug, Clone)]
pub enum Statement {
    Assign(Place, Rvalue),
    Nop,
    SetDiscriminant(Place, usize),  // place: enum local, usize: variant index
    Assume(Operand),
}
```

From crates/analysis/src/ir.rs (Place):
```rust
pub struct Place {
    pub local: String,
    pub projections: Vec<Projection>,
}
impl Place {
    pub fn local(name: &str) -> Self { ... }
}
```

From crates/analysis/src/vcgen.rs (generate_index_bounds_vcs signature + wiring, lines 1374 + 321):
```rust
fn generate_index_bounds_vcs(
    func: &Function,
    datatype_declarations: &[Command],
    declarations: &[Command],
) -> Vec<VerificationCondition> { ... }

// Wiring at line 321 (inside generate_vcs_with_db):
let mut index_vcs = generate_index_bounds_vcs(func, &datatype_declarations, &declarations);
conditions.append(&mut index_vcs);
// ADD discriminant call directly after the above two lines
```

From crates/analysis/src/vcgen.rs (base_script, line 1491):
```rust
fn base_script(
    datatype_declarations: &[Command],
    variable_declarations: &[Command],
    uses_int: bool,
) -> Script {
    // Selects QF_BV (no datatypes), QF_UFBVDT (with datatypes), or ALL (with spec-int)
}

fn uses_spec_int_types(func: &Function) -> bool { ... }
```

From crates/analysis/src/vcgen.rs (VcKind enum, line 86):
```rust
pub enum VcKind {
    Assertion,       // <-- use this for SetDiscriminant (correctness, not safety)
    MemorySafety,
    Postcondition,
    Precondition,
    // ...
}
```

From crates/analysis/src/vcgen.rs (VerificationCondition + VcLocation):
```rust
pub struct VerificationCondition {
    pub description: String,
    pub script: Script,
    pub location: VcLocation,
}
pub struct VcLocation {
    pub function: String,
    pub block: usize,
    pub statement: usize,
    pub source_file: Option<String>,
    pub source_line: Option<u32>,
    pub source_column: Option<u32>,
    pub contract_text: Option<String>,
    pub vc_kind: VcKind,
}
```

From crates/analysis/src/vcgen.rs (Rvalue::Discriminant encoding, line 1659 — naming MUST match):
```rust
Rvalue::Discriminant(disc_place) => {
    let disc_fn = format!("discriminant-{}", disc_place.local);
    Term::App(disc_fn, vec![Term::Const(disc_place.local.clone())])
}
```
The SetDiscriminant VC MUST use the same `"discriminant-{local}"` naming convention.

From rust_fv_smtlib (Term variants used):
```rust
Term::App(String, Vec<Term>)  // uninterpreted function application
Term::Eq(Box<Term>, Box<Term>) // equality comparison
Term::IntLit(i64)              // integer literal
Term::Not(Box<Term>)           // logical negation (for UNSAT-based assertion checking)
```

From rust_fv_smtlib (Command variants used):
```rust
Command::Comment(String)
Command::Assert(Term)
Command::CheckSat
Command::GetModel
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_set_discriminant_vcs and wire into generate_vcs_with_db</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Add a new private function `generate_set_discriminant_vcs` immediately after the `generate_index_bounds_vcs` function (around line 1442), following the exact same signature pattern:

```rust
/// Generate discriminant assertion VCs for SetDiscriminant statements (VCGEN-06).
///
/// For each `Statement::SetDiscriminant(place, variant_idx)`, emits one assertion VC:
/// `discriminant-{place.local}(place.local) == variant_idx`
///
/// The discriminant function name matches the `Rvalue::Discriminant` encoding in
/// `encode_rvalue` (line 1659) to ensure SMT consistency.
fn generate_set_discriminant_vcs(
    func: &Function,
    datatype_declarations: &[Command],
    declarations: &[Command],
) -> Vec<VerificationCondition> {
    let mut vcs = Vec::new();

    for (block_idx, bb) in func.basic_blocks.iter().enumerate() {
        for (stmt_idx, stmt) in bb.statements.iter().enumerate() {
            if let Statement::SetDiscriminant(place, variant_idx) = stmt {
                // Use the same naming convention as Rvalue::Discriminant (vcgen.rs:1659)
                let disc_fn = format!("discriminant-{}", place.local);
                let disc_term = Term::App(disc_fn, vec![Term::Const(place.local.clone())]);
                let idx_term = Term::IntLit(*variant_idx as i64);
                let assertion = Term::Eq(Box::new(disc_term), Box::new(idx_term));

                // base_script selects: QF_BV (no datatypes), QF_UFBVDT (datatypes), ALL (spec-int)
                let mut script = base_script(
                    datatype_declarations,
                    declarations,
                    uses_spec_int_types(func),
                );

                let desc = format!(
                    "{}: discriminant({}) == {} at block {}",
                    func.name, place.local, variant_idx, block_idx
                );
                script.push(Command::Comment(desc.clone()));
                // Negate assertion: UNSAT proves discriminant is set correctly
                script.push(Command::Assert(Term::Not(Box::new(assertion))));
                script.push(Command::CheckSat);
                script.push(Command::GetModel);

                vcs.push(VerificationCondition {
                    description: desc,
                    script,
                    location: VcLocation {
                        function: func.name.clone(),
                        block: block_idx,
                        statement: stmt_idx,
                        source_file: None,
                        source_line: None,
                        source_column: None,
                        contract_text: Some(format!(
                            "discriminant({}) == {}",
                            place.local, variant_idx
                        )),
                        vc_kind: VcKind::Assertion,
                    },
                });
            }
        }
    }

    vcs
}
```

Then wire the call into `generate_vcs_with_db` IMMEDIATELY after the `generate_index_bounds_vcs` call block (lines 321-322). Add these two lines directly after `conditions.append(&mut index_vcs);`:

```rust
// Generate discriminant assertion VCs for SetDiscriminant statements (VCGEN-06).
let mut disc_vcs = generate_set_discriminant_vcs(func, &datatype_declarations, &declarations);
conditions.append(&mut disc_vcs);
```

CRITICAL notes:
- Do NOT add a `DeclareFun` for the discriminant function — Phase 28 confirmed Z3 accepts `Term::App` without explicit declare-fun (STATE.md line 161).
- Use `VcKind::Assertion` (not `VcKind::MemorySafety`) — SetDiscriminant is a correctness assertion.
- Use `Term::IntLit` (not `Term::BitVecLit`) for the variant index — the discriminant function is uninterpreted and integer-sorted.
- Do NOT change the existing `Statement::SetDiscriminant(Place, usize)` tuple variant form in ir.rs — it is already correct.
- Run `cargo clippy --tests 2>&1 | grep "^error"` after implementation to confirm no lint errors.
  </action>
  <verify>
```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test --test vcgen_completeness29 vcgen_06_set_discriminant_unit -- --nocapture 2>&1 | tail -10
```
Expected: test PASSES (was RED in plan 30-01, now GREEN).

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test --test vcgen_completeness29 vcgen_06_set_discriminant_assertion -- --nocapture 2>&1 | tail -10
```
Expected: test PASSES (was RED in plan 30-01, now GREEN).

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test --test vcgen_completeness29 mirconv_02_set_discriminant -- --nocapture 2>&1 | tail -5
```
Expected: still PASSES (regression guard).

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo clippy --tests 2>&1 | grep "^error" | head -5
```
Expected: no output (zero clippy errors).
  </verify>
  <done>
    - `generate_set_discriminant_vcs` function exists in vcgen.rs after `generate_index_bounds_vcs`
    - Call site exists in `generate_vcs_with_db` after the `generate_index_bounds_vcs` call block
    - `vcgen_06_set_discriminant_unit` test is GREEN
    - `vcgen_06_set_discriminant_assertion` test is GREEN
    - `mirconv_02_set_discriminant` test remains GREEN
    - Zero clippy errors
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test --test vcgen_completeness29 2>&1 | grep -E "^test vcgen_06|FAILED|PASSED" | head -10
```
Expected: both `vcgen_06_set_discriminant_unit` and `vcgen_06_set_discriminant_assertion` show PASSED, no FAILED lines.

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis 2>&1 | tail -5
```
Expected: `test result: ok.` with 0 failed.
</verification>

<success_criteria>
- `generate_set_discriminant_vcs` function exists in vcgen.rs with correct signature
- Function is called from `generate_vcs_with_db` after `generate_index_bounds_vcs`
- Both vcgen_06 RED tests from plan 30-01 are now GREEN
- No regressions in vcgen_completeness29 test suite
- Zero clippy errors
- VCGEN-06 requirement: VCGen emits `discriminant(place) == variant_index` assertion VC for SetDiscriminant statements
</success_criteria>

<output>
After completion, create `.planning/phases/30-set-discriminant-vcgen/30-02-SUMMARY.md`
</output>

---
phase: 22-higher-order-closures
plan: 03
type: tdd
wave: 3
depends_on: [22-02]
files_modified:
  - crates/analysis/tests/hof_closures.rs
  - crates/analysis/src/hof_vcgen.rs
  - crates/analysis/src/ir.rs
autonomous: true
requirements: [HOF-01, HOF-02]

must_haves:
  truths:
    - "A fn_spec(f, |x: i32| x > 0 => result > 0) entailment produces UNSAT when f satisfies the spec (HOF-01 verified)"
    - "A fn_spec entailment with a false pre/post produces SAT when no f can satisfy it (HOF-01 counterexample)"
    - "A FnMut fn_spec with env_before_count reference produces UNSAT when the postcondition encodes correct mutation (HOF-02 verified)"
    - "A FnMut fn_spec with incorrect mutation postcondition produces SAT (HOF-02 counterexample)"
    - "All 9 existing RC11 litmus tests continue to pass (zero regressions)"
  artifacts:
    - path: "crates/analysis/tests/hof_closures.rs"
      provides: "TDD test suite for HOF-01 and HOF-02 requirements"
      contains: "fn_spec_fn_verified\|fn_spec_fn_falsified\|fn_spec_fnmut_verified"
  key_links:
    - from: "crates/analysis/tests/hof_closures.rs"
      to: "crates/analysis/src/hof_vcgen.rs generate_fn_spec_vcs()"
      via: "direct call with constructed FnSpec and Function stubs"
      pattern: "generate_fn_spec_vcs"
    - from: "test SMT script output"
      to: "Z3 solver via rust_fv_analysis solver infrastructure"
      via: "run_smt_script() or equivalent in-process solver call"
      pattern: "UNSAT|SAT"
---

<objective>
Validate HOF-01 and HOF-02 end-to-end via TDD: write failing tests first (RED), then fix any remaining gaps in hof_vcgen.rs until they pass (GREEN). This is the soundness proof for the higher-order closure verification feature.

Purpose: The annotation pipeline (Plan 22-01) and VCGen engine (Plan 22-02) may have encoding errors that are invisible until actual Z3 queries are exercised. TDD with direct SMT script execution catches wrong logic selection, quantifier encoding bugs, and env_before/env_after constraint gaps before they reach production.
Output: test suite in hof_closures.rs; all tests green; HOF-01 and HOF-02 requirements confirmed sound.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-higher-order-closures/22-CONTEXT.md
@.planning/phases/22-higher-order-closures/22-RESEARCH.md
@.planning/phases/22-higher-order-closures/22-01-SUMMARY.md
@.planning/phases/22-higher-order-closures/22-02-SUMMARY.md
</context>

<feature>
  <name>Higher-Order Closure Specification Verification (HOF-01 and HOF-02)</name>
  <files>
    crates/analysis/tests/hof_closures.rs
    crates/analysis/src/hof_vcgen.rs (fixes if needed)
    crates/analysis/src/ir.rs (fixes if needed)
  </files>
  <behavior>
    HOF-01 — fn_spec entailment for Fn closures:
    - fn_spec(f, |x: i32| x > 0 => result > 0) on function with Fn closure param
      → generate_fn_spec_vcs() produces 1 VerificationCondition with vc_kind ClosureContract
      → SMT script uses (set-logic AUFLIA) with (not (forall ...)) assertion
      → Z3 returns UNSAT (entailment holds — all x > 0 gives f(x) > 0 for the uninterpreted f with that constraint)
      Wait — the uninterpreted f has no constraint by default. UNSAT means we're checking that
      the negation of "forall x. pre => post" is UNSAT. But for an uninterpreted f, the negation
      IS satisfiable (Z3 can pick any f). So the correct test pattern is:
      - For a VERIFIED entailment test: assert additional axioms saying "f IS the correct function"
        (e.g., add "(assert (forall ((x Int)) (=> (> x 0) (> (f_impl env_f x) 0))))" as a given),
        then check (not (forall x. pre => post)) → UNSAT
      - For a FALSIFIED entailment test: do NOT add the axiom → check (not (forall x. pre => post)) → SAT

    Concrete test cases:

    Case 1: fn_spec_fn_verified
      Given: axiom "(forall ((x Int)) (=> (> x 0) (> (f_impl env_f x) 0)))"
      Check: NOT (forall x. x > 0 => f_impl(env_f, x) > 0) → UNSAT
      Expected: Z3 returns UNSAT (entailment holds given the axiom)

    Case 2: fn_spec_fn_falsified
      Given: no axiom about f_impl
      Check: NOT (forall x. x > 0 => f_impl(env_f, x) > 0) → SAT
      Expected: Z3 returns SAT (uninterpreted f can violate the spec)

    Case 3: fn_spec_fn_trivially_true
      Given: fn_spec(f, |x: i32| false => result > 0) — unsatisfiable precondition
      Check: NOT (forall x. false => f_impl(env_f, x) > 0) → UNSAT (vacuously true)
      Expected: Z3 returns UNSAT

    HOF-02 — FnMut environment mutation:

    Case 4: fn_spec_fnmut_verified
      Closure captures `count: i32`; fn_spec(inc, |x: i32| x > 0 => result == env_before_count + x)
      Generated script:
        (declare-const env_before_count Int)
        (declare-const env_after_count Int)
        (declare-fun inc_impl (Int Int) Int)  ; (env_before_count, x) -> result
        ; Given: axiom that inc_impl is correct implementation
        (assert (forall ((x Int)) (=> (> x 0) (= (inc_impl env_before_count x) (+ env_before_count x)))))
        ; Check entailment
        (assert (not (forall ((x Int)) (=> (> x 0) (= (inc_impl env_before_count x) (+ env_before_count x))))))
        (check-sat)
      Expected: UNSAT

    Case 5: fn_spec_fnmut_falsified
      Same setup but wrong postcondition: result == env_before_count + x + 1
        No axiom, or axiom with actual behavior
      Expected: SAT (counterexample exists)

    Case 6: fn_spec_fnonce_single_call
      FnOnce closure: fn_spec(consume, |x: i32| x > 0 => result > 0)
      Generated VC: same as Fn path (single-call, no env_before/env_after)
      Check: env_before/env_after constants are NOT present in script
      Expected: Script compiles and Z3 returns UNSAT when axiom provided

    Note: The test directly calls generate_fn_spec_vcs() with hand-constructed FnSpec and Function
    stubs (not via the full rustc driver). Look at the pattern used in weak_memory_litmus.rs tests
    (which call rc11.rs functions directly) and in vcgen.rs unit tests for the pattern.
  </behavior>
  <implementation>
    RED phase:
    1. Create crates/analysis/tests/hof_closures.rs with 6 test functions (all marked #[test])
    2. Each test: constructs FnSpec directly, calls generate_fn_spec_vcs(), extracts the SMT script
       from the VerificationCondition, runs it through the Z3 solver infrastructure, checks UNSAT/SAT
    3. Run cargo test -p rust-fv-analysis --test hof_closures — expect failures
    4. Commit: test(22-03): add failing HOF-01/HOF-02 entailment tests (RED)

    GREEN phase:
    5. Fix any issues in hof_vcgen.rs revealed by failing tests:
       - Wrong logic declaration → change to AUFLIA
       - Missing axiom path for verified cases → add axiom injection parameter to generate_fn_spec_vcs
         (or use a separate helper that adds "given" axioms for test harness use)
       - FnMut env constants missing → fix FnMut detection branch
       - Quantifier triggers incorrect → fix trigger inference call
    6. Run cargo test -p rust-fv-analysis --test hof_closures — all 6 tests green
    7. Run cargo test -p rust-fv-analysis — zero regressions
    8. Commit: feat(22-03): fix HOF encoding — all fn_spec entailment tests pass (GREEN)

    Implementation notes:
    - To test "verified" cases (where the entailment holds), the test must supply an axiom to Z3
      that constrains the uninterpreted function. Add a test-only parameter or use a separate
      function generate_fn_spec_vcs_with_axioms() that appends extra (assert ...) commands before
      the final check. Alternatively, inline the axiom in the test by constructing the script
      manually from the VerificationCondition output and prepending the axiom.
    - To test "falsified" cases, no axiom is needed — the uninterpreted function is free.
    - For the Z3 call pattern: look at how existing tests (e.g., rc11 litmus tests or vcgen tests)
      invoke the solver. Use the same pattern (likely via SolverInterface or direct smtlib::Script
      serialization + z3 subprocess call or in-process Z3 binding).
    - RESEARCH.md Pitfall 1: if Z3 returns UNKNOWN instead of UNSAT, the logic is wrong (still QF_BV).
      Fix: ensure hof_vcgen.rs emits (set-logic AUFLIA) not the default.
    - RESEARCH.md Pitfall 3: if fn_spec_fnmut_verified always returns UNSAT even with wrong post,
      the env_after is unconstrained. Fix: ensure the axiom in the test correctly uses the FnMut
      impl function signature.
  </implementation>
</feature>

<verification>
All 6 HOF tests green:
```
cargo test -p rust-fv-analysis --test hof_closures -- --nocapture 2>&1 | tail -30
```

Zero regressions in full suite:
```
cargo test -p rust-fv-analysis 2>&1 | tail -30
```

Confirm AUFLIA logic in hof_vcgen output:
```
grep -n "AUFLIA\|set-logic" crates/analysis/src/hof_vcgen.rs
```

Confirm env naming convention:
```
grep -n "env_before_\|env_after_" crates/analysis/src/hof_vcgen.rs
```
</verification>

<success_criteria>
- 6 tests in hof_closures.rs all pass: fn_spec_fn_verified (UNSAT), fn_spec_fn_falsified (SAT), fn_spec_fn_trivially_true (UNSAT), fn_spec_fnmut_verified (UNSAT), fn_spec_fnmut_falsified (SAT), fn_spec_fnonce_single_call (UNSAT)
- All existing tests pass including 9 RC11 litmus tests — zero regressions
- Generated SMT scripts use (set-logic AUFLIA) for all fn_spec VCs
- FnMut scripts contain env_before_VARNAME and env_after_VARNAME constants
- HOF-01 and HOF-02 requirements are satisfied as confirmed by Z3 UNSAT/SAT results
</success_criteria>

<output>
After completion, create `.planning/phases/22-higher-order-closures/22-03-SUMMARY.md`
</output>

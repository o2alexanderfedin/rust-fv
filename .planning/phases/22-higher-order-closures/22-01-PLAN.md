---
phase: 22-higher-order-closures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/macros/src/lib.rs
  - crates/analysis/src/ir.rs
  - crates/driver/src/callbacks.rs
autonomous: true
requirements: [HOF-01, HOF-02]

must_haves:
  truths:
    - "Developer can write #[fn_spec(f, |x| pre => post)] on a HOF and the macro emits the doc attribute without compile error"
    - "The FnSpec struct exists in ir.rs and Contracts has a fn_specs: Vec<FnSpec> field"
    - "extract_contracts() in callbacks.rs parses rust_fv::fn_spec:: doc attributes into FnSpec entries"
    - "Multiple fn_spec clauses (fn_spec(f => |x| ..., g => |y| ...)) are stored correctly"
  artifacts:
    - path: "crates/macros/src/lib.rs"
      provides: "fn_spec proc macro emitting rust_fv::fn_spec::PARAM::PRE%%POST doc attribute"
      contains: "fn_spec_impl"
    - path: "crates/analysis/src/ir.rs"
      provides: "FnSpec struct and fn_specs Vec<FnSpec> field on Contracts"
      contains: "pub struct FnSpec"
    - path: "crates/driver/src/callbacks.rs"
      provides: "extract_contracts parsing rust_fv::fn_spec:: prefix into contracts.fn_specs"
      contains: "rust_fv::fn_spec::"
  key_links:
    - from: "crates/macros/src/lib.rs fn_spec_impl()"
      to: "crates/driver/src/callbacks.rs extract_contracts()"
      via: "doc attribute format rust_fv::fn_spec::PARAM::PRE%%POST"
      pattern: "rust_fv::fn_spec::"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/ir.rs"
      via: "contracts.fn_specs.push(FnSpec { ... })"
      pattern: "fn_specs\\.push"
---

<objective>
Add the fn_spec annotation infrastructure: the proc macro that encodes closure spec clauses as hidden doc attributes, the FnSpec IR type that represents parsed clauses, the fn_specs field on Contracts, and the callbacks.rs extraction logic that bridges the two.

Purpose: This is the foundation layer — VCGen (Plan 22-02) cannot generate closure entailment VCs without FnSpec data in the IR. The macro+IR+extraction triangle must be complete before any verification can happen.
Output: #[fn_spec(f, |x| pre => post)] compiles, emits doc attributes, and those attributes are parsed into Contracts.fn_specs by the driver.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-higher-order-closures/22-CONTEXT.md
@.planning/phases/22-higher-order-closures/22-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: fn_spec proc macro + FnSpec IR type</name>
  <files>
    crates/macros/src/lib.rs
    crates/analysis/src/ir.rs
  </files>
  <action>
**Part A — FnSpec IR type in crates/analysis/src/ir.rs:**

Add after the existing `Contracts` struct (around line 430):

```rust
/// A higher-order function specification clause.
/// Represents: `fn_spec(f, |x| pre => post)` or `fn_spec(f => |x| ..., g => |y| ...)`
#[derive(Debug, Clone, PartialEq)]
pub struct FnSpec {
    /// The closure parameter name (e.g., "f")
    pub closure_param: String,
    /// The pre-condition expression string (e.g., "x > 0")
    pub pre: String,
    /// The post-condition expression string (e.g., "result > 0")
    pub post: String,
    /// Bound variable names in the clause (e.g., ["x"] from "|x| ...")
    pub bound_vars: Vec<String>,
}
```

Extend the `Contracts` struct to add:
```rust
    /// HOF closure specification entailments (fn_spec clauses)
    pub fn_specs: Vec<FnSpec>,
```

Update `Contracts::default()` / `impl Default for Contracts` (if it exists — search and add `fn_specs: vec![]`) and any constructor site that constructs `Contracts { ... }` explicitly (use grep to find all sites, add `fn_specs: vec![]` to each).

**Part B — fn_spec proc macro in crates/macros/src/lib.rs:**

Model after `borrow_ensures_impl` (lines ~344-380). Add:

1. A public `#[proc_macro_attribute]` entry `fn_spec` that delegates to `fn_spec_impl`.

2. A `fn_spec_impl(attr: TokenStream2, item: TokenStream2) -> TokenStream2` function that:
   - Parses `attr` as a token stream
   - Supports two syntactic forms:
     - Single: `(f, |x| pre => post)` — param name followed by comma, then a closure-style clause
     - Multiple: `(f => |x| ..., g => |y| ...)` — `PARAM => CLAUSE` pairs separated by commas
   - For each clause, splits the clause string at the `=>` fat-arrow token (use `proc_macro2::TokenTree` scanning: find the `=` punct immediately followed by `>` punct, that marks the split). Parse the left side as `|bound_vars| pre_expr` and the right side as `post_expr`.
   - Encodes each clause as a doc attribute string: `"rust_fv::fn_spec::PARAM::PRE_STR%%POST_STR"` where `%%` is the separator between pre and post (avoids `::` collision in expression content). The `PRE_STR` is the full pre token stream stringified (preserving spaces). The `POST_STR` is the full post token stream stringified.
   - Emits one `#[doc(hidden)] #[doc = "rust_fv::fn_spec::..."]` attribute per clause.
   - Passes the item through unchanged.

3. Add unit tests inside the existing `#[cfg(test)]` block:
   - `test_fn_spec_single_clause`: Verifies `fn_spec(f, |x: i32| x > 0 => result > 0)` emits doc with prefix `rust_fv::fn_spec::f::`.
   - `test_fn_spec_multiple_clauses`: Verifies `fn_spec(f => |x| x > 0 => r > 0, g => |y| y >= 0 => r >= 0)` emits two doc attributes.

**Key constraint from RESEARCH.md:** Use `%%` as the pre/post separator (not `::`) to avoid collisions when pre or post contain `::` path separators.

**Anti-pattern:** Do NOT use `syn::parse_str::<Expr>` on `"|x| pre => post"` directly — `=>` is not a valid Rust binary operator and syn will reject it. Scan at the token level.
  </action>
  <verify>
    Run: `cargo test -p rust-fv-macros 2>&1 | tail -20`
    Run: `cargo build -p rust-fv-analysis 2>&1 | tail -20` (verifies FnSpec IR compiles)
    Run: `cargo clippy -p rust-fv-macros -p rust-fv-analysis -- -D warnings 2>&1 | tail -30`
  </verify>
  <done>
    - `cargo test -p rust-fv-macros` passes including new fn_spec tests
    - `cargo build -p rust-fv-analysis` passes with FnSpec struct and fn_specs field on Contracts
    - clippy passes with no warnings in modified crates
  </done>
</task>

<task type="auto">
  <name>Task 2: Driver extraction of fn_spec doc attributes</name>
  <files>
    crates/driver/src/callbacks.rs
  </files>
  <action>
Extend `extract_contracts()` in `crates/driver/src/callbacks.rs` to parse `rust_fv::fn_spec::` doc attributes.

Find the existing doc-attribute parsing loop (around line 775 based on RESEARCH.md). In the `if let Some(doc) = extract_doc_value(attr)` block, add a new branch after the existing `borrow_ensures` / `ghost_predicate` branches:

```rust
} else if let Some(spec) = doc.strip_prefix("rust_fv::fn_spec::") {
    // Format: "PARAM::PRE_STR%%POST_STR"
    if let Some((param, rest)) = spec.split_once("::") {
        if let Some((pre_str, post_str)) = rest.split_once("%%") {
            // Extract bound_vars from pre_str: "|x: T| expr" -> bound_vars = ["x"]
            // Simple heuristic: if pre_str starts with '|', extract names between first two '|'
            let bound_vars = extract_bound_vars(pre_str);
            // The actual pre expression strips the leading "|vars|" prefix
            let pre_expr = strip_bound_var_prefix(pre_str);
            contracts.fn_specs.push(rust_fv_analysis::ir::FnSpec {
                closure_param: param.to_string(),
                pre: pre_expr,
                post: post_str.to_string(),
                bound_vars,
            });
        }
    }
}
```

Add two private helper functions in `callbacks.rs`:

```rust
/// Extract bound variable names from a fn_spec clause like "|x: i32| x > 0"
/// Returns ["x"] — strips type annotations, just the names.
fn extract_bound_vars(clause: &str) -> Vec<String> {
    // Find content between first | and second |
    // ...
}

/// Strip the "|x: T|" prefix from a clause, returning just the pre-expression.
fn strip_bound_var_prefix(clause: &str) -> String {
    // ...
}
```

Implement these as simple string operations (find first and second `|`, extract between them for names, return everything after second `|` trimmed for the expression). Edge case: if no `|` prefix (anonymous bound variable), return the whole string as the pre expression with empty bound_vars.

Also ensure `FnSpec` is imported or fully qualified from `rust_fv_analysis::ir`.

After adding, run `cargo build -p rust-fv-driver` and fix any type import or borrow errors.
  </action>
  <verify>
    Run: `cargo build -p rust-fv-driver 2>&1 | tail -20`
    Run: `cargo clippy -p rust-fv-driver -- -D warnings 2>&1 | tail -30`
    Run: `cargo test -p rust-fv-driver 2>&1 | tail -20`
  </verify>
  <done>
    - `cargo build -p rust-fv-driver` passes with fn_spec extraction code
    - `cargo clippy -p rust-fv-driver -- -D warnings` passes with no warnings
    - `cargo test -p rust-fv-driver` passes (all existing tests green)
    - The fn_spec extraction path is reachable via the existing doc attribute parsing loop
  </done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
```
cargo test -p rust-fv-macros -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -30
```
All existing tests must pass. New fn_spec macro tests must pass.

Verify FnSpec is accessible:
```
grep -n "pub struct FnSpec" crates/analysis/src/ir.rs
grep -n "fn_specs" crates/analysis/src/ir.rs
grep -n "rust_fv::fn_spec::" crates/driver/src/callbacks.rs
grep -n "fn_spec_impl\|pub fn fn_spec" crates/macros/src/lib.rs
```
All four greps must return results.
</verification>

<success_criteria>
- `#[fn_spec(f, |x: i32| x > 0 => result > 0)]` macro compiles and emits doc attribute with `rust_fv::fn_spec::f::` prefix
- `FnSpec` struct exists in `ir.rs` with `closure_param`, `pre`, `post`, `bound_vars` fields
- `Contracts.fn_specs` field exists and defaults to `vec![]`
- `extract_contracts()` parses `rust_fv::fn_spec::` doc attributes into `FnSpec` entries
- All existing tests pass (zero regressions)
- clippy passes on modified crates
</success_criteria>

<output>
After completion, create `.planning/phases/22-higher-order-closures/22-01-SUMMARY.md`
</output>

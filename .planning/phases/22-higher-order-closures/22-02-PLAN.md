---
phase: 22-higher-order-closures
plan: 02
type: execute
wave: 2
depends_on: [22-01]
files_modified:
  - crates/analysis/src/hof_vcgen.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
autonomous: true
requirements: [HOF-01, HOF-02]

must_haves:
  truths:
    - "generate_fn_spec_vcs() produces a ClosureContract VC with AUFLIA logic for each FnSpec entry in contracts.fn_specs"
    - "The VC asserts NOT(forall bound_vars. pre(x) => post(f_impl(env_f, x))) so UNSAT means the entailment holds"
    - "FnMut closures produce env_before_VARNAME and env_after_VARNAME SMT constants in the VC"
    - "generate_fn_spec_vcs() is called from generate_vcs() and results are included in FunctionVCs"
    - "FnOnce closures produce a single-call VC with no env_before/env_after looping"
  artifacts:
    - path: "crates/analysis/src/hof_vcgen.rs"
      provides: "generate_fn_spec_vcs() for Fn/FnOnce and generate_fn_mut_vcs() for FnMut"
      contains: "generate_fn_spec_vcs"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Call to generate_fn_spec_vcs() from generate_vcs()"
      contains: "generate_fn_spec_vcs"
    - path: "crates/analysis/src/lib.rs"
      provides: "pub mod hof_vcgen export"
      contains: "hof_vcgen"
  key_links:
    - from: "crates/analysis/src/vcgen.rs generate_vcs()"
      to: "crates/analysis/src/hof_vcgen.rs generate_fn_spec_vcs()"
      via: "called when func.contracts.fn_specs is non-empty"
      pattern: "generate_fn_spec_vcs"
    - from: "crates/analysis/src/hof_vcgen.rs"
      to: "crates/analysis/src/defunctionalize.rs encode_closure_as_uninterpreted()"
      via: "reuse existing uninterpreted function declaration"
      pattern: "encode_closure_as_uninterpreted"
    - from: "crates/analysis/src/hof_vcgen.rs"
      to: "VcKind::ClosureContract"
      via: "vc_kind field in emitted VerificationCondition"
      pattern: "VcKind::ClosureContract"
---

<objective>
Implement the VCGen engine for higher-order closure verification: a new hof_vcgen.rs module that generates AUFLIA-logic SMT scripts for fn_spec entailment queries, and wire it into generate_vcs() so closure specifications are verified end-to-end.

Purpose: This is the core verification logic — Plan 22-01 built the annotation pipeline; this plan makes the verifier actually check the entailments. Without this, fn_spec annotations are silently ignored.
Output: hof_vcgen.rs with generate_fn_spec_vcs() and generate_fn_mut_vcs(); vcgen.rs calls them; ClosureContract VCs emitted for every fn_spec clause.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-higher-order-closures/22-CONTEXT.md
@.planning/phases/22-higher-order-closures/22-RESEARCH.md
@.planning/phases/22-higher-order-closures/22-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hof_vcgen.rs with Fn/FnOnce and FnMut entailment VC generation</name>
  <files>
    crates/analysis/src/hof_vcgen.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
Create `crates/analysis/src/hof_vcgen.rs` as a new module implementing fn_spec VC generation.

**Step 1: Add to lib.rs**
Add `pub mod hof_vcgen;` in `crates/analysis/src/lib.rs` (alongside other module declarations).

**Step 2: Create hof_vcgen.rs**

The module must export one primary function:

```rust
/// Generate ClosureContract VCs for all fn_spec clauses in a function's contracts.
/// Returns a Vec of VerificationCondition ready to be appended to FunctionVCs.
pub fn generate_fn_spec_vcs(
    func: &Function,
    fn_specs: &[FnSpec],
) -> Vec<VerificationCondition>
```

**For each FnSpec, determine the closure trait:**
- Look up `func`'s parameters to find the parameter named `fn_spec.closure_param`
- Check its type: if `Ty::Closure(info)` with `info.trait_kind == ClosureTrait::FnMut` → call FnMut path
- Otherwise (Fn or FnOnce) → call standard path
- If parameter not found or type is opaque → treat as Fn (conservative)

**Standard path (Fn / FnOnce) — generates UNSAT entailment VC:**

```
(set-logic AUFLIA)
(declare-sort ClosureEnv_PARAM 0)
(declare-fun PARAM_impl (ClosureEnv_PARAM BOUND_SORT) RESULT_SORT)
(declare-const env_PARAM ClosureEnv_PARAM)
; For each bound var:
(declare-const BOUND_VAR BOUND_SORT)
; Assert negation of entailment (UNSAT = verified):
(assert (not (forall ((BOUND_VAR BOUND_SORT))
  (=> PRE_TERM
      POST_TERM_WITH_PARAM_impl))))
(check-sat)
```

Where:
- `BOUND_SORT` is derived from the bound variable's declared type (default `Int` if untyped)
- `PRE_TERM` is parsed from `fn_spec.pre` via `parse_spec_expr()` — convert to `Term`
- `POST_TERM` is parsed from `fn_spec.post` via `parse_spec_expr()` — references `PARAM_impl(env_PARAM, BOUND_VAR)` as the "result" term wherever `result` appears in the spec expression
- Use `Term::Forall(bound_vars_sorts, Box::new(Term::Implies(pre, post)), triggers)` where triggers come from `encode_quantifier::infer_triggers` called with the closure application term

**FnMut path — adds env_before/env_after:**

Extend the standard script with:
```
(declare-const env_before_CAPVAR SORT)  ; for each captured variable in ClosureInfo.env_fields
(declare-const env_after_CAPVAR SORT)
```

The `PARAM_impl` function takes `(env_before_CAPVAR..., BOUND_VAR)` → result.
The `env_after_CAPVAR` values are left unconstrained unless the postcondition references them — the postcondition axiom itself serves as the constraint per RESEARCH.md Pattern 4.

**FnOnce path:** Identical to Fn path — single-call VC with no repeated env tracking (per RESEARCH.md Pattern 6 and user decision). Do NOT add env_before/env_after for FnOnce.

**Emitting the VerificationCondition:**
```rust
VerificationCondition {
    description: format!("fn_spec({}, |{}| {} => {})",
        fn_spec.closure_param,
        fn_spec.bound_vars.join(", "),
        fn_spec.pre,
        fn_spec.post),
    script,
    location: VcLocation {
        function: func.name.clone(),
        block: 0,
        statement: 0,
        source_file: None,
        source_line: None,
        source_column: None,
        contract_text: Some(format!("|{}| {} => {}",
            fn_spec.bound_vars.join(", "), fn_spec.pre, fn_spec.post)),
        vc_kind: VcKind::ClosureContract,
    },
}
```

**Key constraints from RESEARCH.md:**
- Use `(set-logic AUFLIA)` NOT `QF_BV` — quantified VCs require non-QF logic
- Use `encode_closure_as_uninterpreted()` from `defunctionalize.rs` for the closure function declaration (do NOT re-implement)
- Env snapshot names: `env_before_VARNAME` / `env_after_VARNAME` — never numeric indices
- Trait coercion: if `ClosureTrait::FnMut` detected even when HOF bound says `Fn`, use FnMut encoding for soundness

**Parse spec expressions:** Use the existing `parse_spec_expr()` from `spec_parser.rs` (or `parse_spec_expr_with_db()` if ghost predicates are involved). When the expression fails to parse as a known Term, emit an `Assertion(BoolLit(true))` stub with a comment indicating uninterpreted spec — do not panic.
  </action>
  <verify>
    Run: `cargo build -p rust-fv-analysis 2>&1 | tail -30`
    Run: `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -30`
    Check: `grep -n "generate_fn_spec_vcs\|hof_vcgen" crates/analysis/src/vcgen.rs crates/analysis/src/lib.rs`
  </verify>
  <done>
    - `cargo build -p rust-fv-analysis` passes with hof_vcgen.rs compiled
    - `cargo clippy -p rust-fv-analysis -- -D warnings` passes with no warnings
    - `generate_fn_spec_vcs` is exported from `hof_vcgen` module
    - `pub mod hof_vcgen` appears in `lib.rs`
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generate_fn_spec_vcs() into generate_vcs() in vcgen.rs</name>
  <files>
    crates/analysis/src/vcgen.rs
  </files>
  <action>
Extend `generate_vcs()` in `crates/analysis/src/vcgen.rs` to call `generate_fn_spec_vcs()` when a function has fn_spec clauses.

**Locate the generate_vcs() function** (it's the main VCGen entry point returning `FunctionVCs`). After the existing VC generation logic (postconditions, concurrency VCs, etc.), add:

```rust
// HOF-01 / HOF-02: Generate fn_spec entailment VCs if any are declared
if !func.contracts.fn_specs.is_empty() {
    let hof_vcs = crate::hof_vcgen::generate_fn_spec_vcs(func, &func.contracts.fn_specs);
    conditions.extend(hof_vcs);
}
```

Place this after the weak memory VCs section (which was added in Phase 21) and before the final `FunctionVCs` construction — so the call ordering is:
1. Standard precondition/postcondition VCs
2. Memory safety VCs
3. Concurrency/weak memory VCs (Phase 21)
4. HOF fn_spec VCs (Phase 22, here)

**Verify the fn_specs field access:** `func.contracts.fn_specs` must be accessible — it was added in Plan 22-01. If the code uses a pattern like `let contracts = &func.contracts;`, adapt accordingly.

**No new logic needed in vcgen.rs itself** — all the fn_spec VC logic lives in hof_vcgen.rs. This task is purely wiring.

After wiring, run `cargo test -p rust-fv-analysis` to confirm all existing tests still pass (zero regressions from the wiring point — fn_specs is empty for all existing functions so the new branch is never taken in old tests).
  </action>
  <verify>
    Run: `cargo test -p rust-fv-analysis 2>&1 | tail -30`
    Run: `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -20`
    Check: `grep -n "generate_fn_spec_vcs\|fn_specs.is_empty" crates/analysis/src/vcgen.rs`
  </verify>
  <done>
    - `cargo test -p rust-fv-analysis` passes — all existing tests green, zero regressions
    - `cargo clippy -p rust-fv-analysis -- -D warnings` passes
    - `grep generate_fn_spec_vcs crates/analysis/src/vcgen.rs` returns a result
    - `func.contracts.fn_specs` is accessed in `generate_vcs()`
  </done>
</task>

</tasks>

<verification>
Full regression check:
```
cargo test -p rust-fv-macros -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -30
```
All tests must pass. The fn_spec VC pipeline is complete when:
- A function with a non-empty `fn_specs` field triggers `generate_fn_spec_vcs()` in vcgen
- The resulting VerificationConditions have `vc_kind: VcKind::ClosureContract`
- The SMT script uses `(set-logic AUFLIA)` (verify with grep in test output or direct SMT script inspection)

Inspect generated VC:
```
grep -n "AUFLIA\|ClosureContract\|fn_spec" crates/analysis/src/hof_vcgen.rs | head -20
```
</verification>

<success_criteria>
- hof_vcgen.rs exists and compiles with generate_fn_spec_vcs() exported
- vcgen.rs calls generate_fn_spec_vcs() when fn_specs is non-empty
- Fn/FnOnce path: emits (set-logic AUFLIA) + (not (forall ...)) assertion
- FnMut path: additionally emits env_before_VARNAME and env_after_VARNAME constants
- All existing tests pass — fn_specs defaults to empty vec[], so old functions are unaffected
- clippy passes on all modified crates
</success_criteria>

<output>
After completion, create `.planning/phases/22-higher-order-closures/22-02-SUMMARY.md`
</output>

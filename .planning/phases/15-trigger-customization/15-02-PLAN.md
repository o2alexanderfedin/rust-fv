---
phase: 15-trigger-customization
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/ir.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write #[trigger(expr)] inside forall/exists closure body and it is parsed correctly"
    - "Multiple #[trigger] attributes on same quantifier body produce multiple trigger sets (disjunction)"
    - "Multi-trigger conjunctions #[trigger(f(x), g(y))] are parsed as single trigger set"
    - "Trigger expressions are stored in IR alongside quantifier for later validation"
    - "Invalid trigger syntax produces clear parse error"
  artifacts:
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Trigger annotation parsing in convert_quantifier()"
      contains: "parse_trigger_hints"
    - path: "crates/analysis/src/ir.rs"
      provides: "TriggerHint type and storage in quantifier representation"
      contains: "TriggerHint"
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/analysis/src/ir.rs"
      via: "stores parsed trigger hints in IR quantifier data"
      pattern: "TriggerHint"
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/smtlib/src/term.rs"
      via: "converts trigger hint expressions to Term for later validation"
      pattern: "Term::App|Term::Const"
---

<objective>
Parse trigger annotation syntax from developer specifications and propagate through IR.

Purpose: Enable developers to write `#[trigger(expr)]` inside quantifier bodies in `#[requires]`/`#[ensures]` specifications. The parsed trigger hints are stored in the IR so Plan 03 can wire them into the validation and SMT generation pipeline.

Output: Extended spec_parser.rs that recognizes trigger annotations, IR types for trigger hints, comprehensive TDD test suite.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-trigger-customization/15-RESEARCH.md

# Key source files
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/ir.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD trigger hint IR types and spec parser extension</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/spec_parser.rs
  </files>
  <action>
Using TDD (RED-GREEN-REFACTOR), add trigger hint parsing to the spec parser.

**Step 1: IR Types (in ir.rs)**

Add `TriggerHint` struct:
```rust
/// A manual trigger hint from #[trigger(expr1, expr2)] annotation.
/// Each TriggerHint represents one trigger set (conjunction).
/// Multiple TriggerHints on same quantifier = disjunction (OR).
#[derive(Debug, Clone, PartialEq)]
pub struct TriggerHint {
    /// Terms in this trigger set (all must match for instantiation)
    pub terms: Vec<Term>,
}
```

Modify the Term enum or add a wrapper: Since Term::Forall/Term::Exists already exist in smtlib/term.rs and we don't want to modify the SMT-LIB layer with Rust-specific concepts, store trigger hints as **metadata alongside the spec** rather than inside Term.

Add to the specification representation in ir.rs (or wherever specs are stored before being converted to Terms):
- A `QuantifierSpec` struct or extend existing spec storage to carry `Vec<TriggerHint>` alongside the quantifier body
- OR: Use a side-channel approach where `parse_spec_expr` returns trigger hints alongside the Term via a result struct

**Recommended approach:** Extend `parse_spec_expr` return type. Create:
```rust
pub struct ParsedSpec {
    pub term: Term,
    pub trigger_hints: Vec<TriggerHint>,
}
```

Then `parse_spec_expr` returns `Option<ParsedSpec>` instead of `Option<Term>`. All existing callers that only need the Term can use `.term`. This is backward-compatible.

BUT: This changes the public API of parse_spec_expr which is used in many places. A simpler approach: use thread-local or a mutable context to collect trigger hints during parsing.

**Simplest approach (recommended):** Keep `parse_spec_expr` returning `Option<Term>` but add a new function `parse_spec_expr_with_triggers(spec: &str, func: &Function) -> Option<(Term, Vec<TriggerHint>)>` that wraps the existing parser and additionally extracts trigger annotations. The existing `parse_spec_expr` calls this and discards hints (backward compat).

**Step 2: Trigger Syntax Parsing**

The trigger annotation appears INSIDE the closure body of forall/exists in the specification string. Example:
```rust
#[requires(forall(|x: i32| #[trigger(f(x))] f(x) > 0))]
```

When `syn` parses this, the `#[trigger(f(x))]` appears as an attribute on the closure body expression. In `convert_quantifier`:
1. Before converting the closure body, check for `#[trigger(...)]` attributes on the body expression
2. Extract trigger expressions from each `#[trigger(...)]` attribute
3. Parse each trigger expression into a `Term` using the same `convert_expr_with_bounds` logic
4. Collect into `Vec<TriggerHint>`
5. Strip the trigger attributes from the body before converting it normally

For multi-trigger (conjunction): `#[trigger(f(x), g(y))]` parses as one TriggerHint with two terms.
For multiple trigger sets (disjunction): Two `#[trigger(f(x))]` `#[trigger(g(x))]` parse as two TriggerHints.

**Step 3: Storage and Propagation**

Store parsed trigger hints in a way accessible to encode_quantifier. Options:
- Return them alongside the Term (tuple return from convert_quantifier)
- Store in a new Term variant: `Term::QuantifierWithHints(vars, body, hints)` â€” but this pollutes SMT layer
- Use `Term::Annotated` with a custom annotation key like `"trigger_hint"` to carry hints through the Term tree until encode_quantifier processes them

**Best approach:** Use `Term::Annotated` with key `"rust_fv_trigger_hints"` to attach trigger hint terms to the quantifier body. This uses existing infrastructure, requires no new Term variants, and encode_quantifier can check for this annotation. Each trigger set becomes one annotation entry. Example:
```rust
Term::Forall(vars, Box::new(Term::Annotated(
    Box::new(body),
    vec![
        ("rust_fv_trigger_hint".to_string(), vec![f_x]),      // trigger set 1
        ("rust_fv_trigger_hint".to_string(), vec![g_x, h_y]), // trigger set 2 (multi-trigger)
    ]
)))
```

**TDD Test cases (write FIRST):**

```
// Basic trigger parsing
test_parse_trigger_single -> parse "forall(|x: i32| #[trigger(f(x))] f(x) > 0)" extracts trigger hint with f(x)
test_parse_trigger_multi_trigger -> parse "forall(|x: i32, y: i32| #[trigger(f(x), g(y))] ...)" extracts one hint with two terms
test_parse_trigger_multiple_sets -> parse with two #[trigger] attrs -> two trigger hints (disjunction)
test_parse_trigger_nested_quantifier -> trigger on inner quantifier only, outer unaffected
test_parse_no_trigger -> existing forall without trigger still works (backward compat)
test_parse_trigger_complex_expr -> trigger with nested function call: #[trigger(f(g(x)))]

// Error cases
test_parse_trigger_empty -> #[trigger()] is invalid, results in no trigger (or parse error)

// Integration with Term
test_trigger_stored_as_annotation -> parsed trigger appears as Term::Annotated with "rust_fv_trigger_hint" key
test_backward_compat_parse_spec_expr -> existing parse_spec_expr still returns same results for all existing tests
```

**Implementation order:**
1. Add TriggerHint to ir.rs
2. Write failing tests
3. Modify convert_quantifier in spec_parser.rs to detect and extract #[trigger(...)] attributes
4. Convert trigger expressions to Terms
5. Attach as Annotated terms
6. Green all tests
7. Refactor
  </action>
  <verify>
    cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis spec_parser -- --nocapture
    cargo test -p rust-fv-analysis -- --nocapture  # ensure no regressions
    cargo clippy -p rust-fv-analysis -- -D warnings
  </verify>
  <done>
    Spec parser recognizes #[trigger(expr)] inside forall/exists closures. Single triggers, multi-trigger conjunctions, and multiple trigger sets (disjunction) all parse correctly. Trigger hints stored as Term::Annotated with "rust_fv_trigger_hint" key. All existing spec_parser tests still pass (backward compat). No clippy warnings.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis spec_parser` - all parser tests pass including new trigger tests
2. `cargo test -p rust-fv-analysis` - full analysis crate tests pass (no regressions)
3. `cargo clippy -p rust-fv-analysis -- -D warnings` - no lint warnings
4. `cargo build --workspace` - full workspace compiles
</verification>

<success_criteria>
- #[trigger(expr)] annotation parsed correctly in forall/exists closures
- Multi-trigger and multiple trigger sets both supported
- Trigger hints propagated through Term::Annotated for downstream consumption
- All existing tests pass unchanged (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/15-trigger-customization/15-02-SUMMARY.md`
</output>

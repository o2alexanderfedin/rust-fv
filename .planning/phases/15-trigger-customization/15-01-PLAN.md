---
phase: 15-trigger-customization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/trigger_validation.rs
  - crates/analysis/src/lib.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Interpreted symbols (arithmetic, equality, array ops) in triggers are detected and rejected as errors"
    - "Self-instantiating trigger patterns are detected with concrete loop demonstration"
    - "Incomplete variable coverage in trigger sets is detected and reported"
    - "Excessive trigger sets (above limit) are rejected"
    - "Error messages follow Rustc-style formatting with error codes V015-V018"
    - "Error messages include auto-inferred trigger as suggested fix"
  artifacts:
    - path: "crates/analysis/src/trigger_validation.rs"
      provides: "TriggerValidator with validate(), find_interpreted_symbol(), detect_self_instantiation(), demonstrate_loop()"
      exports: ["TriggerValidator", "TriggerValidationError"]
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Trigger validation error formatting with V015-V018 error codes"
      contains: "format_trigger_error"
  key_links:
    - from: "crates/analysis/src/trigger_validation.rs"
      to: "crates/analysis/src/encode_quantifier.rs"
      via: "uses infer_triggers() and free_variables() for auto-inference suggestions and coverage checks"
      pattern: "infer_triggers|free_variables"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/trigger_validation.rs"
      via: "formats TriggerValidationError variants into Rustc-style diagnostics"
      pattern: "TriggerValidationError"
---

<objective>
Build the trigger validation engine and Rustc-style diagnostics for Phase 15 trigger customization.

Purpose: Provide the core validation logic that detects invalid trigger patterns (interpreted symbols, self-instantiation, incomplete coverage, excessive triggers) and formats errors using Rustc conventions (error codes V015-V018, spans, suggestions, fix examples). This is the foundation that Plan 02 (parsing) and Plan 03 (integration) build upon.

Output: Working `trigger_validation.rs` module with comprehensive TDD test suite, and extended `diagnostics.rs` with trigger error formatting.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-trigger-customization/15-RESEARCH.md

# Key source files
@crates/analysis/src/encode_quantifier.rs
@crates/smtlib/src/term.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD trigger validation engine (trigger_validation.rs)</name>
  <files>
    crates/analysis/src/trigger_validation.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
Create `crates/analysis/src/trigger_validation.rs` using TDD (RED-GREEN-REFACTOR).

**TDD Behavior Specification:**

1. `TriggerValidationError` enum with four variants:
   - `InterpretedSymbol { trigger: Term, symbol: String, auto_inferred: Vec<Vec<Term>> }`
   - `SelfInstantiation { trigger: Term, loop_example: String }`
   - `IncompleteCoverage { trigger: Term, missing_vars: Vec<String> }`
   - `TooManyTriggers { count: usize, limit: usize }`

2. `TriggerValidator` struct with `max_trigger_sets: usize` (default 10):
   - `validate(&self, trigger_sets: &[Vec<Term>], bound_vars: &[(String, Sort)], body: &Term) -> Result<(), TriggerValidationError>`

3. `find_interpreted_symbol(term: &Term) -> Option<String>`:
   - Returns `Some("+")` for `Term::BvAdd`, `Some("==")` for `Term::Eq`, etc.
   - Recursively checks into `Term::App` arguments (App itself is OK, args might not be)
   - Returns `None` for `Term::App`, `Term::Const`, literals
   - Covers: BvAdd/Sub/Mul/SDiv/UDiv, IntAdd/Sub/Mul/Div, Eq, all comparison ops (BvSLt/SLe/SGt/SGe/ULt/ULe/UGt/UGe, IntLt/IntLe/IntGt/IntGe), Select, Store
   - NOTE: The top-level trigger itself must be a function application (Term::App). If the trigger IS an arithmetic op like Term::BvAdd, that's an interpreted symbol error. Only recurse into App arguments.

4. `detect_self_instantiation(trigger: &Term, bound_vars: &[(String, Sort)]) -> bool`:
   - Simulate one instantiation step: replace each bound variable with a symbolic application `sym_varname(varname)`
   - Check if instantiated term contains a subterm that structurally matches the original trigger pattern
   - Conservative: may flag false positives, must not miss real loops
   - Example: trigger `f(g(x))` with bound var `x` -> instantiated `f(g(sym_x(x)))` -> check if any subterm matches pattern `f(g(_))` -> NO match here (safe). But trigger `f(g(x))` in body `P(f(g(x)))` where `g` appears in trigger output positions -> detect the loop

5. `demonstrate_loop(trigger: &Term, bound_vars: &[(String, Sort)]) -> String`:
   - Show 3 steps of the instantiation loop as string: "f(g(x)) -> f(g(g(x))) -> f(g(g(g(x)))) -> ..."

**Test cases (write FIRST, then implement):**

```
// Interpreted symbols
test_interpreted_symbol_bvadd -> find_interpreted_symbol(BvAdd(x,y)) == Some("+")
test_interpreted_symbol_eq -> find_interpreted_symbol(Eq(x,y)) == Some("==")
test_interpreted_symbol_intadd -> find_interpreted_symbol(IntAdd(x,y)) == Some("+ (int)")
test_interpreted_symbol_comparisons -> BvSLt returns Some("<"), BvSLe returns Some("<="), etc.
test_interpreted_symbol_select -> find_interpreted_symbol(Select(a,i)) == Some("select (array theory)")
test_interpreted_symbol_store -> Some("store (array theory)")
test_interpreted_symbol_app_clean -> find_interpreted_symbol(App("f", [Const("x")])) == None
test_interpreted_symbol_app_dirty_arg -> find_interpreted_symbol(App("f", [BvAdd(x,y)])) == Some("+")
test_interpreted_symbol_const -> find_interpreted_symbol(Const("x")) == None
test_interpreted_symbol_literal -> find_interpreted_symbol(IntLit(42)) == None

// Self-instantiation
test_self_instantiation_simple_app -> detect_self_instantiation(App("f", [Const("x")]), [("x", Int)]) == false
test_self_instantiation_nested_safe -> detect on App("f", [App("g", [Const("x")])]) == false when g doesn't produce f-shaped terms
test_self_instantiation_loop -> detect on trigger where instantiation creates matching subterm == true

// Coverage
test_coverage_complete -> validate with trigger covering all vars -> Ok
test_coverage_incomplete -> validate with trigger missing var y -> Err(IncompleteCoverage)
test_coverage_multi_trigger_set -> validate with multi-trigger [f(x), g(y)] covering both -> Ok

// Trigger limit
test_too_many_triggers -> validate with 11 trigger sets (limit 10) -> Err(TooManyTriggers)
test_within_limit -> validate with 10 trigger sets -> Ok (passes this check)

// Integration
test_validate_valid_trigger -> full validate() with clean trigger -> Ok
test_validate_interpreted_with_suggestion -> validate with arithmetic trigger, check auto_inferred populated
```

Add `pub mod trigger_validation;` to `crates/analysis/src/lib.rs`.

Make `free_variables` in `encode_quantifier.rs` public (change `fn free_variables` to `pub fn free_variables`) so trigger_validation can reuse it. Similarly make `infer_triggers` visible (already pub).
  </action>
  <verify>
    cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis trigger_validation -- --nocapture
    cargo clippy -p rust-fv-analysis -- -D warnings
  </verify>
  <done>
    All trigger_validation unit tests pass. TriggerValidator correctly detects interpreted symbols, self-instantiation, incomplete coverage, and excessive triggers. Error variants carry enough context for diagnostic formatting (auto-inferred suggestions, loop examples, missing vars).
  </done>
</task>

<task type="auto">
  <name>Task 2: Trigger validation diagnostics (V015-V018 error codes)</name>
  <files>
    crates/driver/src/diagnostics.rs
  </files>
  <action>
Extend `crates/driver/src/diagnostics.rs` with trigger validation error formatting.

Add `format_trigger_error` function that converts `TriggerValidationError` variants to Rustc-style diagnostic output:

1. **V015 - Interpreted Symbol:**
   ```
   error[V015]: trigger contains interpreted symbol `+`
     --> src/spec.rs:42:35
     reason: trigger `(bvadd x y)` uses arithmetic operator
     suggestion: Auto-inference suggests: `f(x)` instead
     note: Triggers must be uninterpreted function applications.
     help: for more information, run `rustc --explain V015`
   ```

2. **V016 - Self-Instantiation:**
   ```
   error[V016]: trigger causes self-instantiation loop
     reason: trigger `f(g(x))` self-instantiates
     loop: f(g(x)) -> f(g(g(x))) -> f(g(g(g(x)))) -> ...
     note: Avoid triggers where instantiation creates new matching terms.
     help: for more information, run `rustc --explain V016`
   ```

3. **V017 - Incomplete Coverage:**
   ```
   error[V017]: trigger does not cover bound variables: y
     reason: trigger `f(x)` missing variables
     note: Each trigger (or trigger set) must reference all quantified variables.
     help: Consider adding a multi-trigger that includes: y
     help: for more information, run `rustc --explain V017`
   ```

4. **V018 - Too Many Triggers:**
   ```
   error[V018]: too many trigger hints (15 exceeds limit of 10)
     note: Excessive triggers harm solver performance. Typical quantifiers need 1-3 trigger sets.
     help: for more information, run `rustc --explain V018`
   ```

Implementation:
- Add `use rust_fv_analysis::trigger_validation::TriggerValidationError;` import
- Create `pub fn format_trigger_error(error: &TriggerValidationError, function_name: &str)` that writes to stderr using `colored` crate (already in deps)
- Use existing formatting patterns from `report_text_only` and `report_with_ariadne` as style reference
- Helper: `fn format_term_compact(term: &Term) -> String` for displaying trigger terms in error messages (use SMT-LIB-like notation, simple recursive formatting)
- Helper: `fn format_trigger_sets(sets: &[Vec<Term>]) -> String` for displaying auto-inferred alternatives

Add unit tests:
- `test_format_trigger_error_interpreted_symbol` - verify output contains "V015" and symbol name
- `test_format_trigger_error_self_instantiation` - verify output contains "V016" and loop example
- `test_format_trigger_error_incomplete_coverage` - verify output contains "V017" and missing vars
- `test_format_trigger_error_too_many` - verify output contains "V018" and counts
  </action>
  <verify>
    cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-driver diagnostics -- --nocapture
    cargo clippy -p rust-fv-driver -- -D warnings
  </verify>
  <done>
    format_trigger_error produces Rustc-style output for all four error variants (V015-V018). Output includes error code, reason, suggestion with auto-inferred alternative (for V015), loop demonstration (for V016), missing variable list (for V017), and count/limit (for V018). All diagnostics tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis trigger_validation` - all validation logic tests pass
2. `cargo test -p rust-fv-driver diagnostics` - all diagnostic formatting tests pass
3. `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` - no lint warnings
4. `cargo build --workspace` - full workspace compiles
</verification>

<success_criteria>
- TriggerValidator correctly identifies all four error categories with zero false negatives for interpreted symbols
- Error variants carry sufficient context for rich diagnostic formatting
- Diagnostics follow Rustc conventions (error codes, colored output, suggestions)
- All tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/15-trigger-customization/15-01-SUMMARY.md`
</output>

---
phase: 28-smt-vcgen-completeness
plan: 03
type: execute
wave: 3
depends_on:
  - 28-02
files_modified:
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements:
  - VCGEN-02

must_haves:
  truths:
    - "Rvalue::Discriminant(place) produces a Term::App('discriminant-{local}', [Term::Const(local)]) — not None"
    - "Match arms with SwitchInt on discriminant get correct path conditions (discr==0, discr==1, etc.)"
    - "if-let Option pattern (SwitchInt + Downcast + Field) generates VCs with discriminant binding"
    - "vcgen_02_match_discr and vcgen_02_if_let tests both pass GREEN"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Rvalue::Discriminant arm in encode_assignment() returns a discriminant term instead of None"
      contains: "Rvalue::Discriminant"
  key_links:
    - from: "vcgen.rs Rvalue::Discriminant"
      to: "vcgen.rs Terminator::SwitchInt"
      via: "The discriminant term produced by encode_assignment is used as discr_term in SwitchInt path conditions"
      pattern: "discriminant-"
---

<objective>
Implement `Rvalue::Discriminant` binding in VCGen so match/if-let/while-let generate correct SMT path conditions.

Purpose: Currently `encode_assignment` returns `None` for `Rvalue::Discriminant` (vcgen.rs:1456 per RESEARCH.md). This means the discriminant variable is never bound in SMT context, causing SwitchInt path conditions to compare against a free (unconstrained) variable — producing unsound verification results for match expressions and if-let patterns.

Output: `Rvalue::Discriminant` arm emitting `Term::App("discriminant-{local}", [Term::Const(local)])`, both tests GREEN.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smt-vcgen-completeness/28-RESEARCH.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/tests/vcgen_completeness28.rs
@.planning/phases/28-smt-vcgen-completeness/28-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Rvalue::Discriminant in encode_assignment</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Find and replace the discriminant stub in `encode_assignment()` in vcgen.rs.

**Current stub (RESEARCH.md vcgen.rs:1456):**
```rust
Rvalue::Discriminant(_) => {
    return None;  // or similar — discriminant not yet encoded
}
```

**Replacement (per RESEARCH.md Pattern 2 and Code Examples section):**
```rust
Rvalue::Discriminant(disc_place) => {
    // Encode the discriminant of an enum value as an uninterpreted selector function.
    // The discriminant is an integer tag that SwitchInt compares against literal variant indices.
    // We declare it as: (discriminant-{local} {enum_value}) where enum_value is the place.
    // This produces Term::App which the SwitchInt path-condition logic already handles correctly —
    // SwitchInt compares discr_term against BitVecLit values for each target arm.
    let disc_fn = format!("discriminant-{}", disc_place.local);
    Term::App(disc_fn, vec![Term::Const(disc_place.local.clone())])
}
```

**Where to find encode_assignment:** Search in vcgen.rs for `fn encode_assignment` or the match arm `Rvalue::Discriminant`. The function is within `traverse_block` or called by it.

**Key context (RESEARCH.md Pitfall 3):** SwitchInt targets carry correct discriminant values as `(value, BlockId)` pairs. Do NOT normalize or remap — the existing SwitchInt path-condition code already uses these values correctly. The only gap is that `disc_place.local` was unbound; now it is bound as `Term::App("discriminant-{local}", ...)`.

**Important edge case:** The `disc_place.local` string must match the local variable name used in the subsequent SwitchInt's `discr` operand. Verify this is the same name by checking how SwitchInt's `discr: Operand::Copy(place)` place.local is encoded in the existing SwitchInt handler. Both must use the same term for the discriminant equality comparison to work.

**Downcast + Field projection:** The `Projection::Downcast(variant_idx)` case in `encode_place_with_type` currently has a comment `// Enum downcast is handled during pattern matching`. For this plan: if Downcast is already handled (passes through), the vcgen_02_if_let test will pass after the Discriminant fix. If Downcast returns an error or identity, add handling for `Projection::Downcast(_) => encode_place_inner(...)` (pass through to parent place — the variant value is the same memory, just retyped).

**After the change:**
1. Run `cargo clippy -p rust-fv-analysis -- -D warnings` and fix all warnings.
2. Run `cargo fmt -p rust-fv-analysis` to format.
3. Run the two vcgen_02 tests.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 vcgen_02 2>&1 | grep -E "vcgen_02|FAILED|ok"</automated>
    <manual>Both vcgen_02_match_discr and vcgen_02_if_let should show "ok". The SMT script text for match functions should contain "discriminant-" substring. Run: cargo test -p rust-fv-analysis 2>&1 | tail -10 to confirm no regressions.</manual>
  </verify>
  <done>vcgen_02_match_discr and vcgen_02_if_let both PASS. encode_assignment no longer returns None for Rvalue::Discriminant. cargo test -p rust-fv-analysis shows no new failures. clippy clean.</done>
</task>

<task type="auto">
  <name>Task 2: Declare discriminant function in SMT declarations</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Ensure the uninterpreted function `discriminant-{local}` is declared in the SMT script before it is used in assertions.

In SMT-LIB2, every function used must be declared with `(declare-fun ...)`. The `Term::App("discriminant-{local}", [enum_term])` we create in Task 1 references an uninterpreted function that must be declared.

**Location:** In `generate_vcs_with_db()` (or `generate_contract_vcs()`), where the `declarations` vector is built. After collecting all local variable declarations, add declarations for any discriminant functions encountered in the function body.

**Algorithm:**
1. Scan `func.basic_blocks` for `Statement::Assign(_, Rvalue::Discriminant(disc_place))`.
2. For each such disc_place, add to declarations:
   ```rust
   // Declare: (declare-fun discriminant-{local} (EnumSort) (_ BitVec 8))
   // Since we use uninterpreted sort for enum: use the encoded sort of disc_place type
   let disc_sort = encode_type(&disc_place_ty); // sort of the enum value
   Command::DeclareFun(
       format!("discriminant-{}", disc_place.local),
       vec![disc_sort],
       Sort::BitVec(8), // discriminant is a small integer tag
   )
   ```
3. Scan happens before VCs are generated, same as how local `DeclareConst` commands are emitted.

**If `Command::DeclareFun` does not exist in the smtlib crate:** Check `crates/smtlib/src/command.rs` for the available command variants. The common alternatives are `DeclareConst` (zero-arg function) or a `DeclareFun` variant. If only DeclareConst exists, declare as a BitVec(8) constant named `discriminant-{local}` (zero-argument application is equivalent for uninterpreted constants).

**If `Command::DeclareFun` variant needs a simple uninterpreted function with one argument:** use `Command::DeclareConst(format!("discriminant-{local}_tag"), Sort::BitVec(8))` and change the Term to `Term::Const(format!("discriminant-{local}_tag"))`. Update vcgen_02 tests accordingly.

**Note:** This task may be trivially satisfied if Z3 accepts undeclared function symbols in the logic string being used. Test first: if vcgen_02_* already pass after Task 1 without this declaration task, skip this task and note it in the summary.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_02|test result"</automated>
    <manual>Confirm both vcgen_02 tests pass. Additionally confirm full suite shows no regressions: cargo test -p rust-fv-analysis 2>&1 | grep -E "FAILED|test result"</manual>
  </verify>
  <done>Both vcgen_02_* tests pass. Z3 does not report "unknown function" errors for discriminant functions. Full test suite shows no regressions.</done>
</task>

</tasks>

<verification>
cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_02|test result"
cargo test -p rust-fv-analysis 2>&1 | tail -5
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -5
</verification>

<success_criteria>
- `Rvalue::Discriminant` arm in `encode_assignment` returns `Some(Term::App(...))` — no longer `None`
- `vcgen_02_match_discr` PASSES: generated SMT script contains "discriminant-" term
- `vcgen_02_if_let` PASSES: SwitchInt path conditions reference the discriminant term
- Full `cargo test -p rust-fv-analysis` shows no new FAILED tests vs pre-plan baseline
- `cargo clippy -p rust-fv-analysis -- -D warnings` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/28-smt-vcgen-completeness/28-03-SUMMARY.md`
</output>

---
phase: 28-smt-vcgen-completeness
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/tests/vcgen_completeness28.rs
autonomous: true
requirements:
  - VCGEN-01
  - VCGEN-02
  - VCGEN-03
  - VCGEN-04

must_haves:
  truths:
    - "All 10 VCGEN-01..04 tests exist and compile"
    - "Every test fails RED (not a compile error, but a logic failure) before implementation"
    - "Test file is auto-discovered by cargo test via naming convention"
  artifacts:
    - path: "crates/analysis/tests/vcgen_completeness28.rs"
      provides: "TDD scaffold for all VCGEN-01..04 behaviors"
      contains: "vcgen_01_array_index, vcgen_01_field_projection, vcgen_01_slice_len, vcgen_02_match_discr, vcgen_02_if_let, vcgen_03_cast_sign_extend, vcgen_03_cast_truncate, vcgen_03_transmute, vcgen_04_trait_bound, vcgen_04_generic_spec"
  key_links:
    - from: "crates/analysis/tests/vcgen_completeness28.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "generate_vcs() and generate_vcs_with_db() calls in tests"
      pattern: "generate_vcs|generate_vcs_with_db"
    - from: "crates/analysis/tests/vcgen_completeness28.rs"
      to: "crates/analysis/src/encode_term.rs"
      via: "encode_cast() call (to be created)"
      pattern: "encode_cast|encode_int_to_int_cast"
---

<objective>
Create the TDD test scaffold for Phase 28: all 10 failing tests for VCGEN-01 through VCGEN-04.

Purpose: Nyquist rule — every `<verify>` in Plans 02-05 requires an automated test. All tests must fail RED before implementation begins. The test file establishes the behavioral contracts for casts, discriminant binding, array bounds, and generic premises.

Output: `crates/analysis/tests/vcgen_completeness28.rs` with 10 test functions, all failing due to unimplemented behavior.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smt-vcgen-completeness/28-RESEARCH.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/monomorphize.rs
@crates/smtlib/src/term.rs
@crates/analysis/tests/completeness_suite.rs
</context>

<feature>
  <name>VCGEN-01..04 TDD Test Scaffold</name>
  <files>crates/analysis/tests/vcgen_completeness28.rs</files>
  <behavior>
10 test functions, one per test map entry from RESEARCH.md Validation Architecture section.

**VCGEN-01 Memory Operations:**
- `vcgen_01_array_index`: Build an IR Function with a Projection::Index access. Call generate_vcs(). Assert that at least one VC has description containing "bounds" or VcKind::BoundsCheck. Currently FAILS because no bounds VC is generated for Index projections.
- `vcgen_01_field_projection`: Build an IR Function with a struct type and Projection::Field. Call generate_vcs(). Assert that the SMT script contains a selector function term (e.g., `selector-field` or Term::App with field selector). Should PASS already if field projection is working — mark as compile-only check, assert VC count > 0 and script is non-empty. (This may already pass; if so, document as green.)
- `vcgen_01_slice_len`: Build an IR Function with Rvalue::Len(place). Call generate_vcs(). Assert the VCs vector is non-empty (not currently generated). Currently FAILS because Rvalue::Len returns None from encode_assignment.

**VCGEN-02 Conditional Operators:**
- `vcgen_02_match_discr`: Build an IR Function with Rvalue::Discriminant(place) + SwitchInt terminator. Call generate_vcs(). Assert that the generated SMT script contains a discriminant term (e.g., `discriminant-` prefix) in the script text. Currently FAILS because encode_assignment returns None for Rvalue::Discriminant.
- `vcgen_02_if_let`: Build an IR Function with a SwitchInt on an Option discriminant (0=None, 1=Some) and a Downcast+Field projection in the Some branch. Assert that the two path conditions (discr==0, discr==1) appear in the generated VCs. Currently FAILS for same reason as vcgen_02_match_discr.

**VCGEN-03 Typecasts:**
- `vcgen_03_cast_sign_extend`: Directly call `encode_int_to_int_cast(src_term, 8, 32, true)` where src_term is Term::Const("x".into()). Assert the result is Term::SignExtend(24, _). Currently FAILS because encode_int_to_int_cast does not yet exist.
- `vcgen_03_cast_truncate`: Directly call `encode_int_to_int_cast(src_term, 64, 32, false)`. Assert the result is Term::Extract(31, 0, _). Currently FAILS because function does not exist.
- `vcgen_03_transmute`: Build an IR Function with Rvalue::Cast(CastKind::IntToFloat, op, Ty::Float(FloatTy::F32)). Call generate_vcs(). Assert the generated script does NOT contain the source bitvector literal at 64-bit width (i.e., truncation occurred). Currently FAILS because cast is identity stub.

**VCGEN-04 Generics:**
- `vcgen_04_trait_bound`: Directly call `trait_bounds_as_smt_assumptions(&generic_param, &concrete_ty)` where generic_param has one Ord trait bound and concrete_ty is Ty::Int(IntTy::I32). Assert result is Vec of length 1 containing Term::BoolLit(true). Currently FAILS because function does not exist.
- `vcgen_04_generic_spec`: Build a generic IR Function with one GenericParam and a postcondition spec. Call generate_vcs_with_db() with a GhostPredicateDatabase. Assert that VCs are non-empty. (Partial test — full propagation tested after VCGEN-04 implementation.) Should FAIL with current implementation because trait bounds are not injected.

**Test helpers to build:**
- `solver_or_skip()` pattern from existing tests (check Z3 available or skip)
- `build_array_index_function()` — Function IR with array parameter and Projection::Index in body
- `build_discriminant_function()` — Function IR with an enum-typed local and Rvalue::Discriminant + SwitchInt
- `build_cast_function(kind, from_ty, to_ty)` — Function IR with a single Rvalue::Cast assignment
- `build_generic_function()` — Function IR with one GenericParam (T: Ord) and simple postcondition

Follow the pattern from `crates/analysis/tests/completeness_suite.rs`:
- Use `use rust_fv_analysis::ir::*;` and `use rust_fv_analysis::vcgen::*;`
- Format SMT script to text for string-based assertions: `format!("{}", script)`
- Helper `make_z3_solver()` for Z3 availability guard

  </behavior>
  <implementation>
**RED phase:** Write all 10 test functions. Run `cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -30`. Confirm tests that test unimplemented functions (VCGEN-01 slice_len, VCGEN-02 discr, VCGEN-03 casts, VCGEN-04) fail with `error[E0425]: cannot find function` or assertion panics, NOT compile errors in the test file itself.

**Commit RED:** `test(28-01): add failing TDD scaffold for VCGEN-01..04`

Note: vcgen_01_field_projection may already pass (field projection works). In that case, restructure the test to assert a specific selector name format so it still guards against regression.

Do NOT implement any production code in this plan. The sole artifact is the test file.
  </implementation>
</feature>

<verification>
<automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -30</automated>
<manual>Confirm test output shows failures for vcgen_01_slice_len, vcgen_02_match_discr, vcgen_02_if_let, vcgen_03_* (3 tests), vcgen_04_* (2 tests). Failures must be logic failures (assertion panic or missing function), not compile errors.</manual>
</verification>

<success_criteria>
- `crates/analysis/tests/vcgen_completeness28.rs` exists with 10 test functions
- File compiles cleanly (no syntax errors, imports resolved)
- Tests for unimplemented features fail with assertion errors or missing-symbol errors
- Tests that may already pass (vcgen_01_field_projection) are written as regression guards
- `cargo test -p rust-fv-analysis 2>&1 | grep FAILED | wc -l` shows at least 7 test failures
</success_criteria>

<output>
After completion, create `.planning/phases/28-smt-vcgen-completeness/28-01-SUMMARY.md`
</output>

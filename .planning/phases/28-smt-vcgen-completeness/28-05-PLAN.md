---
phase: 28-smt-vcgen-completeness
plan: 05
type: execute
wave: 5
depends_on:
  - 28-04
files_modified:
  - crates/analysis/src/monomorphize.rs
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements:
  - VCGEN-04

must_haves:
  truths:
    - "trait_bounds_as_smt_assumptions() exists in monomorphize.rs and returns Vec<Term>"
    - "Generic functions with where-clause bounds get SMT Assert premises in generated VCs"
    - "vcgen_04_trait_bound and vcgen_04_generic_spec tests both pass GREEN"
    - "Existing generic function tests (monomorphization) show no regressions"
  artifacts:
    - path: "crates/analysis/src/monomorphize.rs"
      provides: "trait_bounds_as_smt_assumptions(gp: &GenericParam, concrete_ty: &Ty) -> Vec<Term>"
      exports: ["trait_bounds_as_smt_assumptions"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "generate_vcs_with_db injects trait bound premises via Assert commands before postcondition VCs"
      contains: "trait_bounds_as_smt_assumptions"
  key_links:
    - from: "vcgen.rs generate_vcs_with_db"
      to: "monomorphize.rs trait_bounds_as_smt_assumptions()"
      via: "Called in generate_vcs_monomorphized when func.generic_params is non-empty"
      pattern: "trait_bounds_as_smt_assumptions"
---

<objective>
Implement generic where-clause constraints as SMT premise injection (VCGEN-04).

Purpose: `trait_bound_constraints()` in monomorphize.rs returns `Vec<String>` (human-readable only) and is never wired to VCGen. Generic functions with `T: Ord` or `T: PartialEq` bounds produce VCs with no assumption about T's ordering properties. This plan adds `trait_bounds_as_smt_assumptions()` returning `Vec<Term>` and injects the premises into generated VCs.

Output: `trait_bounds_as_smt_assumptions()` in monomorphize.rs, premise injection in vcgen.rs, 2 tests GREEN.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smt-vcgen-completeness/28-RESEARCH.md
@crates/analysis/src/monomorphize.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/smtlib/src/term.rs
@crates/analysis/tests/vcgen_completeness28.rs
@.planning/phases/28-smt-vcgen-completeness/28-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trait_bounds_as_smt_assumptions() in monomorphize.rs</name>
  <files>crates/analysis/src/monomorphize.rs</files>
  <action>
Add a new public function `trait_bounds_as_smt_assumptions()` to `crates/analysis/src/monomorphize.rs`.

**Context (RESEARCH.md):**
- `trait_bound_constraints()` at line 253-300 already exists and returns `Vec<String>` (human-readable).
- `GenericParam` struct has a `trait_bounds: Vec<TraitBound>` or similar field (inspect the struct definition in ir.rs or monomorphize.rs).
- The new function returns `Vec<Term>` for injection into SMT as `Command::Assert` premises.

**Implementation per RESEARCH.md Pattern 4:**

```rust
use rust_fv_smtlib::term::Term;
use crate::ir::{GenericParam, Ty};

/// Produce SMT-LIB Assert premises encoding a generic parameter's trait bound constraints.
///
/// For integer types with Ord/PartialOrd/Eq/PartialEq: the constraints are trivially true
/// in BV semantics (total order is guaranteed by bitvector comparisons). We emit
/// `Term::BoolLit(true)` as a no-op assumption — it documents the contract without
/// adding false premises.
///
/// For unrecognized/composite types: emit `Term::BoolLit(true)` conservatively (no
/// contradiction, no false implications).
///
/// Safety note (RESEARCH.md Pitfall 5): Do NOT emit incorrect ordering assumptions for
/// non-integer types. If T is not a known integer type, always emit BoolLit(true).
pub fn trait_bounds_as_smt_assumptions(gp: &GenericParam, concrete_ty: &Ty) -> Vec<Term> {
    // Check concrete_ty — for known integer/bool types, all standard trait bounds
    // (Ord, PartialOrd, Eq, PartialEq, Copy, Clone) are trivially satisfied by BV semantics.
    // Return BoolLit(true) for each bound as a no-op documented assumption.
    //
    // For unrecognized types: same conservative approach — emit BoolLit(true).
    // This is sound: we never add false premises.
    gp.trait_bounds.iter().map(|_bound| Term::BoolLit(true)).collect()
}
```

**If GenericParam has no `trait_bounds` field:** Inspect the struct definition in ir.rs. The field may be named differently (e.g., `bounds`, `constraints`, `where_bounds`). Use the actual field name. If no trait bound field exists at all, add one:

```rust
// In ir.rs GenericParam struct (if trait_bounds field is missing):
pub struct GenericParam {
    pub name: String,
    pub trait_bounds: Vec<String>, // trait names as strings (e.g., "Ord", "Clone")
}
```

If adding a field to GenericParam, update all construction sites with `trait_bounds: vec![]` (backward-compatible empty default).

**After implementation:**
- `cargo build -p rust-fv-analysis` must succeed.
- Run `cargo test -p rust-fv-analysis vcgen_04_trait_bound` — should PASS after this task.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis vcgen_04_trait_bound 2>&1 | grep -E "vcgen_04_trait_bound|FAILED|ok"</automated>
    <manual>vcgen_04_trait_bound calls trait_bounds_as_smt_assumptions() with a GenericParam(Ord bound) and i32. Asserts Vec length == 1 and first element == Term::BoolLit(true). Should PASS after this task.</manual>
  </verify>
  <done>trait_bounds_as_smt_assumptions() exported from monomorphize.rs. vcgen_04_trait_bound PASSES. cargo build -p rust-fv-analysis exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Inject trait bound premises in generate_vcs_monomorphized</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Wire `trait_bounds_as_smt_assumptions()` into the VCGen pipeline for generic functions.

**Location (RESEARCH.md vcgen.rs:987-1039):** `generate_vcs_monomorphized()` and/or the caller of `generate_vcs_with_db()` when the function has generic params.

**Strategy:** In `generate_vcs_with_db` (or `generate_vcs_monomorphized`), after building the declarations list and before the postcondition/precondition VC scripts are finalized, inject trait bound assumptions as `Command::Assert` commands.

```rust
// In generate_vcs_with_db or generate_vcs_monomorphized,
// AFTER declarations are built, BEFORE VCs are appended:
if !func.generic_params.is_empty() {
    // For each generic param, inject its trait bound assumptions as SMT premises
    // These become assumptions in ALL VCs for this function
    for gp in &func.generic_params {
        // Get the concrete type substitution for this param (from monomorphization context)
        // If no concrete type is available yet (non-monomorphized call), use Ty::Generic
        let concrete_ty = /* get from substitution_map if available, else Ty::Generic(gp.name.clone()) */;
        let assumptions = crate::monomorphize::trait_bounds_as_smt_assumptions(gp, &concrete_ty);
        for term in assumptions {
            // Inject as a declaration-level Assert (premise, not negated)
            declarations.push(Command::Assert(term));
        }
    }
}
```

**Important:** The assumptions are injected as positive `Assert` commands (premises), NOT negated. They serve as axioms/assumptions that hold for the generic instantiation. For `BoolLit(true)`, Z3 ignores them harmlessly.

**Check `generate_vcs_monomorphized`:** Per RESEARCH.md (vcgen.rs:987-1039), this function calls `generate_vcs_with_db` with a concrete substitution map. The concrete type for each GenericParam is available via the `TypeInstantiation.substitutions` map. Thread this through:

```rust
// In generate_vcs_monomorphized, before calling generate_vcs_with_db:
// The substitution map maps generic param name -> concrete Ty
// Pass this context so trait_bounds_as_smt_assumptions gets the concrete type

// Simplest approach: monomorphize the function first (substitute_generics),
// then the generic_params list in the monomorphized func will be empty.
// So inject premises BEFORE substitution, using the instantiation map.
let monomorphized = crate::monomorphize::substitute_generics(func, instantiation);
// After substitution, generic_params is empty in monomorphized.
// Inject premises based on ORIGINAL func.generic_params + instantiation.substitutions.
for gp in &func.generic_params {
    let concrete_ty = instantiation.substitutions.get(&gp.name)
        .cloned()
        .unwrap_or(Ty::Bool); // fallback
    let assumptions = crate::monomorphize::trait_bounds_as_smt_assumptions(gp, &concrete_ty);
    // Add assertions to all VCs generated for this instantiation
}
```

**Spec annotation propagation:** The spec expression (postcondition) of a generic function uses type parameter names as free variables. After `substitute_generics()`, these are replaced by concrete types. The existing spec parser already handles generic parameter names as free constants in `int_mode` (RESEARCH.md). No additional wiring needed for spec propagation.

**After implementation:**
1. Run `cargo clippy -p rust-fv-analysis -- -D warnings` and fix warnings.
2. Run `cargo fmt -p rust-fv-analysis`.
3. Run both vcgen_04_* tests.
4. Run full test suite for regressions.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_04|test result"</automated>
    <manual>Both vcgen_04_trait_bound and vcgen_04_generic_spec should PASS. Full suite regression check: cargo test -p rust-fv-analysis 2>&1 | tail -10. Verify existing generic function tests still pass (e.g., from phase 04 monomorphization tests).</manual>
  </verify>
  <done>Both vcgen_04_* tests PASS. Trait bound premises injected in generate_vcs_monomorphized. Full cargo test -p rust-fv-analysis shows no new FAILED tests. clippy clean.</done>
</task>

</tasks>

<verification>
cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -15
cargo test -p rust-fv-analysis 2>&1 | tail -10
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -5
cargo clippy -p rust-fv-driver -- -D warnings 2>&1 | tail -5
</verification>

<success_criteria>
- `trait_bounds_as_smt_assumptions()` exported from `monomorphize.rs`
- `generate_vcs_monomorphized` injects trait bound premises via `Command::Assert`
- `vcgen_04_trait_bound` PASSES: Vec<Term> length == number of bounds, each BoolLit(true)
- `vcgen_04_generic_spec` PASSES: VCs non-empty for generic function with postcondition
- All 10 vcgen_completeness28 tests pass GREEN
- Full `cargo test -p rust-fv-analysis` shows no regressions vs baseline
- clippy clean on rust-fv-analysis and rust-fv-driver crates
</success_criteria>

<output>
After completion, create `.planning/phases/28-smt-vcgen-completeness/28-05-SUMMARY.md`
</output>

---
phase: 28-smt-vcgen-completeness
plan: 02
type: execute
wave: 2
depends_on:
  - 28-01
files_modified:
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements:
  - VCGEN-03

must_haves:
  truths:
    - "i8 as i32 (sign-extending cast) encodes as Term::SignExtend(24, src)"
    - "u64 as i32 (narrowing cast) encodes as Term::Extract(31, 0, src)"
    - "f32 transmute from u32 encodes as bitvector reinterpretation (FpFromBits), not identity"
    - "No-op casts (same-bit-width reinterpret) pass through as identity"
    - "vcgen_03_* tests in vcgen_completeness28.rs all pass GREEN"
  artifacts:
    - path: "crates/analysis/src/encode_term.rs"
      provides: "encode_cast(), encode_int_to_int_cast(), encode_int_to_float_cast(), encode_float_to_int_cast()"
      exports: ["encode_cast", "encode_int_to_int_cast"]
      min_lines: 50
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Rvalue::Cast arm in encode_assignment() calls encode_cast() instead of identity stub"
      contains: "encode_cast"
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_term.rs"
      via: "encode_cast() call in Rvalue::Cast arm of encode_assignment()"
      pattern: "encode_cast\\(kind"
    - from: "crates/analysis/src/encode_term.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Term::SignExtend, Term::ZeroExtend, Term::Extract, Term::FpFromBits"
      pattern: "Term::(SignExtend|ZeroExtend|Extract|FpFromBits)"
---

<objective>
Implement correct SMT encoding for Rust numeric `as` casts and `transmute`.

Purpose: The current `Rvalue::Cast` handler (vcgen.rs:1444) is an identity stub — it discards the target type and returns the source operand unchanged. This creates soundness holes: `u64 as i32` passes full 64-bit width through, `i8 as i32` loses sign information. This plan replaces the stub with correct BV extend/truncate/reinterpret encoding.

Output: `encode_cast()` in `encode_term.rs`, updated `Rvalue::Cast` arm in `vcgen.rs`, 3 tests GREEN.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smt-vcgen-completeness/28-RESEARCH.md
@crates/analysis/src/encode_term.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/smtlib/src/term.rs
@crates/analysis/tests/vcgen_completeness28.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement encode_cast() in encode_term.rs</name>
  <files>crates/analysis/src/encode_term.rs</files>
  <action>
Add public function `encode_cast()` and its private helpers to `crates/analysis/src/encode_term.rs`.

**Exact implementation per RESEARCH.md Pattern 1:**

```rust
use std::cmp::Ordering;
use rust_fv_analysis::ir::{CastKind, Ty, IntTy, UintTy, FloatTy};
use rust_fv_smtlib::term::Term;

/// Encode a Rust `as` cast or `transmute` as an SMT-LIB term.
///
/// `kind`: the cast kind from IR
/// `src`: the already-encoded source operand term
/// `from_bits`: bit width of source type (from `ty_bit_width(source_ty)`)
/// `to_bits`: bit width of target type
/// `from_signed`: whether source integer type is signed
pub fn encode_cast(kind: &CastKind, src: Term, from_bits: u32, to_bits: u32, from_signed: bool) -> Term {
    match kind {
        CastKind::IntToInt => encode_int_to_int_cast(src, from_bits, to_bits, from_signed),
        CastKind::IntToFloat => encode_int_to_float_cast(src, from_bits, to_bits, from_signed),
        CastKind::FloatToInt => encode_float_to_int_cast(src, from_bits, to_bits),
        CastKind::FloatToFloat => encode_float_to_float_cast(src, from_bits, to_bits),
        // Pointer casts: identity on bitvector (pointer is BitVec 64)
        CastKind::Pointer => src,
    }
}

/// Integer-to-integer cast: widening (zero/sign extend) or narrowing (extract low bits).
pub fn encode_int_to_int_cast(src: Term, from_bits: u32, to_bits: u32, from_signed: bool) -> Term {
    match from_bits.cmp(&to_bits) {
        Ordering::Equal   => src,  // no-op cast (reinterpret, same width)
        Ordering::Less    => if from_signed {
            Term::SignExtend(to_bits - from_bits, Box::new(src))
        } else {
            Term::ZeroExtend(to_bits - from_bits, Box::new(src))
        },
        Ordering::Greater => Term::Extract(to_bits - 1, 0, Box::new(src)),
    }
}

/// Integer-to-float cast (as per transmute semantics): reinterpret bits as float.
/// For IntToFloat casts from arithmetic context, we use FpFromBits on the source BV.
fn encode_int_to_float_cast(src: Term, from_bits: u32, to_bits: u32, from_signed: bool) -> Term {
    // Ensure source is the right bit width for the target float
    let adjusted = if from_bits == to_bits {
        src
    } else {
        encode_int_to_int_cast(src, from_bits, to_bits, from_signed)
    };
    Term::FpFromBits(Box::new(adjusted))
}

/// Float-to-integer cast: extract raw bits via concat of sign/exponent/mantissa.
/// We model this as a round-to-zero integer conversion using Bv2Int then clamp.
/// For simplicity (sound approximation): use identity on the BV representation.
fn encode_float_to_int_cast(src: Term, _from_bits: u32, to_bits: u32) -> Term {
    // Conservative: model as extraction of the lower to_bits from the float BV
    // This is an approximation — float-to-int is complex; leave as extract for now
    // TODO Phase 29: proper rtz conversion
    Term::Extract(to_bits - 1, 0, Box::new(src))
}

/// Float-to-float cast (f32 ↔ f64): treat as float conversion via FpFromBits.
fn encode_float_to_float_cast(src: Term, from_bits: u32, to_bits: u32) -> Term {
    // For same-size: identity. Different size: FpFromBits after width adjustment.
    if from_bits == to_bits {
        src
    } else {
        // Truncation or extension of float BV representation
        let adjusted = if from_bits < to_bits {
            Term::ZeroExtend(to_bits - from_bits, Box::new(src))
        } else {
            Term::Extract(to_bits - 1, 0, Box::new(src))
        };
        Term::FpFromBits(Box::new(adjusted))
    }
}
```

**Helper: `ty_bit_width(ty: &Ty) -> u32`** — if this does not already exist in encode_term.rs or encode_sort.rs, add it:

```rust
/// Returns the bit width of a Rust numeric type, or 64 as default for pointers/unknown.
pub fn ty_bit_width(ty: &Ty) -> u32 {
    match ty {
        Ty::Int(int_ty) => match int_ty {
            IntTy::I8  => 8,   IntTy::I16 => 16,
            IntTy::I32 => 32,  IntTy::I64 => 64,
            IntTy::I128 => 128, IntTy::Isize => 64,
        },
        Ty::Uint(uint_ty) => match uint_ty {
            UintTy::U8  => 8,   UintTy::U16 => 16,
            UintTy::U32 => 32,  UintTy::U64 => 64,
            UintTy::U128 => 128, UintTy::Usize => 64,
        },
        Ty::Float(float_ty) => match float_ty {
            FloatTy::F32 => 32, FloatTy::F64 => 64,
        },
        _ => 64, // pointer default (conservative)
    }
}

/// Returns true if the type is a signed integer type.
pub fn ty_is_signed(ty: &Ty) -> bool {
    matches!(ty, Ty::Int(_))
}
```

Check if these helpers already exist by reading encode_term.rs before writing. If they exist under different names, use those names instead (do NOT duplicate).

**Anti-patterns to avoid:**
- Do NOT leave `CastKind::Pointer` as anything other than identity — pointer casts stay as BitVec 64.
- Do NOT use `Bv2Int` for integer casts — use `SignExtend`/`ZeroExtend`/`Extract` (bitvector operations, not integer conversion).
- Transmute is modeled as `IntToFloat` with `FpFromBits` — do NOT treat it as a semantic conversion.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis vcgen_03_cast_sign_extend vcgen_03_cast_truncate 2>&1 | tail -20</automated>
    <manual>Confirm vcgen_03_cast_sign_extend and vcgen_03_cast_truncate both pass. vcgen_03_transmute may still fail until Task 2 wires encode_cast into vcgen.rs.</manual>
  </verify>
  <done>encode_cast(), encode_int_to_int_cast(), and ty_bit_width() exist in encode_term.rs. vcgen_03_cast_sign_extend asserts Term::SignExtend(24, _) and passes. vcgen_03_cast_truncate asserts Term::Extract(31, 0, _) and passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire encode_cast into Rvalue::Cast arm in vcgen.rs</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Replace the identity stub at `vcgen.rs:1444` with a proper call to `encode_cast()`.

**Location:** In `encode_assignment()` function, the `Rvalue::Cast(kind, op, target_ty)` match arm.

**Current stub (RESEARCH.md confirmed):**
```rust
Rvalue::Cast(_, op, _) => {
    // Phase 1: casts are identity (TODO: proper cast encoding)
    encode_operand(op)
}
```

**Replacement:**
```rust
Rvalue::Cast(kind, op, target_ty) => {
    let src = encode_operand_for_vcgen(op, func);
    // Infer source type from operand — use infer_operand_type() if it exists in vcgen.rs,
    // otherwise use find_local_type() as fallback
    let source_ty = infer_operand_type(func, op)
        .unwrap_or_else(|| target_ty.clone()); // fallback: assume same type (safe — no truncation)
    let from_bits = crate::encode_term::ty_bit_width(&source_ty);
    let to_bits   = crate::encode_term::ty_bit_width(target_ty);
    let from_signed = crate::encode_term::ty_is_signed(&source_ty);
    crate::encode_term::encode_cast(kind, src, from_bits, to_bits, from_signed)
}
```

**Important:** Check whether `infer_operand_type()` or `find_local_type()` already exists in vcgen.rs (RESEARCH.md says `infer_operand_type(func, op)` exists). If not found, use the following fallback:
- For `Operand::Copy(place)` or `Operand::Move(place)`: call `find_local_type(func, &place.local)` — look for this function first, it likely exists.
- For `Operand::Const(_, ty)`: use `ty` directly.
- If source type is unresolvable: fall back to identity (existing behavior with a comment noting the fallback).

**Pitfall (RESEARCH.md Pitfall 1):** `Rvalue::Cast` stores the target type, not the source type. The source comes from `infer_operand_type`. Always call this — do NOT assume source == target.

**After the change:** Run `cargo clippy -p rust-fv-analysis -- -D warnings` and fix any issues before moving on.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_03|FAILED|PASSED|ok"</automated>
    <manual>All 3 vcgen_03_* tests (sign_extend, truncate, transmute) should show "ok". Run full suite to confirm no regressions: cargo test -p rust-fv-analysis 2>&1 | tail -20</manual>
  </verify>
  <done>All 3 vcgen_03_* tests pass. cargo test -p rust-fv-analysis shows no new FAILED tests. cargo clippy -p rust-fv-analysis -- -D warnings exits with 0.</done>
</task>

</tasks>

<verification>
cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_03|test result"
cargo test -p rust-fv-analysis 2>&1 | tail -5
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -5
</verification>

<success_criteria>
- `encode_cast()` and `encode_int_to_int_cast()` exported from `encode_term.rs`
- `Rvalue::Cast` arm in `vcgen.rs` calls `encode_cast()` — no identity stub
- `vcgen_03_cast_sign_extend`, `vcgen_03_cast_truncate`, `vcgen_03_transmute` all PASS
- Full cargo test suite shows no regressions (same or fewer failures than before this plan)
- clippy clean on `rust-fv-analysis` crate
</success_criteria>

<output>
After completion, create `.planning/phases/28-smt-vcgen-completeness/28-02-SUMMARY.md`
</output>

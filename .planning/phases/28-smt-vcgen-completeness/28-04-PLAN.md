---
phase: 28-smt-vcgen-completeness
plan: 04
type: execute
wave: 4
depends_on:
  - 28-03
files_modified:
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/encode_term.rs
autonomous: true
requirements:
  - VCGEN-01

must_haves:
  truths:
    - "Array index `a[i]` generates a BoundsCheck VC asserting 0 <= i AND i < len alongside the Select term"
    - "Rvalue::Len(place) generates a length constant declaration instead of returning None"
    - "Struct/tuple field projection (Projection::Field) encodes as SMT selector function (regression guard)"
    - "vcgen_01_array_index, vcgen_01_slice_len, vcgen_01_field_projection tests all pass GREEN"
  artifacts:
    - path: "crates/analysis/src/encode_term.rs"
      provides: "bounds_check_term(idx: Term, len: Term) -> Term"
      exports: ["bounds_check_term"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "BoundsCheck VC generation when Projection::Index is used; Rvalue::Len returns length constant term"
      contains: "VcKind::BoundsCheck"
  key_links:
    - from: "vcgen.rs place encoding with Projection::Index"
      to: "encode_term.rs bounds_check_term()"
      via: "Call to bounds_check_term() when Index projection detected, adding VC to output"
      pattern: "bounds_check_term"
    - from: "vcgen.rs Rvalue::Len"
      to: "SMT declarations"
      via: "Len generates a constant {place}_len declared as Sort::BitVec(64)"
      pattern: "{local}_len"
---

<objective>
Implement array index bounds VCs and slice length encoding (VCGEN-01 memory operations).

Purpose: `Projection::Index(idx_local)` already maps to `Term::Select` (correct memory model access), but no bounds-check VC is generated — a buffer overread is silently allowed. `Rvalue::Len` returns `None` so slice length is unknown. This plan adds the safety VC `0 <= i AND i < len` for every array index, and wires `Rvalue::Len` to produce a length constant.

Output: `bounds_check_term()` in encode_term.rs, BoundsCheck VC emission in vcgen.rs, Len encoding, all 3 vcgen_01_* tests GREEN.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-smt-vcgen-completeness/28-RESEARCH.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/ir.rs
@crates/smtlib/src/term.rs
@crates/analysis/tests/vcgen_completeness28.rs
@.planning/phases/28-smt-vcgen-completeness/28-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bounds_check_term() helper and Rvalue::Len encoding</name>
  <files>crates/analysis/src/encode_term.rs</files>
  <action>
Add two items to `crates/analysis/src/encode_term.rs`:

**1. `bounds_check_term()` helper:**

```rust
/// Build the bounds-check term for an array/slice index access.
///
/// Asserts: (0 <= idx) AND (idx < len)
/// Both operands are 64-bit bitvectors (unsigned comparison via BvULe / BvULt).
pub fn bounds_check_term(idx: Term, len: Term) -> Term {
    // Lower bound: 0 <= idx (unsigned, so this is always true for bitvectors;
    // but we emit it explicitly for documentation and for signed-index catching)
    let lower = Term::BvULe(
        Box::new(Term::BitVecLit(0, 64)),
        Box::new(idx.clone()),
    );
    // Upper bound: idx < len
    let upper = Term::BvULt(Box::new(idx), Box::new(len));
    Term::And(vec![lower, upper])
}
```

**Note on bit width:** If the idx local is a 32-bit index (usize varies), you may need to zero-extend it. Use `ty_bit_width()` (added in Plan 02) to check. If idx is 32-bit BV and len is 64-bit BV, zero-extend idx to 64 bits:
```rust
let idx_64 = if idx_bits < 64 {
    Term::ZeroExtend(64 - idx_bits, Box::new(idx))
} else { idx };
```
The simpler approach: declare the bounds-check with the native idx width and a matching len constant — both the idx term and len constant can use the same width. Check what width `Projection::Index(idx_local)` uses in the codebase.

**2. `len_constant_name()` helper:**

```rust
/// Generate the SMT constant name for a slice/array length.
pub fn len_constant_name(arr_local: &str) -> String {
    format!("{}_len", arr_local)
}
```

These are pure encoding helpers — no I/O, easy to test.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis vcgen_01_slice_len 2>&1 | grep -E "vcgen_01_slice_len|FAILED|ok"</automated>
    <manual>vcgen_01_slice_len test should pass after Rvalue::Len is wired (Task 2). This task only adds the helpers — the test may not pass until Task 2 wires them into vcgen.rs.</manual>
  </verify>
  <done>bounds_check_term() and len_constant_name() exported from encode_term.rs. Compile succeeds: cargo build -p rust-fv-analysis exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Wire bounds VC and Rvalue::Len into vcgen.rs</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Two changes to vcgen.rs:

**Change 1: Rvalue::Len encoding**

Find the `Rvalue::Len` arm in `encode_assignment()` (currently returns `None`):

```rust
Rvalue::Len(len_place) => {
    // Return None
}
```

Replace with:

```rust
Rvalue::Len(len_place) => {
    // Model slice/array length as a named constant: {local}_len.
    // The constant is declared as Sort::BitVec(64) in the declarations section.
    // This makes the length available for bounds checks and spec expressions.
    let len_name = crate::encode_term::len_constant_name(&len_place.local);
    Term::Const(len_name)
}
```

Additionally, in the declarations section (where DeclareConst commands are built for all locals), add a DeclareConst for the len constant when the function has any Len rvalue:

```rust
// After existing local declarations
for bb in &func.basic_blocks {
    for stmt in &bb.statements {
        if let Statement::Assign(_, Rvalue::Len(len_place)) = stmt {
            let len_const = crate::encode_term::len_constant_name(&len_place.local);
            declarations.push(Command::DeclareConst(len_const, Sort::BitVec(64)));
        }
    }
}
```

**Change 2: BoundsCheck VC generation for Projection::Index**

Find where `encode_place_with_type()` handles `Projection::Index(idx_local)` and where place encoding is called in the path traversal. The goal is: whenever a place with `Projection::Index` is READ (as an operand), generate a companion bounds-check VC.

**Location:** In the traversal code where statements are encoded (`encode_assignment` or `traverse_block`), after a statement `_N = place[idx]` is encoded:

```rust
// After encoding the Index select term, generate a bounds VC
if place.projections.iter().any(|p| matches!(p, Projection::Index(_))) {
    for proj in &place.projections {
        if let Projection::Index(idx_local) = proj {
            // Get or construct the index term
            let idx_term = Term::Const(idx_local.clone());
            // Get the length term for the base array
            let len_term = Term::Const(
                crate::encode_term::len_constant_name(&place.local)
            );
            let bounds_ok = crate::encode_term::bounds_check_term(idx_term, len_term);
            // Emit a BoundsCheck VC: negation of bounds_ok must be UNSAT
            let vc_desc = format!("bounds check: {} index in bounds", place.local);
            vcs.push(build_bounds_check_vc(bounds_ok, &vc_desc, func, path_conditions));
        }
    }
}
```

**If `VcKind::BoundsCheck` does not exist:** Add it. Search vcgen.rs for `VcKind` enum (may be in ir.rs or vcgen.rs). Add `BoundsCheck` variant. Update any exhaustive match on VcKind in callbacks.rs/diagnostics.rs to handle the new variant (with a default "array index out of bounds" message).

**Follow the overflow_check() pattern:** The existing overflow VCs use `generate_overflow_vc()` or similar. Find how overflow VCs are built (they share the same `build_vc_script_with_negation` or `generate_safety_vc` pattern) and follow it exactly.

**Pitfall (RESEARCH.md Pitfall 2):** If the function uses both array indexing AND seq operations, the logic may need to be `QF_AUFBV` not `QF_BV`. The existing logic selection in `generate_contract_vcs` should already handle array sorts (sort audit). Verify the generated script uses an appropriate logic.

After changes: run clippy and fmt.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_01|test result"</automated>
    <manual>All 3 vcgen_01_* tests should pass: vcgen_01_array_index (BoundsCheck VC present), vcgen_01_slice_len (Len returns constant, not None), vcgen_01_field_projection (regression guard passes). Full suite: cargo test -p rust-fv-analysis 2>&1 | tail -10</manual>
  </verify>
  <done>All 3 vcgen_01_* tests PASS. VcKind::BoundsCheck exists and is handled in diagnostics. cargo test -p rust-fv-analysis shows no new FAILED tests. cargo clippy -p rust-fv-analysis -- -D warnings exits 0.</done>
</task>

</tasks>

<verification>
cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | grep -E "vcgen_01|test result"
cargo test -p rust-fv-analysis 2>&1 | tail -5
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -5
</verification>

<success_criteria>
- `bounds_check_term()` and `len_constant_name()` exported from `encode_term.rs`
- `Rvalue::Len` in `encode_assignment` returns a length constant term (not None)
- BoundsCheck VCs generated when Projection::Index is used
- `VcKind::BoundsCheck` variant added if not present; handled in diagnostics
- All 3 vcgen_01_* tests PASS
- Full cargo test suite shows no regressions
- clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/28-smt-vcgen-completeness/28-04-SUMMARY.md`
</output>

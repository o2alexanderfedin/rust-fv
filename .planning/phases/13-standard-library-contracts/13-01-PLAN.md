---
phase: 13-standard-library-contracts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/smtlib/src/sort.rs
  - crates/smtlib/src/term.rs
  - crates/smtlib/src/formatter.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/stdlib_contracts/mod.rs
  - crates/analysis/src/stdlib_contracts/types.rs
  - crates/analysis/src/encode_sort.rs
autonomous: true

must_haves:
  truths:
    - "SMT Seq sort and sequence operations (seq.unit, seq.concat, seq.len, seq.nth, seq.extract) are available for encoding collections"
    - "SMT Map abstraction via uninterpreted functions is available for HashMap modeling"
    - "Stdlib contract data model can represent contracts for Vec, Option, Result, HashMap, Iterator, String, slice"
  artifacts:
    - path: "crates/smtlib/src/sort.rs"
      provides: "Sort::Seq variant for SMT sequence theory"
      contains: "Seq"
    - path: "crates/smtlib/src/term.rs"
      provides: "Sequence operation terms (SeqUnit, SeqConcat, SeqLen, SeqNth, SeqExtract, SeqEmpty, SeqContains)"
      contains: "SeqUnit"
    - path: "crates/smtlib/src/formatter.rs"
      provides: "SMT-LIB formatting for all new sorts and terms"
      contains: "seq.unit"
    - path: "crates/analysis/src/stdlib_contracts/mod.rs"
      provides: "Module root exporting stdlib contract types and registry"
      contains: "pub mod types"
    - path: "crates/analysis/src/stdlib_contracts/types.rs"
      provides: "StdlibContract, ContractSource, StdlibContractRegistry data structures"
      contains: "StdlibContractRegistry"
  key_links:
    - from: "crates/analysis/src/encode_sort.rs"
      to: "crates/smtlib/src/sort.rs"
      via: "Sort::Seq used for Vec<T>, slice, String encoding"
      pattern: "Sort::Seq"
    - from: "crates/analysis/src/stdlib_contracts/types.rs"
      to: "crates/analysis/src/contract_db.rs"
      via: "StdlibContractRegistry produces FunctionSummary entries"
      pattern: "FunctionSummary"
---

<objective>
Build SMT sequence theory infrastructure and stdlib contract data model.

Purpose: Foundation for all stdlib contracts -- sequence operations enable Vec/Iterator/String modeling, map abstraction enables HashMap. The StdlibContractRegistry provides the data structure to register, query, and load prebuilt contracts.

Output: Extended smtlib crate with Seq sort + sequence/map terms, new stdlib_contracts module with registry types.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/smtlib/src/sort.rs
@crates/smtlib/src/term.rs
@crates/smtlib/src/formatter.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/contract_db.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SMT Seq sort and sequence/map operations to smtlib crate</name>
  <files>crates/smtlib/src/sort.rs, crates/smtlib/src/term.rs, crates/smtlib/src/formatter.rs</files>
  <action>
  1. In sort.rs, add `Seq(Box<Sort>)` variant to the Sort enum -- represents `(Seq T)` in SMT-LIB (Z3's sequence theory).

  2. In term.rs, add sequence operation variants to Term enum:
     - `SeqEmpty` -- `(as seq.empty (Seq T))` (needs Sort parameter for type)
     - `SeqUnit(Box<Term>)` -- `(seq.unit x)` (singleton sequence)
     - `SeqConcat(Box<Term>, Box<Term>)` -- `(seq.++ a b)` (concatenation)
     - `SeqLen(Box<Term>)` -- `(seq.len s)` (length, returns Int)
     - `SeqNth(Box<Term>, Box<Term>)` -- `(seq.nth s i)` (element at index)
     - `SeqExtract(Box<Term>, Box<Term>, Box<Term>)` -- `(seq.extract s offset len)` (subsequence)
     - `SeqContains(Box<Term>, Box<Term>)` -- `(seq.contains s sub)` (containment check)
     - `SeqUpdate(Box<Term>, Box<Term>, Box<Term>)` -- `(seq.update s i val)` (functional update at index)

  3. In formatter.rs:
     - Add formatting for `Sort::Seq(inner)` as `(Seq {inner})`
     - Add formatting for all sequence Term variants using Z3's seq.* operations
     - Add unit tests for each new sort and term formatting

  NOTE: Map abstraction for HashMap will use existing uninterpreted functions (Term::App with declare-fun) plus array theory (Sort::Array for Map<K,V>), so no new Term variants needed for maps. The key insight: HashMap is modeled as `(Array K (Option V))` where Option is an existing SMT datatype.
  </action>
  <verify>
  `cargo test -p rust-fv-smtlib` -- all existing tests pass plus new tests for:
  - Sort::Seq formatting produces `(Seq Int)`, `(Seq (BitVec 32))` etc.
  - SeqUnit, SeqConcat, SeqLen, SeqNth, SeqExtract, SeqContains, SeqUpdate format correctly
  - Nested sequences: `(Seq (Seq Int))` works
  </verify>
  <done>All SMT sequence operations and Seq sort are available with correct SMT-LIB formatting. Existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create stdlib contracts module with registry data model and Seq sort integration</name>
  <files>crates/analysis/src/stdlib_contracts/mod.rs, crates/analysis/src/stdlib_contracts/types.rs, crates/analysis/src/lib.rs, crates/analysis/src/encode_sort.rs</files>
  <action>
  1. Create `crates/analysis/src/stdlib_contracts/` directory with:

  **mod.rs:**
  - `pub mod types;`
  - Re-export key types: `StdlibContractRegistry`, `StdlibContract`, `ContractSource`

  **types.rs:**
  - `ContractSource` enum: `{ Builtin, UserOverride, UserExtension }` -- tracks where a contract came from
  - `StdlibContract` struct:
    ```rust
    pub struct StdlibContract {
        /// Fully-qualified type path (e.g., "std::vec::Vec", "std::option::Option")
        pub type_path: String,
        /// Method name (e.g., "push", "pop", "len")
        pub method_name: String,
        /// The function summary (contracts + param metadata)
        pub summary: FunctionSummary,
        /// Where this contract came from
        pub source: ContractSource,
    }
    ```
  - `StdlibContractRegistry` struct with HashMap<String, StdlibContract> keyed by fully-qualified method name (e.g., "Vec::push"):
    ```rust
    pub struct StdlibContractRegistry {
        contracts: HashMap<String, StdlibContract>,
        enabled: bool,
    }
    ```
  - Methods:
    - `new() -> Self` (enabled=true by default)
    - `new_disabled() -> Self` (for --no-stdlib-contracts)
    - `register(contract: StdlibContract)` -- add a contract
    - `get(&self, method_key: &str) -> Option<&StdlibContract>` -- lookup
    - `override_contract(&mut self, key: &str, contract: StdlibContract)` -- full replacement
    - `extend_contract(&mut self, key: &str, extra_requires: Vec<SpecExpr>, extra_ensures: Vec<SpecExpr>)` -- additive
    - `merge_into(&self, db: &mut ContractDatabase)` -- inject all stdlib contracts into the contract database
    - `is_enabled(&self) -> bool`
    - `len(&self) -> usize`
  - Unit tests for registry: insert, get, override, extend, merge_into, disabled registry returns None

  2. In `crates/analysis/src/lib.rs`, add `pub mod stdlib_contracts;`

  3. In `crates/analysis/src/encode_sort.rs`, add encoding for collection types that map to Seq sort:
  - When encountering `Ty::Named("Vec")` or types matching known collection patterns, encode as `Sort::Seq(element_sort)` (this will be refined when actual contracts are wired in Plan 04)
  - Add a helper function `encode_stdlib_type(name: &str, type_args: &[Ty]) -> Option<Sort>` that recognizes Vec<T>, HashMap<K,V>, String, etc. and returns appropriate SMT sorts
  - Vec<T> -> Seq(T_sort) with separate length/capacity tracking via uninterpreted functions
  - HashMap<K,V> -> Array(K_sort, Option_sort(V_sort))
  - String -> Seq(BitVec(8)) (UTF-8 byte sequence)
  - &str -> Seq(BitVec(8))
  </action>
  <verify>
  `cargo test -p rust-fv-analysis` -- all existing tests pass plus new tests for:
  - StdlibContractRegistry insert/get/override/extend/merge_into
  - encode_stdlib_type returns correct sorts for Vec, HashMap, String
  - Disabled registry blocks all lookups
  `cargo clippy -p rust-fv-analysis -- -D warnings` passes
  </verify>
  <done>stdlib_contracts module exists with registry, contract data types, and sort encoding for stdlib types. All existing analysis tests still pass.</done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes (all existing + new tests)
- `cargo clippy --workspace -- -D warnings` passes
- Sort::Seq and sequence operations available in smtlib
- StdlibContractRegistry functional with CRUD operations
- encode_stdlib_type maps Vec->Seq, HashMap->Array, String->Seq
</verification>

<success_criteria>
SMT sequence theory infrastructure fully operational. Stdlib contract data model ready for individual type contract registration (Plans 02-03). All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/13-standard-library-contracts/13-01-SUMMARY.md`
</output>

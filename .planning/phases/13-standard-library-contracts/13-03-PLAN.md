---
phase: 13-standard-library-contracts
plan: 03
type: tdd
wave: 2
depends_on: ["13-01"]
files_modified:
  - crates/analysis/src/stdlib_contracts/hashmap.rs
  - crates/analysis/src/stdlib_contracts/iterator.rs
  - crates/analysis/src/stdlib_contracts/string.rs
  - crates/analysis/src/stdlib_contracts/mod.rs
  - crates/analysis/tests/stdlib_hashmap_test.rs
  - crates/analysis/tests/stdlib_iterator_test.rs
  - crates/analysis/tests/stdlib_string_test.rs
autonomous: true

must_haves:
  truths:
    - "HashMap<K,V> insert/get/remove/contains_key/len have mathematical map abstraction contracts"
    - "Iterator next/map/filter/collect/count/fold/any/all/zip/enumerate/take have composable sequence contracts"
    - "String/&str operations (len, push_str, as_bytes, is_empty, contains) have contracts"
    - "Iterator chain composition preserves properties: map preserves length, filter reduces length"
  artifacts:
    - path: "crates/analysis/src/stdlib_contracts/hashmap.rs"
      provides: "HashMap<K,V> contracts: insert, get, remove, contains_key, len, is_empty, clear"
      contains: "register_hashmap_contracts"
    - path: "crates/analysis/src/stdlib_contracts/iterator.rs"
      provides: "Iterator contracts: next, map, filter, collect, count, fold, any, all, zip, enumerate, take"
      contains: "register_iterator_contracts"
    - path: "crates/analysis/src/stdlib_contracts/string.rs"
      provides: "String/&str/slice contracts: len, push_str, as_bytes, is_empty, contains, get(slice)"
      contains: "register_string_contracts"
  key_links:
    - from: "crates/analysis/src/stdlib_contracts/hashmap.rs"
      to: "crates/smtlib/src/sort.rs"
      via: "HashMap modeled as Array(K_sort, Option(V_sort))"
      pattern: "Sort::Array"
    - from: "crates/analysis/src/stdlib_contracts/iterator.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Iterator chains use Seq operations for composition"
      pattern: "SeqLen"
---

<objective>
Implement formal verification contracts for HashMap<K,V>, Iterator trait (with Tier 1 adaptors), and String/&str/slice.

Purpose: HashMap as mathematical map abstraction (STDLIB-03) enables functional correctness proofs. Iterator contracts (STDLIB-04) enable verifying chain compositions (map/filter/collect). String/str/slice contracts round out Tier 1 type coverage per user decision.

Output: Three contract modules with registration functions, tested via TDD.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-standard-library-contracts/13-01-SUMMARY.md
@crates/analysis/src/stdlib_contracts/types.rs
@crates/analysis/src/stdlib_contracts/mod.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/contract_db.rs
@crates/smtlib/src/sort.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HashMap<K,V> mathematical map abstraction contracts (TDD)</name>
  <files>crates/analysis/src/stdlib_contracts/hashmap.rs, crates/analysis/src/stdlib_contracts/mod.rs, crates/analysis/tests/stdlib_hashmap_test.rs</files>
  <action>
  **TDD: Write tests first, then implement.**

  **RED phase** -- Write test file `crates/analysis/tests/stdlib_hashmap_test.rs`:
  - Test insert: post: get(key) == Some(value), post: forall k != key: get(k) == old(get(k)), post: len changes appropriately (increments if new key, stays if overwrite)
  - Test get: pure, post: result == model.lookup(key)
  - Test remove: post: get(key) == None, post: forall k != key: get(k) == old(get(k)), post: len decreases by 1 if key existed
  - Test contains_key: pure, post: result == get(key).is_some()
  - Test len: pure
  - Test is_empty: pure, post: result == (len == 0)
  - Test clear: post: len == 0, post: forall k: get(k) == None

  **GREEN phase** -- Implement `crates/analysis/src/stdlib_contracts/hashmap.rs`:
  - `pub fn register_hashmap_contracts(registry: &mut StdlibContractRegistry)`
  - Mathematical map abstraction: HashMap modeled as abstract map function `map_model: K -> Option<V>`
  - SMT encoding: Use Array(K_sort, Option_sort(V_sort)) where Option is a datatype
  - insert(k,v) ensures get(k)==Some(v) (user requirement)
  - remove(k) ensures get(k)==None (user requirement)
  - Frame conditions: forall k != key: lookup unchanged (critical for functional correctness)
  - Length tracking via separate uninterpreted function
  - Do NOT model iteration order (HashMap is non-deterministic -- pitfall #4 from research)

  Update mod.rs to add `pub mod hashmap;`

  **REFACTOR** -- Clean up, ensure frame conditions are complete.
  </action>
  <verify>
  `cargo test -p rust-fv-analysis -- stdlib_hashmap` passes all tests.
  `cargo clippy -p rust-fv-analysis -- -D warnings` passes.
  </verify>
  <done>HashMap<K,V> has mathematical map abstraction contracts for insert, get, remove, contains_key, len, is_empty, clear. Frame conditions preserve unmodified entries.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Iterator and String/str/slice contracts (TDD)</name>
  <files>crates/analysis/src/stdlib_contracts/iterator.rs, crates/analysis/src/stdlib_contracts/string.rs, crates/analysis/src/stdlib_contracts/mod.rs, crates/analysis/tests/stdlib_iterator_test.rs, crates/analysis/tests/stdlib_string_test.rs</files>
  <action>
  **TDD: Write tests first, then implement.**

  **RED phase** -- Write iterator test file `crates/analysis/tests/stdlib_iterator_test.rs`:
  - Test next: post: is_some ==> seq_model shrinks by 1, post: is_none ==> seq_model was empty
  - Test map: composition property -- result.seq_len() == input.seq_len() (map preserves length)
  - Test filter: composition property -- result.seq_len() <= input.seq_len()
  - Test collect: post: result_vec.len() == consumed_iterator.count()
  - Test count: post: result == seq_model.len()
  - Test fold: post: result == fold(init, f, seq_model) (abstract fold operation)
  - Test any: post: result == exists(|x| predicate(x) in seq_model)
  - Test all: post: result == forall(|x| predicate(x) in seq_model)
  - Test zip: post: result.seq_len() == min(a.seq_len(), b.seq_len())
  - Test enumerate: post: result.seq_len() == input.seq_len(), each element is (index, value)
  - Test take: post: result.seq_len() == min(n, input.seq_len())
  - Test chain composition: vec.iter().map(f).filter(p).collect() has result.len() <= input.len()

  Write string test file `crates/analysis/tests/stdlib_string_test.rs`:
  - Test String::len: pure, result is byte length
  - Test String::is_empty: pure, post: result == (len == 0)
  - Test String::push_str: post: len == old(len) + other.len()
  - Test str::len: pure
  - Test str::is_empty: pure
  - Test str::contains: pure
  - Test str::as_bytes: post: result.len() == self.len()
  - Test slice::len: pure
  - Test slice::get: pre: index < len, post: returns i-th element
  - Test slice::is_empty: pure, post: result == (len == 0)

  **GREEN phase** -- Implement:

  **iterator.rs:**
  - `pub fn register_iterator_contracts(registry: &mut StdlibContractRegistry)`
  - Model iterators as abstract sequences (Seq<Item> in SMT)
  - Each adaptor transforms the sequence model:
    - map: same length, elements transformed
    - filter: length <= original, all elements satisfy predicate
    - take(n): length = min(n, original length)
    - zip: length = min(a_len, b_len), pairs from both
    - enumerate: same length, wraps in (usize, Item) pairs
  - For infinite iterators: require finiteness precondition (conservative, per research recommendation). If no .take(n) or known-finite source, emit a warning VC rather than unsound contract.
  - Tier 1 adaptors per user decision: map, filter, collect, next, count, fold, any, all, zip, enumerate, take

  **string.rs:**
  - `pub fn register_string_contracts(registry: &mut StdlibContractRegistry)`
  - String modeled as Seq(BitVec(8)) -- UTF-8 byte sequence
  - &str modeled same as String (reference transparent)
  - Slice &[T] modeled as Seq(T_sort) with length
  - len() returns seq.len, push_str concatenates sequences

  Update mod.rs to add `pub mod iterator;` and `pub mod string;`
  </action>
  <verify>
  `cargo test -p rust-fv-analysis -- stdlib_iterator` passes.
  `cargo test -p rust-fv-analysis -- stdlib_string` passes.
  `cargo clippy -p rust-fv-analysis -- -D warnings` passes.
  </verify>
  <done>Iterator has contracts for all Tier 1 adaptors with composable sequence properties. String/str/slice have contracts. Chain composition verified (map preserves length, filter reduces).</done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes
- `cargo clippy --workspace -- -D warnings` passes
- HashMap modeled as mathematical map with frame conditions
- Iterator chain composition properties verified in tests
- String/str modeled as UTF-8 byte sequences
- All contracts registered in StdlibContractRegistry
</verification>

<success_criteria>
Requirements STDLIB-03 (HashMap) and STDLIB-04 (Iterator) have complete contracts. HashMap uses mathematical map abstraction per user decision. Iterator chains compose per user decision (map preserves length, filter reduces). Tier 1 types fully covered.
</success_criteria>

<output>
After completion, create `.planning/phases/13-standard-library-contracts/13-03-SUMMARY.md`
</output>

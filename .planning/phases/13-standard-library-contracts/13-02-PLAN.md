---
phase: 13-standard-library-contracts
plan: 02
type: tdd
wave: 2
depends_on: ["13-01"]
files_modified:
  - crates/analysis/src/stdlib_contracts/vec.rs
  - crates/analysis/src/stdlib_contracts/option.rs
  - crates/analysis/src/stdlib_contracts/result.rs
  - crates/analysis/src/stdlib_contracts/mod.rs
  - crates/analysis/tests/stdlib_vec_test.rs
  - crates/analysis/tests/stdlib_option_result_test.rs
autonomous: true

must_haves:
  truths:
    - "Vec<T> push/pop/len/get/reserve/shrink_to_fit have formal contracts with element-level precision"
    - "Option<T> is_some/is_none/unwrap/map/and_then/ok_or have full behavioral contracts"
    - "Result<T,E> is_ok/is_err/unwrap/unwrap_err/map/map_err/and_then/ok have full behavioral contracts"
    - "All contracts are registered in StdlibContractRegistry and producible as FunctionSummary"
  artifacts:
    - path: "crates/analysis/src/stdlib_contracts/vec.rs"
      provides: "Vec<T> contracts: push, pop, len, capacity, get, index, reserve, shrink_to_fit, is_empty, clear"
      contains: "register_vec_contracts"
    - path: "crates/analysis/src/stdlib_contracts/option.rs"
      provides: "Option<T> contracts: is_some, is_none, unwrap, map, and_then, ok_or, unwrap_or, unwrap_or_else"
      contains: "register_option_contracts"
    - path: "crates/analysis/src/stdlib_contracts/result.rs"
      provides: "Result<T,E> contracts: is_ok, is_err, unwrap, unwrap_err, map, map_err, and_then, ok, err"
      contains: "register_result_contracts"
  key_links:
    - from: "crates/analysis/src/stdlib_contracts/vec.rs"
      to: "crates/analysis/src/stdlib_contracts/types.rs"
      via: "Vec contracts registered as StdlibContract into registry"
      pattern: "StdlibContract"
    - from: "crates/analysis/src/stdlib_contracts/option.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Contracts use SpecExpr for requires/ensures"
      pattern: "SpecExpr"
---

<objective>
Implement formal verification contracts for Vec<T>, Option<T>, and Result<T,E>.

Purpose: These are the most commonly used Rust stdlib types. Vec contracts enable verifying collection manipulations (STDLIB-01). Option/Result contracts enable verifying error handling patterns (STDLIB-02). Element-level precision per user decision: vec.push(x) ensures vec[len-1]==x, vec.get(i) returns i-th element.

Output: Three contract modules with registration functions, tested via TDD.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-standard-library-contracts/13-01-SUMMARY.md
@crates/analysis/src/stdlib_contracts/types.rs
@crates/analysis/src/stdlib_contracts/mod.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/contract_db.rs
@crates/analysis/src/spec_parser.rs
@crates/smtlib/src/sort.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Vec<T> contracts with element-level precision (TDD)</name>
  <files>crates/analysis/src/stdlib_contracts/vec.rs, crates/analysis/src/stdlib_contracts/mod.rs, crates/analysis/tests/stdlib_vec_test.rs</files>
  <action>
  **TDD: Write tests first, then implement.**

  **RED phase** -- Write test file `crates/analysis/tests/stdlib_vec_test.rs`:
  - Test `register_vec_contracts` populates registry with all Vec methods
  - Test Vec::push contract: pre: len < capacity (or no capacity pre if allocator is assumed), post: len == old(len) + 1, post: self[old(len)] == value
  - Test Vec::pop contract: post: is_some ==> len == old(len) - 1, post: is_none ==> old(len) == 0
  - Test Vec::len contract: pure, no preconditions
  - Test Vec::capacity contract: pure, ensures capacity >= len
  - Test Vec::get contract: pre: index < len, post: result == seq_nth(self, index)
  - Test Vec::reserve contract: post: capacity >= old(capacity) + additional, post: len == old(len), elements preserved
  - Test Vec::shrink_to_fit contract: post: capacity == len, elements preserved
  - Test Vec::is_empty contract: pure, post: result == (len == 0)
  - Test Vec::clear contract: post: len == 0
  - Verify each contract produces valid FunctionSummary with correct param_names and param_types

  **GREEN phase** -- Implement `crates/analysis/src/stdlib_contracts/vec.rs`:
  - `pub fn register_vec_contracts(registry: &mut StdlibContractRegistry)` function
  - Each method modeled with:
    - SpecExpr for requires/ensures using the specification language
    - SMT encoding uses Seq sort for element tracking: vec modeled as (len: usize, cap: usize, data: Seq<T>)
    - Element-level contracts use seq.nth for indexing, seq.++ with seq.unit for push
  - Vec push precondition: relaxed (no capacity check -- Rust allocator handles reallocation; capacity tracks allocation but push always succeeds). Per research: don't over-specify.
  - Element preservation for reserve/shrink: forall i < len: self[i] == old(self[i])

  Update mod.rs to add `pub mod vec;`

  **REFACTOR** -- Clean up, ensure all doc comments present, verify contracts match user decisions exactly.
  </action>
  <verify>
  `cargo test -p rust-fv-analysis -- stdlib_vec` passes all tests.
  `cargo clippy -p rust-fv-analysis -- -D warnings` passes.
  </verify>
  <done>Vec<T> has contracts for push, pop, len, capacity, get, reserve, shrink_to_fit, is_empty, clear with element-level precision. All registered in StdlibContractRegistry.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Option<T> and Result<T,E> contracts (TDD)</name>
  <files>crates/analysis/src/stdlib_contracts/option.rs, crates/analysis/src/stdlib_contracts/result.rs, crates/analysis/src/stdlib_contracts/mod.rs, crates/analysis/tests/stdlib_option_result_test.rs</files>
  <action>
  **TDD: Write tests first, then implement.**

  **RED phase** -- Write test file `crates/analysis/tests/stdlib_option_result_test.rs`:

  Option<T> tests:
  - Test is_some: pure, post: result == !is_none
  - Test is_none: pure, post: result == !is_some
  - Test unwrap: pre: is_some, post: result == inner_value (ghost accessor)
  - Test map: post: is_some ==> result == Some(f(inner)), post: is_none ==> result == None
  - Test and_then: post: is_some ==> result == f(inner), post: is_none ==> result == None
  - Test ok_or: post: is_some ==> result == Ok(inner), post: is_none ==> result == Err(default)
  - Test unwrap_or: post: is_some ==> result == inner, post: is_none ==> result == default
  - Test unwrap_or_else: post: is_some ==> result == inner, post: is_none ==> result == f()

  Result<T,E> tests:
  - Test is_ok: pure, post: result == !is_err
  - Test is_err: pure, post: result == !is_ok
  - Test unwrap: pre: is_ok, post: result == ok_value
  - Test unwrap_err: pre: is_err, post: result == err_value
  - Test map: post: is_ok ==> result == Ok(f(ok_value)), post: is_err ==> result == Err(err_value)
  - Test map_err: post: is_ok ==> result == Ok(ok_value), post: is_err ==> result == Err(f(err_value))
  - Test and_then: post: is_ok ==> result == f(ok_value), post: is_err ==> result == Err(err_value)
  - Test ok: post: is_ok ==> result == Some(ok_value), post: is_err ==> result == None
  - Test err: post: is_ok ==> result == None, post: is_err ==> result == Some(err_value)

  **GREEN phase** -- Implement option.rs and result.rs:
  - `pub fn register_option_contracts(registry: &mut StdlibContractRegistry)`
  - `pub fn register_result_contracts(registry: &mut StdlibContractRegistry)`
  - Option modeled as SMT datatype: `(declare-datatype Option ((Some (option_value T)) (None)))`
  - Result modeled as SMT datatype: `(declare-datatype Result ((Ok (ok_value T)) (Err (err_value E))))`
  - Ghost accessor functions: `option_value(x)` extracts inner from Some, `ok_value(x)`/`err_value(x)` for Result
  - Use SpecExpr raw strings with match expressions for postconditions

  Update mod.rs to add `pub mod option;` and `pub mod result;`

  **REFACTOR** -- Ensure consistency between Option and Result contracts, doc comments.
  </action>
  <verify>
  `cargo test -p rust-fv-analysis -- stdlib_option_result` passes all tests.
  `cargo clippy -p rust-fv-analysis -- -D warnings` passes.
  </verify>
  <done>Option<T> has contracts for is_some, is_none, unwrap, map, and_then, ok_or, unwrap_or, unwrap_or_else. Result<T,E> has contracts for is_ok, is_err, unwrap, unwrap_err, map, map_err, and_then, ok, err. All registered in StdlibContractRegistry.</done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes
- `cargo clippy --workspace -- -D warnings` passes
- Vec contracts cover: push, pop, len, capacity, get, reserve, shrink_to_fit, is_empty, clear
- Option contracts cover: is_some, is_none, unwrap, map, and_then, ok_or, unwrap_or, unwrap_or_else
- Result contracts cover: is_ok, is_err, unwrap, unwrap_err, map, map_err, and_then, ok, err
- All contracts registered in StdlibContractRegistry and convertible to FunctionSummary
</verification>

<success_criteria>
Requirements STDLIB-01 (Vec) and STDLIB-02 (Option/Result) have complete contracts. Element-level Vec precision matches user decision. Full behavioral contracts for Option/Result match user decision.
</success_criteria>

<output>
After completion, create `.planning/phases/13-standard-library-contracts/13-02-SUMMARY.md`
</output>

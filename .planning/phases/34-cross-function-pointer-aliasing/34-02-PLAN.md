---
phase: 34-cross-function-pointer-aliasing
plan: 02
type: tdd
wave: 2
depends_on:
  - 34-01
files_modified:
  - crates/analysis/src/unsafe_analysis.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/unsafe_verification.rs
autonomous: true
requirements:
  - ALIAS-01
  - ALIAS-02

must_haves:
  truths:
    - "unsafe_analysis.rs extracts AliasPreconditions from #[unsafe_requires(!alias(p, q))] annotations and stores them in FunctionSummary.alias_preconditions by parameter index"
    - "vcgen.rs generate_call_site_vcs injects a VcKind::PointerAliasing VC for each alias_precondition: actual argument addresses substituted into generate_alias_check_assertion"
    - "When the same pointer is passed for both parameters the VC is SAT (violation found); different pointers produce UNSAT (no violation)"
    - "The counterexample description names the specific parameter pair: 'pointer aliasing: call to `swap_unsafe` — arg[0] and arg[1] alias'"
    - "The DEBTLINE test test_cross_function_pointer_aliasing updated to pass with a contract_db providing alias_preconditions"
    - "All existing intra-procedural unsafe_verification tests remain GREEN (cargo test unsafe_verification)"
  artifacts:
    - path: "crates/analysis/src/unsafe_analysis.rs"
      provides: "extract_alias_preconditions(func) returning Vec<AliasPrecondition>"
      exports: ["extract_alias_preconditions"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "alias VC injection in generate_call_site_vcs loop"
      contains: "PointerAliasing"
    - path: "crates/analysis/tests/unsafe_verification.rs"
      provides: "new alias VC integration tests + updated DEBTLINE test"
      contains: "test_alias_vc_generated_for_callee_with_alias_precondition"
  key_links:
    - from: "unsafe_analysis.rs extract_alias_preconditions"
      to: "contract_db.rs FunctionSummary.alias_preconditions"
      via: "caller populates alias_preconditions when building FunctionSummary for ContractDatabase"
    - from: "vcgen.rs generate_call_site_vcs"
      to: "heap_model.rs generate_alias_check_assertion"
      via: "alias_preconditions loop: looks up actual arg operands by param_idx_a/b, calls generate_alias_check_assertion(arg_a_name, arg_b_name)"
    - from: "unsafe_verification.rs tests"
      to: "vcgen::generate_vcs_with_db / generate_vcs"
      via: "ContractDatabase with FunctionSummary.alias_preconditions populated by tests directly"
---

<objective>
Wire alias precondition extraction and call-site VC injection. After this plan, `cargo verify` generates a SAT-checkable `VcKind::PointerAliasing` condition at every call site where the callee has `#[unsafe_requires(!alias(p, q))]`. The DEBTLINE test is updated to reflect the new behavior, and Z3-backed integration tests confirm SAT/UNSAT results.

Purpose: This delivers ALIAS-01 (the end-to-end enforcement) and ALIAS-02 (the counterexample naming the aliasing pair). Plan 01 created the building blocks; this plan connects them into a working pipeline.

Output:
- `extract_alias_preconditions(func)` in unsafe_analysis.rs
- Alias VC injection loop in vcgen.rs `generate_call_site_vcs`
- Updated DEBTLINE test + new alias integration tests in unsafe_verification.rs
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/34-cross-function-pointer-aliasing/34-01-SUMMARY.md
@.planning/phases/34-cross-function-pointer-aliasing/34-CONTEXT.md

<interfaces>
<!-- Contracts from plan 01 and existing codebase. Executor needs these; no exploration required. -->

From crates/analysis/src/contract_db.rs (created in plan 01):
```rust
pub struct AliasPrecondition {
    pub param_idx_a: usize,
    pub param_idx_b: usize,
    pub raw: String,
}

pub struct FunctionSummary {
    pub contracts: Contracts,
    pub param_names: Vec<String>,
    pub param_types: Vec<Ty>,
    pub return_ty: Ty,
    pub alias_preconditions: Vec<AliasPrecondition>,
}
```

From crates/analysis/src/heap_model.rs (created in plan 01):
```rust
pub fn generate_alias_check_assertion(p_name: &str, q_name: &str) -> Term;
```

From crates/analysis/src/vcgen.rs (created in plan 01):
```rust
pub enum VcKind {
    // ...
    PointerAliasing,
    // ...
}

// Existing call-site loop structure (vcgen.rs ~line 2364):
// for path in paths {
//     for call_site in &path.call_sites {
//         let callee_summary = match contract_db.get(&call_site.callee_name) { ... };
//         // existing: precondition VCs from contracts.requires
//         // NEW: alias VC injection goes here, after precondition VCs
//     }
// }

// CallSiteInfo (vcgen.rs ~line 179):
struct CallSiteInfo {
    callee_name: String,
    args: Vec<Operand>,       // actual arguments in call order (index matches param_idx)
    destination: Place,
    block_idx: usize,
    prior_assignments: Vec<PathAssignment>,
    path_condition: Option<Term>,
}

// Existing argument-to-SMT-name helper (used in build_arg_substitutions):
// Operand::Move(Place::Local(name)) or Operand::Copy(Place::Local(name)) -> name
// Use the same pattern: extract local name from Operand for alias term construction
```

From crates/analysis/src/unsafe_analysis.rs (existing patterns to follow):
```rust
pub fn get_unsafe_requires(func: &Function) -> Vec<&SpecExpr> {
    func.unsafe_contracts
        .as_ref()
        .map(|c| c.requires.iter().collect())
        .unwrap_or_default()
}
// New function: extract_alias_preconditions(func) parses raw spec strings
// looking for "!alias(param_a, param_b)" or "alias(param_a, param_b)" patterns,
// matches param names against func.params to get indices.
```

From crates/analysis/tests/unsafe_verification.rs (DEBTLINE test to update, ~line 1103):
```rust
// test_cross_function_pointer_aliasing currently asserts 1 null-check VC only.
// After this plan: update to pass a ContractDatabase with alias_preconditions
// and assert 1 alias VC is generated (VcKind::PointerAliasing).
// The test function name stays the same; the DEBTLINE comment is removed/updated.
```
</interfaces>
</context>

<feature>
  <name>Alias VC call-site injection and integration tests</name>
  <files>
    crates/analysis/src/unsafe_analysis.rs,
    crates/analysis/src/vcgen.rs,
    crates/analysis/tests/unsafe_verification.rs
  </files>
  <behavior>
    unsafe_analysis tests:
    - extract_alias_preconditions on a func with unsafe_requires raw="!alias(_1, _2)" and params ["_1", "_2"] returns vec![AliasPrecondition { param_idx_a: 0, param_idx_b: 1, raw: "!alias(_1, _2)" }]
    - extract_alias_preconditions on func with no unsafe_contracts returns empty vec
    - extract_alias_preconditions on func with unsafe_requires raw="_1 != 0" (no alias term) returns empty vec

    vcgen call-site injection tests (in unsafe_verification.rs):
    - test_alias_vc_generated_for_callee_with_alias_precondition:
      Build callee with alias_preconditions: [{param_idx_a:0, param_idx_b:1, raw:"!alias(_1, _2)"}].
      Build caller that calls callee with args [_3, _4] (different locals).
      Populate ContractDatabase with callee summary.
      Call generate_vcs_with_db on caller.
      Assert: exactly 1 VC with vc_kind == VcKind::PointerAliasing.
      Assert: description contains "alias" and callee name.

    - test_alias_vc_description_names_parameter_pair:
      Same setup. Assert description string contains "arg[0]" and "arg[1]" (or param indices).

    - test_alias_vc_sat_when_same_pointer_passed (Z3 integration):
      Build caller that calls callee with args [_1, _1] (same pointer).
      Extract alias VC script. Run through Z3.
      Assert: Z3 returns SAT (violation: p == q because same variable).

    - test_alias_vc_unsat_when_different_pointers (Z3 integration):
      Build caller that calls callee with args [_1, _2] and adds assertion _1 != _2 as path fact.
      Extract alias VC script. Run through Z3 (with _1 != _2 assumed).
      Assert: Z3 returns UNSAT (no violation: pointers provably distinct).

    - test_cross_function_pointer_aliasing (updated DEBTLINE test):
      Use ContractDatabase with alias precondition for the callee.
      Assert: 1 VcKind::PointerAliasing VC generated.
      Assert: 1 VcKind::MemorySafety null-check VC still present (no regression).
  </behavior>
  <implementation>
    TDD cycle:

    RED — Write failing tests first in unsafe_verification.rs and unsafe_analysis.rs unit tests.

    In unsafe_analysis.rs #[cfg(test)]:
    - test_extract_alias_preconditions_basic
    - test_extract_alias_preconditions_no_contracts
    - test_extract_alias_preconditions_non_alias_requires

    In unsafe_verification.rs:
    - test_alias_vc_generated_for_callee_with_alias_precondition
    - test_alias_vc_description_names_parameter_pair
    - test_alias_vc_sat_when_same_pointer_passed
    - test_alias_vc_unsat_when_different_pointers
    - Update test_cross_function_pointer_aliasing (remove DEBTLINE comment, add alias VC assertion)

    Run `cargo test -p rust-fv-analysis -- alias 2>&1` — new tests MUST fail.

    GREEN — Implement:

    Step 1: unsafe_analysis.rs — add extract_alias_preconditions:
    ```rust
    /// Extract alias preconditions from #[unsafe_requires] annotations.
    ///
    /// Parses raw spec strings for `alias(param_a, param_b)` or
    /// `!alias(param_a, param_b)` patterns. Returns AliasPrecondition
    /// items with parameter indices resolved against func.params.
    ///
    /// Only finds direct `alias(...)` calls. Negation (`!alias(...)`)
    /// is accepted — the non-aliasing constraint is the precondition.
    pub fn extract_alias_preconditions(func: &Function) -> Vec<AliasPrecondition> {
        use crate::contract_db::AliasPrecondition;

        let unsafe_requires = get_unsafe_requires(func);
        let mut result = Vec::new();

        for spec in unsafe_requires {
            let raw = spec.raw.trim();
            // Strip leading `!` — both "alias(p,q)" and "!alias(p,q)" are preconditions
            let inner = if raw.starts_with('!') { raw[1..].trim() } else { raw };

            // Match alias(param_a, param_b) — simple pattern match on raw string
            if !inner.starts_with("alias(") || !inner.ends_with(')') {
                continue;
            }
            let args_str = &inner["alias(".len()..inner.len() - 1];
            let parts: Vec<&str> = args_str.splitn(2, ',').collect();
            if parts.len() != 2 {
                continue;
            }
            let name_a = parts[0].trim();
            let name_b = parts[1].trim();

            // Resolve param indices: func.params are zero-based
            let idx_a = func.params.iter().position(|p| p.name == name_a);
            let idx_b = func.params.iter().position(|p| p.name == name_b);

            if let (Some(ia), Some(ib)) = (idx_a, idx_b) {
                result.push(AliasPrecondition {
                    param_idx_a: ia,
                    param_idx_b: ib,
                    raw: spec.raw.clone(),
                });
            } else {
                tracing::warn!(
                    function = %func.name,
                    spec = %spec.raw,
                    "alias() parameter names not found in function signature — skipping"
                );
            }
        }
        result
    }
    ```

    Step 2: vcgen.rs generate_call_site_vcs — add alias VC injection after the existing precondition VC loop for each call site. Location: after the `for (pre_idx, pre) in callee_summary.contracts.requires.iter()...` block (~line 2508), still inside `for call_site in &path.call_sites`:

    ```rust
    // Alias VC injection: one VC per alias_precondition in callee summary
    for alias_pre in &callee_summary.alias_preconditions {
        let arg_a = call_site.args.get(alias_pre.param_idx_a);
        let arg_b = call_site.args.get(alias_pre.param_idx_b);

        let (a_name, b_name) = match (arg_a, arg_b) {
            (Some(Operand::Move(Place { local, .. }) | Operand::Copy(Place { local, .. })),
             Some(Operand::Move(Place { local: local2, .. }) | Operand::Copy(Place { local: local2, .. }))) => {
                (local.clone(), local2.clone())
            }
            _ => {
                tracing::debug!(
                    callee = %call_site.callee_name,
                    "alias precondition: could not resolve argument names — skipping"
                );
                continue;
            }
        };

        let mut script = base_script(
            datatype_declarations,
            declarations,
            uses_spec_int_types(func),
        );

        // Encode prior assignments
        let mut ssa_counter = HashMap::new();
        for pa in &call_site.prior_assignments {
            if let Some(cmd) = encode_assignment(&pa.place, &pa.rvalue, func, &mut ssa_counter) {
                script.push(cmd);
            }
        }

        // Assume caller preconditions
        for caller_pre in &func.contracts.requires {
            if let Some(term) = parse_spec(&caller_pre.raw, func, ghost_pred_db) {
                script.push(Command::Assert(term));
            }
        }

        // Assume path condition
        if let Some(ref cond) = call_site.path_condition {
            script.push(Command::Assert(cond.clone()));
        }

        // Assert alias violation (SAT = a and b have equal addresses)
        let alias_assertion = crate::heap_model::generate_alias_check_assertion(&a_name, &b_name);
        script.push(Command::Assert(alias_assertion));
        script.push(rust_fv_smtlib::command::Command::CheckSat);

        vcs.push(VerificationCondition {
            description: format!(
                "pointer aliasing: call to `{}` — arg[{}] (`{}`) and arg[{}] (`{}`) must not alias ({})",
                call_site.callee_name,
                alias_pre.param_idx_a, a_name,
                alias_pre.param_idx_b, b_name,
                alias_pre.raw,
            ),
            script,
            location: VcLocation {
                function: func.name.clone(),
                block: call_site.block_idx,
                statement: 0,
                source_file: None,
                source_line: None,
                source_column: None,
                contract_text: Some(alias_pre.raw.clone()),
                vc_kind: VcKind::PointerAliasing,
            },
        });
    }
    ```

    Note on Operand pattern: Check the actual Operand and Place types in ir.rs. Use the correct destructuring — Place has a `local` field (String). Operand variants are Move(Place) and Copy(Place). Use `if let` chains or a helper closure to extract the local name cleanly.

    Step 3: unsafe_verification.rs — Update test_cross_function_pointer_aliasing:
    - Remove the DEBTLINE comment block (lines 1103-1115)
    - Build a ContractDatabase with the callee's FunctionSummary including alias_preconditions: vec![AliasPrecondition { param_idx_a: 0, param_idx_b: 1, raw: "!alias(_1, _2)".into() }]
    - Call generate_vcs_with_db instead of generate_vcs
    - Assert VcKind::PointerAliasing VC count == 1
    - Assert existing null-check VC count == 1 (no regression)

    REFACTOR:
    ```
    cargo clippy -p rust-fv-analysis -- -D warnings 2>&1
    cargo fmt -p rust-fv-analysis
    cargo test -p rust-fv-analysis 2>&1 | tail -30
    ```

    Fix any clippy warnings before marking done.
  </implementation>
</feature>

<verification>
```bash
# Full test suite — all green
cargo test -p rust-fv-analysis 2>&1 | tail -30

# Regression guard: existing unsafe_verification tests unchanged
cargo test -p rust-fv-analysis -- unsafe_verification 2>&1 | grep -E "test.*ok|FAILED"

# New alias tests pass
cargo test -p rust-fv-analysis -- alias 2>&1 | grep -E "test.*ok|FAILED"

# Clippy clean
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep -v "^$"
```

Confirm:
- test_alias_vc_sat_when_same_pointer_passed: Z3 returns SAT
- test_alias_vc_unsat_when_different_pointers: Z3 returns UNSAT
- test_cross_function_pointer_aliasing: VcKind::PointerAliasing count == 1, MemorySafety count == 1
- All existing unsafe_verification tests: GREEN
</verification>

<success_criteria>
- extract_alias_preconditions parses "!alias(_1, _2)" from unsafe_requires and returns param indices 0, 1
- generate_call_site_vcs emits VcKind::PointerAliasing VCs for each alias_precondition in callee summary
- Alias VC description names arg indices and local names: "arg[0] (`_1`) and arg[1] (`_2`)"
- Z3 confirms: same pointer → SAT, distinct pointers → UNSAT
- cargo test -p rust-fv-analysis — all tests GREEN, no FAILED lines
- cargo clippy -p rust-fv-analysis -- -D warnings — no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/34-cross-function-pointer-aliasing/34-02-SUMMARY.md`
</output>

---
phase: 34-cross-function-pointer-aliasing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/heap_model.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/contract_db.rs
autonomous: true
requirements:
  - ALIAS-01
  - ALIAS-02

must_haves:
  truths:
    - "spec_parser parses `alias(p, q)` in #[unsafe_requires] and produces an SMT equality term (= p q) on BitVec 64"
    - "heap_model exposes generate_alias_check_assertion(p, q) returning Term::Eq over BitVec 64 Const terms"
    - "VcKind has a PointerAliasing variant usable as a filter on VerificationCondition"
    - "contract_db FunctionSummary carries alias_preconditions: Vec<AliasPrecondition> where AliasPrecondition holds param_idx_a, param_idx_b, and raw spec text"
    - "All existing heap_model, spec_parser, and vcgen unit tests remain GREEN (cargo test -p rust-fv-analysis)"
  artifacts:
    - path: "crates/analysis/src/heap_model.rs"
      provides: "generate_alias_check_assertion(p_term, q_term) helper"
      exports: ["generate_alias_check_assertion"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::PointerAliasing variant"
      contains: "PointerAliasing"
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "alias(p, q) parse arm in convert_call"
      contains: "\"alias\""
    - path: "crates/analysis/src/contract_db.rs"
      provides: "AliasPrecondition struct and alias_preconditions field in FunctionSummary"
      contains: "AliasPrecondition"
  key_links:
    - from: "spec_parser.rs alias arm"
      to: "heap_model.rs generate_alias_check_assertion"
      via: "direct call returning Term::Eq(p_bv64, q_bv64)"
    - from: "contract_db.rs FunctionSummary"
      to: "AliasPrecondition"
      via: "alias_preconditions field on FunctionSummary used by plan-02 call-site injection"
---

<objective>
Lay the core infrastructure for cross-function pointer aliasing: a new SMT assertion helper, the VcKind variant that classifies alias VCs, the spec_parser arm that turns `alias(p, q)` annotations into SMT terms, and the contract_db extension that stores alias preconditions per parameter-index pair.

Purpose: Plan 02 depends on every piece created here. Nothing in plan 01 generates call-site VCs yet — this plan wires the contracts and primitives so plan 02 can inject alias checks at call boundaries.

Output:
- `generate_alias_check_assertion` in heap_model.rs (like null_check_assertion, but for address equality)
- `VcKind::PointerAliasing` variant in vcgen.rs
- `alias(p, q)` parse arm in spec_parser.rs
- `AliasPrecondition` struct + `alias_preconditions` field in contract_db.rs FunctionSummary
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/34-cross-function-pointer-aliasing/34-CONTEXT.md

<interfaces>
<!-- Key contracts the executor needs. No codebase exploration required. -->

From crates/analysis/src/heap_model.rs:
```rust
/// Returns SMT term asserting ptr == 0 (the violation condition for null-check).
pub fn generate_null_check_assertion(ptr_name: &str) -> Term {
    Term::Eq(
        Box::new(Term::Const(ptr_name.to_string())),
        Box::new(Term::BitVecLit(0, 64)),
    )
}
// New function to add (same pattern):
// pub fn generate_alias_check_assertion(p_name: &str, q_name: &str) -> Term
// Returns: Term::Eq(Term::Const(p_name), Term::Const(q_name))
// Semantics: SAT means p and q have equal addresses (aliasing violation found).
```

From crates/analysis/src/vcgen.rs VcKind enum (add PointerAliasing after MemorySafety):
```rust
pub enum VcKind {
    // ... existing variants ...
    MemorySafety,
    PointerAliasing,  // NEW — raw pointer argument aliasing at call boundaries
    // ... rest ...
}
```

From crates/analysis/src/spec_parser.rs convert_call (add before `_ =>` arm):
```rust
"alias" => {
    // alias(p, q) — pointer non-aliasing predicate
    // Encodes as SAT-check: (= p q) on BitVec 64
    // Two arguments required: alias(ptr_a, ptr_b)
    if call_expr.args.len() != 2 {
        tracing::warn!("alias() requires exactly 2 arguments: alias(ptr_a, ptr_b)");
        return None;
    }
    let p_term = convert_expr_with_bounds(&call_expr.args[0], func, false, in_postcondition, in_int_mode, bound_vars)?;
    let q_term = convert_expr_with_bounds(&call_expr.args[1], func, false, in_postcondition, in_int_mode, bound_vars)?;
    return Some(crate::heap_model::generate_alias_check_assertion_from_terms(p_term, q_term));
}
```

From crates/analysis/src/contract_db.rs:
```rust
pub struct FunctionSummary {
    pub contracts: Contracts,
    pub param_names: Vec<String>,
    pub param_types: Vec<Ty>,
    pub return_ty: Ty,
    // NEW:
    pub alias_preconditions: Vec<AliasPrecondition>,
}

// NEW struct:
#[derive(Debug, Clone)]
pub struct AliasPrecondition {
    /// Zero-based index of first pointer parameter (e.g., 0 for first param)
    pub param_idx_a: usize,
    /// Zero-based index of second pointer parameter (e.g., 1 for second param)
    pub param_idx_b: usize,
    /// Raw spec text for diagnostics (e.g., "!ptr_a.alias(ptr_b)")
    pub raw: String,
}
```
</interfaces>
</context>

<feature>
  <name>Cross-function pointer aliasing core infrastructure</name>
  <files>
    crates/analysis/src/heap_model.rs,
    crates/analysis/src/vcgen.rs,
    crates/analysis/src/spec_parser.rs,
    crates/analysis/src/contract_db.rs
  </files>
  <behavior>
    heap_model tests:
    - generate_alias_check_assertion("_1", "_2") returns Term::Eq(Term::Const("_1"), Term::Const("_2"))
    - generate_alias_check_assertion("p", "p") returns Term::Eq where both sides are the same Const (self-alias, always SAT)
    - generate_alias_check_assertion_from_terms(t1, t2) returns Term::Eq(t1, t2)

    spec_parser tests:
    - parse_spec_expr("alias(ptr_a, ptr_b)", &func) returns Some(term) where term is Term::Eq
    - parse_spec_expr("alias(p)", &func) returns None (wrong arity, logs warn)
    - parse_spec_expr("alias(ptr_a, ptr_b, ptr_c)", &func) returns None (wrong arity)
    - parse_spec_expr("!alias(p, q)", &func) returns Some(Term::Not(Term::Eq(...)))

    VcKind tests:
    - VcKind::PointerAliasing != VcKind::MemorySafety
    - VcKind::PointerAliasing can be used in filter: vc.location.vc_kind == VcKind::PointerAliasing

    contract_db tests:
    - FunctionSummary with alias_preconditions: vec![AliasPrecondition { param_idx_a: 0, param_idx_b: 1, raw: "!ptr_a.alias(ptr_b)".into() }] is constructible
    - alias_preconditions field defaults to vec![] when not specified
  </behavior>
  <implementation>
    TDD cycle:

    RED — Write failing tests first:

    1. In heap_model.rs #[cfg(test)] mod tests block, add:
       - test_generate_alias_check_assertion_different_ptrs: asserts Term::Eq(Const("_1"), Const("_2"))
       - test_generate_alias_check_assertion_same_ptr: asserts Term::Eq where both sides are Const("p")

    2. In spec_parser.rs #[cfg(test)] mod tests block, add:
       - test_alias_parse_basic: parse_spec_expr("alias(ptr_a, ptr_b)", &func_with_two_ptr_params) returns Some(Term::Eq)
       - test_alias_parse_wrong_arity_one: parse_spec_expr("alias(p)", &func) returns None
       - test_alias_parse_wrong_arity_three: returns None
       - test_alias_negated: parse_spec_expr("!alias(p, q)", &func) returns Some(Term::Not(...))

    3. In contract_db.rs #[cfg(test)] mod tests block, add:
       - test_alias_precondition_stored: FunctionSummary { alias_preconditions: vec![AliasPrecondition {...}], ...} roundtrips through insert/get

    Run `cargo test -p rust-fv-analysis 2>&1 | grep -E "FAILED|error"` — all new tests MUST fail.

    GREEN — Implement minimally:

    1. heap_model.rs: Add after generate_bounds_check_assertion:
       ```rust
       /// Generates alias-check assertion term: p == q (SAT = aliasing violation).
       /// Used as the VC body for `#[unsafe_requires(!alias(p, q))]` call-site checks.
       pub fn generate_alias_check_assertion(p_name: &str, q_name: &str) -> Term {
           Term::Eq(
               Box::new(Term::Const(p_name.to_string())),
               Box::new(Term::Const(q_name.to_string())),
           )
       }

       /// Same as generate_alias_check_assertion but takes pre-built terms.
       /// Used by spec_parser when converting alias(p, q) expressions.
       pub fn generate_alias_check_assertion_from_terms(p: Term, q: Term) -> Term {
           Term::Eq(Box::new(p), Box::new(q))
       }
       ```

    2. vcgen.rs VcKind enum: Add `PointerAliasing` variant after `MemorySafety`:
       ```rust
       /// Pointer argument aliasing check at function call boundaries.
       /// Generated when callee has #[unsafe_requires(!alias(p, q))].
       PointerAliasing,
       ```
       No other changes to vcgen.rs in this plan.

    3. spec_parser.rs: In convert_call() function, add "alias" arm before the `_ =>` fallthrough:
       ```rust
       "alias" => {
           if call_expr.args.len() != 2 {
               tracing::warn!("alias() requires exactly 2 arguments: alias(ptr_a, ptr_b)");
               return None;
           }
           let p_term = convert_expr_with_bounds(
               &call_expr.args[0], func, false, in_postcondition, in_int_mode, bound_vars,
           )?;
           let q_term = convert_expr_with_bounds(
               &call_expr.args[1], func, false, in_postcondition, in_int_mode, bound_vars,
           )?;
           return Some(crate::heap_model::generate_alias_check_assertion_from_terms(p_term, q_term));
       }
       ```

    4. contract_db.rs:
       - Add AliasPrecondition struct before FunctionSummary:
         ```rust
         /// A pointer non-aliasing precondition extracted from #[unsafe_requires(!alias(p, q))].
         /// Stored by parameter index (not name) so it survives call-site argument substitution.
         #[derive(Debug, Clone)]
         pub struct AliasPrecondition {
             /// Zero-based index of first pointer parameter in callee signature.
             pub param_idx_a: usize,
             /// Zero-based index of second pointer parameter in callee signature.
             pub param_idx_b: usize,
             /// Raw spec text for counterexample diagnostics.
             pub raw: String,
         }
         ```
       - Add `alias_preconditions: Vec<AliasPrecondition>` field to FunctionSummary.
       - Update all existing FunctionSummary construction sites in contract_db.rs tests to add `alias_preconditions: vec![]`.

    REFACTOR — Run clippy and ensure all tests green:
    ```
    cargo clippy -p rust-fv-analysis -- -D warnings
    cargo fmt -p rust-fv-analysis
    cargo test -p rust-fv-analysis
    ```
  </implementation>
</feature>

<verification>
```
cargo test -p rust-fv-analysis 2>&1 | tail -20
```
All tests pass. No FAILED lines. PointerAliasing variant compiles. alias parse arm reachable.

Specific new tests must pass:
- test_generate_alias_check_assertion_different_ptrs
- test_generate_alias_check_assertion_same_ptr
- test_alias_parse_basic
- test_alias_parse_wrong_arity_one
- test_alias_negated
- test_alias_precondition_stored

Regression guard (intra-procedural null/bounds tests unchanged):
```
cargo test -p rust-fv-analysis -- unsafe_verification 2>&1 | grep -E "test.*ok|FAILED"
```
All existing unsafe_verification tests remain GREEN.
</verification>

<success_criteria>
- generate_alias_check_assertion("_1", "_2") compiles and returns Term::Eq
- VcKind::PointerAliasing exists and is distinct from VcKind::MemorySafety
- spec_parser converts "alias(p, q)" to Some(Term::Eq) and "alias(p)" to None
- FunctionSummary has alias_preconditions field, AliasPrecondition is pub exported
- cargo test -p rust-fv-analysis — all tests GREEN, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-cross-function-pointer-aliasing/34-01-SUMMARY.md`
</output>

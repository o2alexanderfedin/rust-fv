---
phase: 29.3-borrow-conflict-detection-implementation
verified: 2026-02-25T22:00:00Z
status: passed
score: 4/4 must-haves verified
re_verification: false
---

# Phase 29.3: Borrow Conflict Detection Implementation Verification Report

**Phase Goal:** Implement generate_expiry_vcs() in borrow_conflict.rs — replace the stub returning Vec::new() (line 144) with real use-after-expiry detection that scans basic blocks outside a borrow's live range for local references and emits BorrowValidity VCs
**Verified:** 2026-02-25T22:00:00Z
**Status:** passed
**Re-verification:** No — initial verification

---

## Goal Achievement

### Observable Truths

| # | Truth | Status | Evidence |
|---|-------|--------|----------|
| 1 | generate_expiry_vcs() returns at least one BorrowValidity VC when a borrow local is used in a block outside its live range | VERIFIED | test_generate_expiry_vcs_use_after_expiry: borrow _1 live in [0,1], used in block 2 → asserts vcs.len()==1, BorrowValidity, block==2, statement==0 — passes |
| 2 | generate_expiry_vcs() returns zero VCs when all borrow uses are within the live range | VERIFIED | test_generate_expiry_vcs_no_expiry: borrow live in [0,1,2], all 3 blocks — asserts vcs.len()==0 — passes |
| 3 | All 13 existing unit tests in borrow_conflict::tests continue to pass | VERIFIED | cargo test output: all 13 borrow_conflict::tests pass (test_detect_conflicts_none, test_detect_conflicts_multiple, test_detect_conflicts_non_overlapping, test_detect_conflicts_overlapping, test_generate_conflict_vc_description, test_generate_conflict_vcs_empty, test_generate_conflict_vcs_produces_vc, test_generate_expiry_vcs_no_expiry, test_generate_expiry_vcs_use_after_expiry, test_generate_reborrow_vcs_valid, test_generate_reborrow_vcs_outlives, test_vcgen_borrow_validity_integration, test_vcgen_no_lifetime_no_borrow_vcs) |
| 4 | cargo test passes with 0 failures across the full crate | VERIFIED | cargo test -p rust-fv-analysis: 1202 passed; 0 failed; 0 ignored |

**Score:** 4/4 truths verified

---

### Required Artifacts

| Artifact | Expected | Status | Details |
|----------|----------|--------|---------|
| `crates/analysis/src/borrow_conflict.rs` | generate_expiry_vcs() implementation + helper fns + updated test assertions | VERIFIED | File exists. Contains full generate_expiry_vcs() implementation (lines 185-239), three private helpers: collect_locals_in_operand() (lines 135-141), collect_locals_in_rvalue() (lines 143-160), statement_references_local() (lines 162-175). No TODO stub at line 144 — stub replaced entirely. Test assertions use vcs.len()==1, BorrowValidity, block==2, statement==0. |

**Artifact substantiveness check:**
- `fn statement_references_local` present at line 162: FOUND
- `generate_expiry_vcs` body is not `Vec::new()` — contains `context.shared_borrows().into_iter().chain(context.mutable_borrows())` iterator, block scanning loop, and VC emission: CONFIRMED
- No `// TODO: implement` comment remaining in the file: CONFIRMED

**Artifact wiring check:**
- `generate_expiry_vcs()` is a public function called from the VCGen pipeline (vcgen.rs lines 491-494 per RESEARCH.md)
- `statement_references_local()` called inside `generate_expiry_vcs()` at line 213: WIRED
- `collect_locals_in_rvalue()` called inside `statement_references_local()` at line 167: WIRED
- `collect_locals_in_operand()` called inside `collect_locals_in_rvalue()` at multiple lines: WIRED

---

### Key Link Verification

| From | To | Via | Status | Details |
|------|----|-----|--------|---------|
| generate_expiry_vcs() | context.shared_borrows() + context.mutable_borrows() | chain() iterator over all borrows | WIRED | Lines 193-197: `context.shared_borrows().into_iter().chain(context.mutable_borrows())` — both borrow collections chained; functionally equivalent to the plan's pattern though spread across three lines |
| generate_expiry_vcs() | VcLocation { vc_kind: VcKind::BorrowValidity, .. } | VerificationCondition emission | WIRED | Line 230: `vc_kind: VcKind::BorrowValidity` inside the VC push at lines 219-233; emitted once per statement-level expiry violation found |

**Note on chain() pattern:** The PLAN frontmatter specifies pattern `shared_borrows.*chain.*mutable_borrows` as a single-line match. The actual code spans three lines (`.shared_borrows()` / `.into_iter()` / `.chain(context.mutable_borrows())`). The wiring is functionally identical and correct — the regex pattern was written for single-line formatting but the implementation is multi-line idiomatic Rust.

---

### Requirements Coverage

| Requirement | Source Plan | Description | Status | Evidence |
|-------------|------------|-------------|--------|----------|
| BORROW-EXPIRY-01 | 29.3-01-PLAN.md | Use-after-lifetime-end detection via statement scanning in generate_expiry_vcs() | SATISFIED | generate_expiry_vcs() implemented and tested; ROADMAP.md line 330 references this requirement for Phase 29.3 |

**Note on REQUIREMENTS.md:** No `.planning/REQUIREMENTS.md` file exists in this project. The requirement ID BORROW-EXPIRY-01 is tracked exclusively in ROADMAP.md (line 330). This is not a gap in the implementation — it is a gap in the project's requirements tracking infrastructure, outside the scope of Phase 29.3.

**Orphaned requirements check:** ROADMAP.md references BORROW-EXPIRY-01 only for Phase 29.3. No additional requirement IDs are mapped to this phase in any other planning document.

---

### Anti-Patterns Found

| File | Line | Pattern | Severity | Impact |
|------|------|---------|----------|--------|
| borrow_conflict.rs | — | No TODO/FIXME/HACK/PLACEHOLDER found | — | Clean |
| borrow_conflict.rs | 51, 101, 190, 251 | Vec::new() | INFO | All are accumulator initializations, not stub returns |

No blocker anti-patterns detected. All `Vec::new()` usages are legitimate mutable accumulator initializations inside functions that then populate and return the vector.

---

### Human Verification Required

None. All verification was accomplished programmatically:
- Implementation existence and content verified by direct file read
- Test behavior verified by cargo test execution (1202 passed, 0 failed)
- Clippy ran cleanly (0 code warnings in the analysis crate; one unrelated Cargo.toml file-duplication warning in the driver crate appeared but was suppressed by `-p rust-fv-analysis` scope)
- Commit hashes 85fdb5a (RED) and 0d9ffc0 (GREEN) verified via git show

---

### Commits Verified

| Hash | Message | Role |
|------|---------|------|
| 85fdb5a | test(29.3-01): RED — test_generate_expiry_vcs_use_after_expiry asserts len==1 | TDD RED state |
| 0d9ffc0 | feat(29.3-01): implement generate_expiry_vcs() with statement scanning | TDD GREEN implementation |

---

### Gaps Summary

No gaps. Phase goal fully achieved.

The stub `generate_expiry_vcs()` that previously returned `Vec::new()` unconditionally has been replaced with a complete implementation that:
1. Iterates all borrows (shared and mutable) via chain() iterator
2. Looks up each borrow's live range from the `live_ranges` map
3. Scans every basic block outside the live range for statement-level local references
4. Emits a `BorrowValidity` VC with precise block/statement location for each violation found

Three private helper functions support exhaustive statement scanning with no wildcard arms — the compiler enforces completeness if the IR's Statement/Rvalue variants are extended in future phases.

---

_Verified: 2026-02-25T22:00:00Z_
_Verifier: Claude (gsd-verifier)_

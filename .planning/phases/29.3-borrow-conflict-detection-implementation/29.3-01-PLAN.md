---
phase: 29.3-borrow-conflict-detection-implementation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/borrow_conflict.rs
autonomous: true
requirements:
  - BORROW-EXPIRY-01
must_haves:
  truths:
    - "generate_expiry_vcs() returns at least one BorrowValidity VC when a borrow local is used in a block outside its live range"
    - "generate_expiry_vcs() returns zero VCs when all borrow uses are within the live range"
    - "All 13 existing unit tests in borrow_conflict::tests continue to pass"
    - "cargo test passes with 0 failures across the full crate"
  artifacts:
    - path: "crates/analysis/src/borrow_conflict.rs"
      provides: "generate_expiry_vcs() implementation + helper fns + updated test assertions"
      contains: "fn statement_references_local"
  key_links:
    - from: "generate_expiry_vcs()"
      to: "context.shared_borrows() + context.mutable_borrows()"
      via: "chain() iterator over all borrows"
      pattern: "shared_borrows.*chain.*mutable_borrows"
    - from: "generate_expiry_vcs()"
      to: "VcLocation { vc_kind: VcKind::BorrowValidity, .. }"
      via: "VerificationCondition emission"
      pattern: "BorrowValidity"
---

<objective>
Implement `generate_expiry_vcs()` in `crates/analysis/src/borrow_conflict.rs` — the single stub function (line 144) that currently returns `Vec::new()` unconditionally.

Purpose: Enable use-after-lifetime-end detection. When a borrow local appears in a basic block outside its declared live range, emit a `BorrowValidity` verification condition. This completes the third and final borrow validity category (after shared/mutable conflict and reborrow outlives checks).

Output: Working `generate_expiry_vcs()` + private helpers + updated test assertions. Zero new files.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

# Key interfaces — executor should use these directly, no codebase exploration needed

From crates/analysis/src/borrow_conflict.rs (lines 97-133) — template to replicate:
```rust
pub fn generate_conflict_vcs(
    conflicts: &[BorrowConflict],
    function_name: &str,
) -> Vec<VerificationCondition> {
    let mut vcs = Vec::new();
    for conflict in conflicts {
        let script = Script::new();
        let description = format!(
            "Shared borrow {} and mutable borrow {} cannot overlap at BB{:?}",
            conflict.shared_borrow, conflict.mutable_borrow, conflict.overlapping_blocks
        );
        let location = VcLocation {
            function: function_name.to_string(),
            block: conflict.overlapping_blocks.first().copied().unwrap_or(0),
            statement: 0,
            source_file: None, source_line: None, source_column: None,
            contract_text: None,
            vc_kind: VcKind::BorrowValidity,
        };
        vcs.push(VerificationCondition { description, script, location });
    }
    vcs
}
```

From crates/analysis/src/ir.rs (actual Rvalue variants — exhaustive list):
```rust
pub enum Rvalue {
    Use(Operand),
    BinaryOp(BinOp, Operand, Operand),
    CheckedBinaryOp(BinOp, Operand, Operand),
    UnaryOp(UnOp, Operand),
    Cast(CastKind, Operand, Ty),
    Ref(Mutability, Place),
    Aggregate(AggregateKind, Vec<Operand>),
    Len(Place),
    Discriminant(Place),
    Repeat(Operand, usize),
    // NOTE: No RawPtr, CopyForDeref, NullaryOp, or ShallowInitBox variants exist
}

pub enum Statement {
    Assign(Place, Rvalue),
    Nop,
    SetDiscriminant(Place, usize),
    Assume(Operand),
}

pub enum Operand {
    Copy(Place),
    Move(Place),
    Constant(Constant),
}

pub struct Place {
    pub local: String,
    pub projections: Vec<Projection>,
}
```

From crates/analysis/src/borrow_conflict.rs (stub to replace, lines 139-146):
```rust
pub fn generate_expiry_vcs(
    _context: &LifetimeContext,
    _live_ranges: &HashMap<String, Vec<usize>>,
    _function: &Function,
) -> Vec<VerificationCondition> {
    // TODO: implement
    Vec::new()
}
```

From crates/analysis/src/borrow_conflict.rs (test to update, lines 424-486):
The test `test_generate_expiry_vcs_use_after_expiry` currently:
- Has borrow `_1` with live_ranges `vec![0, 1]`
- Has a 3-block function where blocks 0, 1, 2 all have EMPTY statements
- Asserts `vcs.len() == 0` (acknowledged stub behavior)

This test must be updated to add a `Statement::Assign` using `_1` in block 2, and assert `vcs.len() == 1`.
</context>

<tasks>

<task type="tdd">
  <name>Task 1: RED — update test_generate_expiry_vcs_use_after_expiry to assert len == 1</name>
  <files>crates/analysis/src/borrow_conflict.rs</files>
  <action>
In `test_generate_expiry_vcs_use_after_expiry` (line 425), make the test RED by:

1. Add a `Statement::Assign` to block 2 that references local `_1`. Use:
   ```rust
   Statement::Assign(
       Place::local("_0"),
       Rvalue::Use(Operand::Copy(Place::local("_1"))),
   )
   ```
   Block 2 must have `statements: vec![that_statement]` instead of `vec![]`.

2. Change the assertion from `assert_eq!(vcs.len(), 0)` to:
   ```rust
   assert_eq!(vcs.len(), 1);
   assert_eq!(vcs[0].location.vc_kind, VcKind::BorrowValidity);
   assert_eq!(vcs[0].location.block, 2);
   assert_eq!(vcs[0].location.statement, 0);
   ```

3. Remove the comment "This will be 0 until we implement statement scanning".

4. Add import `use crate::ir::Statement;` at the top of the test module if not already present (check current imports at line 215: `use crate::ir::{BasicBlock, BorrowInfo, Contracts, Local, Terminator, Ty}`).
   Update the import to include `Statement`: `use crate::ir::{BasicBlock, BorrowInfo, Contracts, Local, Statement, Terminator, Ty};`.

Run: `cargo test -p rust-fv-analysis test_generate_expiry_vcs_use_after_expiry 2>&1 | tail -20`
Expected: test FAILS (RED state — stub returns 0, test expects 1).
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis test_generate_expiry_vcs_use_after_expiry 2>&1 | grep -E "FAILED|test_generate_expiry_vcs"</automated>
  </verify>
  <done>test_generate_expiry_vcs_use_after_expiry FAILS with "left: 0, right: 1" (RED state confirmed)</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN — implement generate_expiry_vcs() with statement scanning helpers</name>
  <files>crates/analysis/src/borrow_conflict.rs</files>
  <action>
Replace the stub `generate_expiry_vcs()` with the full implementation. Also add three private helper functions immediately above it (or below the imports, before the public functions). All code stays in `borrow_conflict.rs`.

**Step 1: Add private helpers before `generate_expiry_vcs`:**

```rust
fn collect_locals_in_operand(op: &crate::ir::Operand) -> Vec<String> {
    use crate::ir::Operand;
    match op {
        Operand::Copy(p) | Operand::Move(p) => vec![p.local.clone()],
        Operand::Constant(_) => vec![],
    }
}

fn collect_locals_in_rvalue(rval: &crate::ir::Rvalue) -> Vec<String> {
    use crate::ir::Rvalue;
    match rval {
        Rvalue::Use(op) | Rvalue::Cast(_, op, _) | Rvalue::Repeat(op, _) => {
            collect_locals_in_operand(op)
        }
        Rvalue::Ref(_, place) | Rvalue::Len(place) | Rvalue::Discriminant(place) => {
            vec![place.local.clone()]
        }
        Rvalue::BinaryOp(_, l, r) | Rvalue::CheckedBinaryOp(_, l, r) => {
            let mut v = collect_locals_in_operand(l);
            v.extend(collect_locals_in_operand(r));
            v
        }
        Rvalue::UnaryOp(_, op) => collect_locals_in_operand(op),
        Rvalue::Aggregate(_, ops) => ops.iter().flat_map(collect_locals_in_operand).collect(),
    }
}

fn statement_references_local(stmt: &crate::ir::Statement, local: &str) -> bool {
    use crate::ir::Statement;
    let locals = match stmt {
        Statement::Assign(place, rvalue) => {
            let mut ls = vec![place.local.clone()];
            ls.extend(collect_locals_in_rvalue(rvalue));
            ls
        }
        Statement::Nop => vec![],
        Statement::SetDiscriminant(place, _) => vec![place.local.clone()],
        Statement::Assume(op) => collect_locals_in_operand(op),
    };
    locals.iter().any(|l| l == local)
}
```

**Step 2: Replace the stub `generate_expiry_vcs()` with:**

```rust
pub fn generate_expiry_vcs(
    context: &LifetimeContext,
    live_ranges: &HashMap<String, Vec<usize>>,
    function: &Function,
) -> Vec<VerificationCondition> {
    let mut vcs = Vec::new();

    // Check all borrows (shared and mutable) for use-after-expiry.
    // NOTE: compute_live_ranges() in production uses conservative 0..num_blocks ranges,
    // so this function only detects expiry in production when precise NLL ranges are
    // provided. Unit tests use narrow explicit ranges to exercise this logic.
    let all_borrows: Vec<_> = context
        .shared_borrows()
        .into_iter()
        .chain(context.mutable_borrows())
        .collect();

    for borrow in all_borrows {
        let live_blocks = match live_ranges.get(&borrow.local_name) {
            Some(blocks) => blocks,
            None => continue,
        };

        for (block_idx, block) in function.basic_blocks.iter().enumerate() {
            // Block is in live range — borrow is valid here, skip
            if live_blocks.contains(&block_idx) {
                continue;
            }

            // Scan statements for any reference to this borrow's local
            for (stmt_idx, stmt) in block.statements.iter().enumerate() {
                if statement_references_local(stmt, &borrow.local_name) {
                    let expiry_block = live_blocks.last().copied().unwrap_or(0);
                    let description = format!(
                        "Borrow {} (region {}) used at BB{} stmt {} after expiry at BB{}",
                        borrow.local_name,
                        borrow.region,
                        block_idx,
                        stmt_idx,
                        expiry_block
                    );
                    vcs.push(VerificationCondition {
                        description,
                        script: Script::new(),
                        location: VcLocation {
                            function: function.name.clone(),
                            block: block_idx,
                            statement: stmt_idx,
                            source_file: None,
                            source_line: None,
                            source_column: None,
                            contract_text: None,
                            vc_kind: VcKind::BorrowValidity,
                        },
                    });
                }
            }
        }
    }

    vcs
}
```

After implementing, run clippy and fmt, then run the full test suite:
1. `cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo fmt -p rust-fv-analysis`
2. `cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | tail -30`
3. `cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis 2>&1 | tail -30`

Expected: All tests pass, including `test_generate_expiry_vcs_use_after_expiry` asserting len==1.
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis 2>&1 | tail -10</automated>
  </verify>
  <done>
    - cargo test -p rust-fv-analysis: 0 failures, all tests pass (including test_generate_expiry_vcs_use_after_expiry with len==1 assertion)
    - cargo clippy -p rust-fv-analysis -- -D warnings: 0 warnings
    - generate_expiry_vcs() no longer a stub — contains statement scanning logic
    - test_generate_expiry_vcs_no_expiry still passes (borrow used in all 3 blocks, live range covers all 3)
  </done>
</task>

</tasks>

<verification>
Run the full analysis crate test suite to confirm no regressions:

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis 2>&1 | grep -E "test result|FAILED|ok$"
```

Expected: `test result: ok. N passed; 0 failed; 0 ignored`

Run clippy to confirm no lint warnings:
```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep -E "warning|error" | head -10
```
</verification>

<success_criteria>
- `generate_expiry_vcs()` implementation replaces the `Vec::new()` stub (lines 139-146)
- `test_generate_expiry_vcs_use_after_expiry` passes with assertion `len() == 1` (not `len() == 0`)
- `test_generate_expiry_vcs_no_expiry` still passes (borrow in range → 0 VCs)
- All 13 existing unit tests in `borrow_conflict::tests` pass
- All integration tests in `crates/analysis/tests/lifetime_verification.rs` pass
- `cargo clippy -p rust-fv-analysis -- -D warnings` exits 0
- `borrow_conflict.rs:144` is no longer a `// TODO: implement` stub
</success_criteria>

<output>
After completion, create `.planning/phases/29.3-borrow-conflict-detection-implementation/29.3-01-SUMMARY.md`
</output>

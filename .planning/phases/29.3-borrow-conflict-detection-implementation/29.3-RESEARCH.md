# Phase 29.3: Borrow Conflict Detection Implementation - Research

**Researched:** 2026-02-25
**Domain:** Rust borrow checker verification / SMT VC generation
**Confidence:** HIGH

## Summary

Phase 29.3 fixes a single stub function in `crates/analysis/src/borrow_conflict.rs`: `generate_expiry_vcs()` at line 144 returns `Vec::new()` unconditionally (TODO comment). The other three public functions in that module (`detect_borrow_conflicts`, `generate_conflict_vcs`, `generate_reborrow_vcs`) are fully implemented and all 13 unit tests in the module pass green.

The function's job is to scan a `Function`'s basic blocks for any statement that **uses** a borrow local after the borrow's live range has ended. When it finds such a use, it should emit a `VerificationCondition` with `VcKind::BorrowValidity`. This is "use-after-lifetime-end" detection — the third and final category of borrow validity check (after shared/mutable conflict and reborrow outlives).

The implementation complexity is LOW. The IR already provides everything needed: `func.basic_blocks` (with `Statement::Assign`, `Rvalue`, `Operand`, `Place`), the live range map from `compute_live_ranges()`, and the borrow registry from `LifetimeContext`. The existing `generate_conflict_vcs()` is the exact template to follow for emitting `VerificationCondition` objects. The existing test `test_generate_expiry_vcs_use_after_expiry` already asserts `len() == 0` (which will need updating to assert `> 0` once implemented).

**Primary recommendation:** Implement `generate_expiry_vcs()` by scanning each basic block's statements and terminator operands for references to borrow locals; if a reference appears in a block not in the borrow's live range, emit a `BorrowValidity` VC using `Script::new()` + `VcLocation` + `VcKind::BorrowValidity` — exactly as `generate_conflict_vcs()` does.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `rust_fv_analysis::borrow_conflict` | in-repo | Module being implemented | Only location for expiry detection |
| `rust_fv_smtlib::script::Script` | in-repo | SMT script container for VCs | All VCs use `Script::new()` |
| `std::collections::HashMap` | std | `live_ranges: &HashMap<String, Vec<usize>>` | Already in function signature |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `crate::vcgen::{VcKind, VcLocation, VerificationCondition}` | in-repo | VC output type | Emit one per expiry violation |
| `crate::ir::{Function, Statement, Rvalue, Operand, Place}` | in-repo | IR traversal | Scan statements for local refs |
| `crate::lifetime_analysis::LifetimeContext` | in-repo | Access borrow registry | Enumerate borrows to check |

## Architecture Patterns

### Pattern 1: generate_conflict_vcs() Template
**What:** The existing `generate_conflict_vcs()` is the exact pattern to replicate for expiry VCs.
**When to use:** Always — for any BorrowValidity VC emission.
**Example:**
```rust
// Source: crates/analysis/src/borrow_conflict.rs:97-133
pub fn generate_conflict_vcs(
    conflicts: &[BorrowConflict],
    function_name: &str,
) -> Vec<VerificationCondition> {
    let mut vcs = Vec::new();
    for conflict in conflicts {
        let script = Script::new();
        let description = format!("...", conflict.shared_borrow, ...);
        let location = VcLocation {
            function: function_name.to_string(),
            block: conflict.overlapping_blocks.first().copied().unwrap_or(0),
            statement: 0,
            source_file: None,
            source_line: None,
            source_column: None,
            contract_text: None,
            vc_kind: VcKind::BorrowValidity,
        };
        vcs.push(VerificationCondition { description, script, location });
    }
    vcs
}
```

### Pattern 2: Scanning Statements for Local References
**What:** Walk `func.basic_blocks[block_idx].statements` and extract all local names referenced.
**When to use:** In `generate_expiry_vcs()` to find where each borrow local is used.

```rust
// Source: crates/analysis/src/ir.rs (Statement/Rvalue/Operand/Place types)
fn collect_locals_in_statement(stmt: &Statement) -> Vec<String> {
    match stmt {
        Statement::Assign(place, rvalue) => {
            let mut locals = collect_locals_in_place(place);
            locals.extend(collect_locals_in_rvalue(rvalue));
            locals
        }
        Statement::Nop => vec![],
        Statement::SetDiscriminant(place, _) => collect_locals_in_place(place),
        Statement::Assume(operand) => collect_locals_in_operand(operand),
    }
}

fn collect_locals_in_rvalue(rval: &Rvalue) -> Vec<String> {
    match rval {
        Rvalue::Use(op) | Rvalue::Cast(_, op, _) | Rvalue::Repeat(op, _) => {
            collect_locals_in_operand(op)
        }
        Rvalue::Ref(_, place) | Rvalue::Len(place) | Rvalue::Discriminant(place) => {
            collect_locals_in_place(place)
        }
        Rvalue::BinaryOp(_, l, r) | Rvalue::CheckedBinaryOp(_, l, r) => {
            let mut v = collect_locals_in_operand(l);
            v.extend(collect_locals_in_operand(r));
            v
        }
        Rvalue::UnaryOp(_, op) => collect_locals_in_operand(op),
        Rvalue::Aggregate(_, ops) => ops.iter().flat_map(collect_locals_in_operand).collect(),
        Rvalue::RawPtr(_, place) | Rvalue::CopyForDeref(place) => {
            collect_locals_in_place(place)
        }
        Rvalue::NullaryOp(_, _) | Rvalue::ShallowInitBox(_, _) => vec![],
    }
}

fn collect_locals_in_operand(op: &Operand) -> Vec<String> {
    match op {
        Operand::Copy(p) | Operand::Move(p) => collect_locals_in_place(p),
        Operand::Constant(_) => vec![],
    }
}

fn collect_locals_in_place(place: &Place) -> Vec<String> {
    vec![place.local.clone()]
}
```

### Pattern 3: Expiry Detection Algorithm
**What:** Cross-reference borrow local against its live range map per block.

```rust
// Conceptual algorithm for generate_expiry_vcs()
for borrow in context.mutable_borrows().iter().chain(context.shared_borrows()) {
    let live_blocks = match live_ranges.get(&borrow.local_name) {
        Some(blocks) => blocks,
        None => continue,
    };

    for (block_idx, block) in func.basic_blocks.iter().enumerate() {
        // Skip if this block IS in the live range
        if live_blocks.contains(&block_idx) {
            continue;
        }
        // Scan statements for use of borrow local
        for (stmt_idx, stmt) in block.statements.iter().enumerate() {
            let locals = collect_locals_in_statement(stmt);
            if locals.contains(&borrow.local_name) {
                // Use-after-expiry detected — emit VC
                let description = format!(
                    "Borrow {} (region {}) used at BB{} after expiry (live range: {:?})",
                    borrow.local_name, borrow.region, block_idx, live_blocks
                );
                let location = VcLocation {
                    function: func.name.clone(),
                    block: block_idx,
                    statement: stmt_idx,
                    source_file: None,
                    source_line: None,
                    source_column: None,
                    contract_text: None,
                    vc_kind: VcKind::BorrowValidity,
                };
                vcs.push(VerificationCondition {
                    description,
                    script: Script::new(),
                    location,
                });
            }
        }
    }
}
```

### Recommended Project Structure
No structural changes needed. Everything is in:
```
crates/analysis/src/
└── borrow_conflict.rs   # Only file changing — generate_expiry_vcs() implementation
```

### Anti-Patterns to Avoid
- **Using `_function` parameter then not implementing**: The parameter is already in the signature (`_function: &Function`); just remove the leading underscore and use it.
- **Emitting SMT commands in Script**: Do NOT add `SetLogic` or `CheckSat` commands — `generate_conflict_vcs()` uses `Script::new()` (empty script) and the pattern must be consistent.
- **Testing with conservative live ranges**: `compute_live_ranges()` returns ALL block indices for every borrow (conservative approximation). This means with conservative live ranges, no expiry VCs will ever fire — the test must use EXPLICITLY NARROWED live ranges where a borrow's live range excludes the block where it's used.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Local scanning | Custom AST visitor | Pattern match on `Statement`/`Rvalue`/`Operand`/`Place` | IR is simple, direct match is clearest |
| VC emission | Custom struct | `VerificationCondition { description, script: Script::new(), location }` | Exact same as `generate_conflict_vcs()` |
| Borrow enumeration | Separate data structure | `context.mutable_borrows()` + `context.shared_borrows()` | Already provided by `LifetimeContext` |

**Key insight:** This is pure data traversal with pattern matching. No new data structures needed.

## Common Pitfalls

### Pitfall 1: Conservative Live Ranges Make Expiry Impossible to Detect
**What goes wrong:** `compute_live_ranges()` (called from `vcgen.rs`) assigns ALL block indices to every borrow. With this range, no block is ever "outside the live range", so `generate_expiry_vcs()` would always emit 0 VCs even if correctly implemented.
**Why it happens:** The comment in `lifetime_analysis.rs:244` explicitly says "Simple heuristic: assume borrow is live from block 0 to the end."
**How to avoid:** The test `test_generate_expiry_vcs_use_after_expiry` must provide NARROW live ranges (e.g., borrow `_1` only live in `vec![0, 1]` but function has 3 blocks and block 2 uses `_1`). The UNIT TEST for `generate_expiry_vcs` is the only place where precise live ranges are provided.
**Warning signs:** If all tests still pass `len() == 0`, the implementation is correct for conservative live ranges but the test was expecting the stub behavior.

### Pitfall 2: Test Assertion Mismatch
**What goes wrong:** `test_generate_expiry_vcs_use_after_expiry` currently asserts `len() == 0` with comment "This will be 0 until we implement statement scanning". After implementation, this test needs to be UPDATED to assert `len() > 0` (or a specific count).
**Why it happens:** The test was written as a forward-declaration of intent, not as a TDD RED test.
**How to avoid:** Update the test expectation as part of the implementation.

### Pitfall 3: Missing Terminator Scanning
**What goes wrong:** Borrow locals can appear in `Terminator::Call` arguments, `Terminator::SwitchInt` discriminant, or `Terminator::Assert` condition — not just in statements.
**Why it happens:** Only scanning `block.statements` misses these uses.
**How to avoid:** Also scan `block.terminator` for local references, or document that terminator scanning is deferred (with a TODO comment).

### Pitfall 4: Double-Counting via Place vs. Borrow Local Name
**What goes wrong:** A reborrow's `source_local` points to the original borrow. If we scan `place.local` and find `_1` in a `Deref` projection of `_2`, we'd only find `_2` (the direct local), not `_1` (the source).
**Why it happens:** Place projection scanning only finds the root local of the place expression.
**How to avoid:** Only match `place.local` directly (root of place). This is correct behavior — the borrow `_1` is expired when the place root IS `_1`, not when a field of `_1` is accessed through a projection.

## Code Examples

### Complete `generate_expiry_vcs()` Implementation Shape

```rust
// Source: crates/analysis/src/borrow_conflict.rs (implementation target)
pub fn generate_expiry_vcs(
    context: &LifetimeContext,
    live_ranges: &HashMap<String, Vec<usize>>,
    function: &Function,
) -> Vec<VerificationCondition> {
    let mut vcs = Vec::new();

    // Check all borrows (both shared and mutable) for use-after-expiry
    let all_borrows: Vec<&BorrowInfo> = context
        .shared_borrows()
        .into_iter()
        .chain(context.mutable_borrows())
        .collect();

    for borrow in all_borrows {
        let live_blocks = match live_ranges.get(&borrow.local_name) {
            Some(blocks) => blocks,
            None => continue,
        };

        for (block_idx, block) in function.basic_blocks.iter().enumerate() {
            // If block is in live range, borrow is valid here — skip
            if live_blocks.contains(&block_idx) {
                continue;
            }

            // Scan statements for use of this borrow's local
            for (stmt_idx, stmt) in block.statements.iter().enumerate() {
                if statement_references_local(stmt, &borrow.local_name) {
                    let expiry_block = live_blocks.last().copied().unwrap_or(0);
                    let description = format!(
                        "Borrow {} (region {}) used at BB{} stmt {} after expiry at BB{}",
                        borrow.local_name, borrow.region,
                        block_idx, stmt_idx, expiry_block
                    );
                    vcs.push(VerificationCondition {
                        description,
                        script: Script::new(),
                        location: VcLocation {
                            function: function.name.clone(),
                            block: block_idx,
                            statement: stmt_idx,
                            source_file: None,
                            source_line: None,
                            source_column: None,
                            contract_text: None,
                            vc_kind: VcKind::BorrowValidity,
                        },
                    });
                }
            }
        }
    }

    vcs
}
```

### Unit Test Shape for Expiry Detection

```rust
// Update test_generate_expiry_vcs_use_after_expiry to assert > 0:
// Borrow _1 live only in [0, 1], but used in block 2
let mut live_ranges = HashMap::new();
live_ranges.insert("_1".to_string(), vec![0, 1]);  // NOT block 2

// Function has 3 blocks: 0->1->2 (Return)
// Block 2 has a statement using _1

let vcs = generate_expiry_vcs(&context, &live_ranges, &func);
assert_eq!(vcs.len(), 1);  // Updated from 0 to 1
assert_eq!(vcs[0].location.vc_kind, VcKind::BorrowValidity);
assert_eq!(vcs[0].location.block, 2);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Stub returning `Vec::new()` | Scan statements + terminator | Phase 29.3 | Enables use-after-expiry detection |
| Conservative live ranges only | Conservative live ranges (unit tests use precise ranges) | No change needed | Tests must provide narrow ranges |

**Notes on the "stub" designation:**
- Lines 140-145: `_context`, `_live_ranges`, `_function` (all underscored params) + `Vec::new()` = pure stub
- `generate_conflict_vcs()` and `generate_reborrow_vcs()` ARE implemented and working
- 13 unit tests in `borrow_conflict::tests` ALL pass — none are testing expiry detection with actual statement scanning
- The test `test_generate_expiry_vcs_use_after_expiry` asserts `len() == 0` explicitly acknowledging the stub

## Open Questions

1. **Should terminator scanning be in-scope for Phase 29.3?**
   - What we know: `Terminator::Call` args, `Terminator::SwitchInt` discriminant, `Terminator::Assert` condition can all reference borrow locals
   - What's unclear: Whether any test scenario requires terminator scanning to pass
   - Recommendation: Start with statement-only scanning (sufficient for existing test shape). Add terminator scanning only if needed for a new test. Document as TODO.

2. **Should `generate_expiry_vcs` emit SMT commands or just annotate with empty Script?**
   - What we know: `generate_conflict_vcs()` uses `Script::new()` (empty script). VCs are consumed by Z3 solver which checks UNSAT. An empty script would be trivially UNSAT.
   - What's unclear: Whether expiry VCs should encode the actual SMT formula for the violation
   - Recommendation: Use `Script::new()` consistently with `generate_conflict_vcs()`. The empty script approach is already the established pattern in this codebase. Encoding actual liveness predicates in SMT would require a separate phase.

3. **Will conservative live ranges cause zero expiry VCs in production?**
   - What we know: `compute_live_ranges()` returns `0..num_blocks` for all borrows. In the production path (vcgen.rs:482), these conservative ranges are used. With conservative ranges, every block IS in the live range, so `generate_expiry_vcs()` will always return 0 VCs in production.
   - What's unclear: Whether this is intentional or a known limitation
   - Recommendation: Implement correctly for narrow ranges (which is what unit tests use). Note this in code comments. Precise NLL-based live ranges are a future concern documented in `lifetime_analysis.rs:238-251`.

## Validation Architecture

> nyquist_validation not set in config.json — no Validation Architecture section required.

## Sources

### Primary (HIGH confidence)
- `/Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/src/borrow_conflict.rs` — Full source, stub at line 144, all 13 tests examined
- `/Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/src/lifetime_analysis.rs` — `compute_live_ranges()`, `build_lifetime_context()`, `LifetimeContext` API
- `/Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/src/vcgen.rs:471-499` — How `generate_expiry_vcs` is called in production VCGen pipeline
- `/Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/tests/lifetime_verification.rs` — All 9 integration tests PASS (examined)
- `cargo test` run — 1202 unit tests pass, 0 failed, 0 ignored

### Secondary (MEDIUM confidence)
- STATE.md decision log — confirms Phase 29.3 is "URGENT — borrow_conflict.rs:144 is a stub returning 0 always"

## Metadata

**Confidence breakdown:**
- What the stub is: HIGH — directly read line 144 of borrow_conflict.rs
- How it is called: HIGH — directly read vcgen.rs:491-494
- What the output type should be: HIGH — `Vec<VerificationCondition>` same as other functions
- Implementation algorithm: HIGH — pattern match on IR types, clear from existing impl patterns
- Test expectations: HIGH — all tests read, current assertions identified, update needed

**Research date:** 2026-02-25
**Valid until:** 60 days — this is stable internal code, no external dependencies

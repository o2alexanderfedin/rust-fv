---
phase: 07-closures
plan: 02
type: tdd
wave: 2
depends_on: ["07-01"]
files_modified:
  - crates/analysis/src/defunctionalize.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Closure calls are defunctionalized to first-order function calls with explicit environment parameter"
    - "VCGen generates closure contract VCs (assume closure contract at call site, check function postcondition)"
    - "FnMut closures use prophecy variables for mutable capture state"
    - "FnOnce closures enforce single-call semantics"
    - "Spec parser handles closure parameter references in requires/ensures (e.g., closure(x))"
    - "Closure environment fields accessible in SMT encoding via datatype selectors"
  artifacts:
    - path: "crates/analysis/src/defunctionalize.rs"
      provides: "Defunctionalization pass transforming closure calls to first-order"
      exports: ["defunctionalize_closure_call", "build_closure_function_body", "ClosureEncoding"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Closure-aware VC generation integrating defunctionalization and prophecy variables"
      contains: "closure"
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Parsing closure parameter references in specifications"
      contains: "closure"
  key_links:
    - from: "crates/analysis/src/defunctionalize.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Reads Ty::Closure, ClosureInfo, ClosureTrait to produce first-order encoding"
      pattern: "ClosureInfo"
    - from: "crates/analysis/src/defunctionalize.rs"
      to: "crates/analysis/src/closure_analysis.rs"
      via: "Uses ClosureCallSite from closure analysis"
      pattern: "ClosureCallSite"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/defunctionalize.rs"
      via: "Calls defunctionalize to get first-order encoding before SMT generation"
      pattern: "defunctionalize"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_prophecy.rs"
      via: "Uses prophecy infrastructure for FnMut mutable captures"
      pattern: "prophecy"
---

<objective>
Implement defunctionalization transformation and integrate closure verification into VCGen.

Purpose: This is the core verification logic. Defunctionalization transforms higher-order closure calls into first-order SMT-solvable problems. VCGen integration enables the full verification pipeline: closure environment encoding, contract assumption at call sites, and postcondition checking. Spec parser extension allows users to reference closure parameters in specifications.

Output: `defunctionalize.rs` module, extended VCGen with closure-aware path handling, extended spec parser for closure references in contracts.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-closures/07-RESEARCH.md
@.planning/phases/07-closures/07-01-SUMMARY.md

@crates/analysis/src/ir.rs
@crates/analysis/src/closure_analysis.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/encode_prophecy.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/contract_db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create defunctionalize module and extend spec parser for closure references</name>
  <files>crates/analysis/src/defunctionalize.rs, crates/analysis/src/spec_parser.rs, crates/analysis/src/lib.rs</files>
  <action>
TDD: Write tests first, then implement.

**Part A: defunctionalize.rs (NEW file)**

Create `crates/analysis/src/defunctionalize.rs` and register in `lib.rs` as `pub mod defunctionalize;`.

This module implements the Reynolds (1972) defunctionalization pattern adapted for Rust closures:

1. `ClosureEncoding` struct:
   - `env_datatype_name: String` -- SMT datatype name for the closure environment
   - `env_constructor: String` -- constructor name (e.g., "mk-closure_add")
   - `env_selectors: Vec<(String, Sort)>` -- field selectors and their sorts
   - `defunctionalized_name: String` -- first-order function name (e.g., "closure_add_impl")
   - `param_sorts: Vec<Sort>` -- parameter sorts (env_sort followed by explicit param sorts)
   - `return_sort: Sort` -- return type sort
   - `trait_kind: ClosureTrait` -- Fn/FnMut/FnOnce

2. `defunctionalize_closure_call(info: &ClosureInfo, call_args: &[Operand]) -> ClosureEncoding`:
   - Takes ClosureInfo (from Ty::Closure) and the actual call arguments
   - Produces ClosureEncoding with:
     - env_datatype_name: info.name (reuses closure name as datatype name)
     - env_constructor: "mk-{info.name}"
     - env_selectors: each env_field -> ("{info.name}-{field_name}", encode_type(&field_ty))
     - defunctionalized_name: "{info.name}_impl"
     - param_sorts: [Sort::Datatype(info.name)] ++ encode_type for each param
     - return_sort: encode_type(&info.return_ty)
     - trait_kind: info.trait_kind

3. `build_closure_function_body(encoding: &ClosureEncoding, body_term: Term) -> Vec<Command>`:
   - Generates SMT `(define-fun name ((env EnvSort) (p1 S1) ...) RetSort body_term)` command
   - For Fn closures: straightforward define-fun
   - For FnMut closures: adds prophecy variable parameters for mutable captures
   - For FnOnce closures: same as Fn (ownership transfer handled at call site validation level)

4. `encode_closure_call_term(encoding: &ClosureEncoding, env_term: Term, arg_terms: Vec<Term>) -> Term`:
   - Returns `Term::App(defunctionalized_name, [env_term] ++ arg_terms)` -- the first-order function application

5. `encode_closure_as_uninterpreted(info: &ClosureInfo) -> Vec<Command>`:
   - For closures WITHOUT visible bodies (opaque/from parameters), encode as uninterpreted function
   - `(declare-fun closure_name_impl (env_sort param_sorts...) return_sort)`
   - This is used when a function accepts a closure parameter -- we don't know the body, just the contract

**Part B: spec_parser.rs extension**

Extend the spec parser to handle closure parameter references in specifications:

1. In `convert_expr_with_bounds` (the main expression conversion function), detect function call expressions where the function name matches a closure parameter name. Currently `convert_call` handles known functions like `old()`, `final_value()`, `forall()`, `exists()`, `implies()`. Add handling for:
   - If the call target is a function parameter name that has `Ty::Closure` type in the function, encode as `Term::App("{param_name}_impl", [env_term] ++ converted_arg_terms)`
   - This allows specs like `#[requires(forall(|x: i32| x > 0 ==> predicate(x) == true))]` where `predicate` is a closure parameter

2. Add helper `is_closure_param(name: &str, func: &Function) -> Option<&ClosureInfo>`:
   - Check if `name` matches a parameter whose type is `Ty::Closure(info)` and return the info

Tests (write FIRST):

For defunctionalize.rs:
- `test_defunctionalize_fn_closure`: Create ClosureInfo for Fn closure with i32 env field and i32 param, call defunctionalize_closure_call, verify encoding fields (env_datatype_name, defunctionalized_name, param_sorts, return_sort, trait_kind)
- `test_defunctionalize_fnmut_closure`: FnMut closure, verify trait_kind is FnMut and encoding is correct
- `test_defunctionalize_fnonce_closure`: FnOnce closure, verify trait_kind is FnOnce
- `test_encode_closure_call_term`: Create encoding, call encode_closure_call_term with env Term and arg Terms, verify resulting Term::App has correct function name and argument count
- `test_encode_closure_as_uninterpreted`: Create ClosureInfo, call encode_closure_as_uninterpreted, verify Command::DeclareFun with correct sorts
- `test_defunctionalize_empty_env`: Closure with no captures (empty env_fields), verify encoding works (single-element param_sorts containing just the empty env)
- `test_defunctionalize_multi_field_env`: Closure capturing 3 variables, verify all env_selectors present

For spec_parser.rs:
- `test_closure_param_reference_in_spec`: Build Function with closure param "predicate" of type Ty::Closure, parse spec "predicate(x) > 0", verify Term::App with "{param}_impl" name
- `test_non_closure_param_not_treated_as_closure`: Regular i32 param named "f", parse spec "f > 0", verify normal variable encoding (not closure call)
  </action>
  <verify>`cargo test -p rust-fv-analysis --lib -- defunctionalize` and `cargo test -p rust-fv-analysis --lib -- closure_param` pass all new tests. `cargo test -p rust-fv-analysis` passes all tests. `cargo clippy --workspace -- -D warnings` produces 0 warnings.</verify>
  <done>defunctionalize.rs module exists with ClosureEncoding, defunctionalize_closure_call, build_closure_function_body, encode_closure_call_term, encode_closure_as_uninterpreted. spec_parser handles closure parameter references in specifications. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate closure handling into VCGen (Fn, FnMut prophecy, FnOnce single-call)</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
TDD: Write tests first, then implement.

Extend `generate_vcs()` in vcgen.rs to handle closures, following the same integration pattern used for recursion (Phase 6, lines 254-295 of vcgen.rs). Add a closure analysis section AFTER the recursion analysis section.

1. **Closure detection in generate_vcs()**: After the recursion analysis block, add:
   ```
   // Closure analysis: detect closure parameters and generate closure-related VCs
   {
       let closure_infos = closure_analysis::extract_closure_info(func);
       let closure_calls = closure_analysis::detect_closure_calls(func);
       // ... processing below
   }
   ```

2. **FnOnce validation**: Call `closure_analysis::validate_fnonce_single_call(func)`. For each error, generate a diagnostic VC (always-SAT, like missing-decreases pattern from Phase 6) with VcKind::ClosureContract and description including the error message.

3. **Closure contract encoding at call sites**: For each closure call site detected:
   a. Look up the closure's ClosureInfo from the function's locals/params
   b. If the closure has associated contracts (from the function's requires/ensures that reference the closure parameter), encode:
      - For Fn closures: `(declare-fun closure_impl (EnvSort ParamSorts...) RetSort)` as uninterpreted + assume closure contract axiom from function's requires
      - For FnMut closures: Same as Fn PLUS prophecy variable declarations for mutable capture fields. Use the existing `encode_prophecy` module pattern -- for each mutable env field, create ProphecyInfo with initial_var and prophecy_var. Track intermediate states between calls using SSA-style naming (e.g., `capture_after_call1`, `capture_after_call2`).
      - For FnOnce closures: Same as Fn (ownership enforced by validate_fnonce_single_call)

4. **Closure environment construction encoding**: When encountering `Rvalue::Aggregate(AggregateKind::Closure(name), operands)` in path traversal (the existing `encode_rvalue` or assignment encoding), encode as datatype constructor application: `Term::App("mk-{name}", [encoded_operands...])`. This follows the same pattern as `AggregateKind::Struct` encoding.

5. **Contract VC generation for closure-accepting functions**: In `generate_contract_vcs()`, when the function has closure parameters:
   - In precondition encoding: Skip closure-related preconditions (they are assumptions about the closure, not checks on the caller)
   - In postcondition encoding: Assume closure contract (from requires that reference the closure), encode function body with defunctionalized closure calls, then assert function postcondition
   - The key insight: `#[requires(forall(|x| x > 0 ==> closure(x) > 0))]` becomes an SMT assumption `(assert (forall ((x (_ BitVec 32))) (=> (bvsgt x #x00000000) (bvsgt (closure_impl env x) #x00000000))))`

6. Handle the case where a function parameter is a closure but has NO explicit contract -- in this case, the closure is treated as fully uninterpreted (no assumptions about its behavior), which is sound but may cause postcondition VCs to be unprovable.

Tests (write FIRST as unit tests within vcgen.rs `#[cfg(test)] mod tests` section):
- `test_vcgen_fn_closure_basic`: Build Function with Fn closure parameter and a simple postcondition. Verify VCs are generated with correct closure contract encoding (the postcondition VC script should contain declare-fun for the closure).
- `test_vcgen_fnmut_closure_prophecy`: Build Function with FnMut closure parameter that mutates captured state. Verify prophecy variables are declared in the VC script for the mutable capture.
- `test_vcgen_fnonce_double_call_diagnostic`: Build Function with FnOnce closure called twice. Verify a diagnostic VC (VcKind::ClosureContract) is generated.
- `test_vcgen_closure_contract_assumed`: Build Function with closure parameter and requires clause referencing the closure. Verify the requires clause appears as an assumption (assert) in the postcondition VC script.
- `test_vcgen_closure_env_construction`: Build Function with AggregateKind::Closure in assignment. Verify the SMT script contains the datatype constructor application.
  </action>
  <verify>`cargo test -p rust-fv-analysis --lib -- test_vcgen_fn_closure` and `cargo test -p rust-fv-analysis --lib -- test_vcgen_fnmut` and `cargo test -p rust-fv-analysis --lib -- test_vcgen_fnonce` pass. `cargo test -p rust-fv-analysis` passes all tests. `cargo clippy --workspace -- -D warnings` produces 0 warnings.</verify>
  <done>VCGen handles Fn closures (uninterpreted function + contract assumption), FnMut closures (prophecy variables for mutable captures), FnOnce closures (single-call validation). Closure environment construction encoded as datatype constructor. Closure contract from requires clause assumed in postcondition VC. All tests pass including all 1,788+ existing tests.</done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis` -- all tests pass (existing + new)
2. `cargo clippy --workspace -- -D warnings` -- 0 warnings
3. `cargo fmt --all -- --check` -- no formatting issues
4. Defunctionalization transforms closure calls to first-order Term::App
5. VCGen generates closure contract VCs for all three trait kinds
6. FnMut closures produce prophecy variable declarations
7. FnOnce double-call produces diagnostic VC
8. Closure contracts from requires assumed in postcondition VCs
9. Spec parser resolves closure parameter references to defunctionalized function calls
</verification>

<success_criteria>
- defunctionalize.rs module exists with ClosureEncoding, all defunctionalization functions
- VCGen generates VCs for functions with Fn, FnMut, FnOnce closure parameters
- FnMut closures use prophecy variables for mutable captures
- FnOnce double-call validation produces diagnostic VC
- Closure contracts (from requires/ensures) are assumed/checked correctly
- Spec parser handles closure(x) references in specifications
- All existing tests still pass (zero regressions)
- 0 clippy warnings, 0 formatting issues
</success_criteria>

<output>
After completion, create `.planning/phases/07-closures/07-02-SUMMARY.md`
</output>

---
phase: 07-closures
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/closure_analysis.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "ClosureTrait enum distinguishes Fn, FnMut, FnOnce capture modes"
    - "Ty::Closure variant encodes closure name, environment fields, params, return type, and trait kind"
    - "AggregateKind::Closure variant allows constructing closure environments in IR"
    - "VcKind::ClosureContract variant enables closure-specific VC diagnostics"
    - "closure_analysis module extracts ClosureInfo from Function IR"
    - "encode_sort handles Ty::Closure by encoding environment as SMT datatype"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "ClosureTrait enum, ClosureInfo struct, Ty::Closure variant, AggregateKind::Closure variant, VcKind::ClosureContract"
      contains: "ClosureTrait"
    - path: "crates/analysis/src/closure_analysis.rs"
      provides: "Closure detection and environment extraction from IR"
      exports: ["extract_closure_info", "classify_closure_trait", "ClosureCallSite"]
    - path: "crates/analysis/src/encode_sort.rs"
      provides: "SMT datatype encoding for Ty::Closure"
      contains: "Ty::Closure"
    - path: "crates/analysis/src/lib.rs"
      provides: "pub mod closure_analysis"
      contains: "closure_analysis"
  key_links:
    - from: "crates/analysis/src/closure_analysis.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Uses ClosureTrait, ClosureInfo, Ty::Closure"
      pattern: "use crate::ir"
    - from: "crates/analysis/src/encode_sort.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Matches Ty::Closure in encode_type and collect_from_type"
      pattern: "Ty::Closure"
---

<objective>
Add closure representation to the IR and implement closure analysis infrastructure.

Purpose: Provide the foundational types and analysis for closure verification. Without these, neither defunctionalization nor VCGen can handle closures. This mirrors the Phase 6 Plan 01 pattern of building IR extensions and detection infrastructure first.

Output: `Ty::Closure` variant in IR, `ClosureTrait` enum (Fn/FnMut/FnOnce), `ClosureInfo` struct, `closure_analysis.rs` module for closure detection, SMT datatype encoding for closure environments.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-closures/07-RESEARCH.md

@crates/analysis/src/ir.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add closure types to IR (ClosureTrait, ClosureInfo, Ty::Closure, AggregateKind::Closure, VcKind::ClosureContract)</name>
  <files>crates/analysis/src/ir.rs</files>
  <action>
TDD: Write tests first, then implement.

1. Add `ClosureTrait` enum with three variants: `Fn`, `FnMut`, `FnOnce`. Derive Debug, Clone, Copy, PartialEq, Eq. This enum classifies the closure capture mode per Rust's Fn trait hierarchy.

2. Add `ClosureInfo` struct with fields:
   - `name: String` -- unique closure identifier (e.g., "closure_add_captured")
   - `env_fields: Vec<(String, Ty)>` -- captured variable names and their types
   - `params: Vec<(String, Ty)>` -- closure parameter names and types
   - `return_ty: Ty` -- closure return type
   - `trait_kind: ClosureTrait` -- which Fn trait this closure implements
   Derive Debug, Clone.

3. Add `Ty::Closure(Box<ClosureInfo>)` variant to the `Ty` enum. Use Box to avoid recursive type size explosion since ClosureInfo contains Vec<Ty>.

4. Add `AggregateKind::Closure(String)` variant -- the String is the closure name, paralleling `AggregateKind::Struct(String)`. This allows `Rvalue::Aggregate(AggregateKind::Closure("name"), operands)` to construct closure environments.

5. In `vcgen.rs` (the VcKind enum at line ~78): Add `VcKind::ClosureContract` variant for closure contract verification conditions. This follows the same pattern as `VcKind::Termination` added in Phase 6.

6. Add `Ty::is_closure(&self) -> bool` helper method returning `matches!(self, Self::Closure(_))`.

Tests (write FIRST):
- `test_closure_trait_equality`: Assert ClosureTrait::Fn == ClosureTrait::Fn, Fn != FnMut, etc.
- `test_closure_info_creation`: Create ClosureInfo with env_fields, params, return_ty, trait_kind; verify fields.
- `test_ty_closure_variant`: Create Ty::Closure(Box::new(info)), verify is_closure() returns true.
- `test_ty_non_closure_is_not_closure`: Ty::Int(I32).is_closure() returns false.
- `test_aggregate_kind_closure`: Construct AggregateKind::Closure("test".into()), verify Debug output.
- `test_vc_kind_closure_contract`: Construct VcKind::ClosureContract, verify equality.
  </action>
  <verify>`cargo test -p rust-fv-analysis --lib -- closure` passes all new tests AND `cargo test -p rust-fv-analysis` passes all existing tests (no regressions). `cargo clippy --workspace -- -D warnings` produces 0 warnings.</verify>
  <done>ClosureTrait enum, ClosureInfo struct, Ty::Closure variant, AggregateKind::Closure variant, VcKind::ClosureContract variant, and is_closure() helper all exist with passing tests. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create closure_analysis module and extend encode_sort for Ty::Closure</name>
  <files>crates/analysis/src/closure_analysis.rs, crates/analysis/src/encode_sort.rs, crates/analysis/src/lib.rs</files>
  <action>
TDD: Write tests first, then implement.

**Part A: closure_analysis.rs (NEW file)**

Create `crates/analysis/src/closure_analysis.rs` module and register it in `lib.rs` as `pub mod closure_analysis;`.

This module provides:

1. `ClosureCallSite` struct with fields:
   - `closure_name: String` -- which closure is being called
   - `args: Vec<Operand>` -- arguments passed to the closure (excluding environment)
   - `destination: Place` -- where the return value is stored
   - `block_idx: usize` -- which basic block the call occurs in
   - `trait_kind: ClosureTrait` -- what Fn trait the closure implements

2. `extract_closure_info(func: &Function) -> Vec<&ClosureInfo>` -- scan function parameters and locals for `Ty::Closure` types and return references to their ClosureInfo.

3. `detect_closure_calls(func: &Function) -> Vec<ClosureCallSite>` -- scan function terminators for `Terminator::Call` where the callee name matches a known closure pattern (starts with "Fn::call", "FnMut::call_mut", or "FnOnce::call_once", OR matches a closure name from the function's locals/params). Returns ClosureCallSite structs.

4. `classify_closure_trait(callee_name: &str) -> Option<ClosureTrait>` -- parse trait from callee name:
   - Contains "call_once" -> FnOnce
   - Contains "call_mut" -> FnMut
   - Contains "call" (but not "call_mut"/"call_once") -> Fn
   - Otherwise -> None

5. `validate_fnonce_single_call(func: &Function) -> Vec<String>` -- detect FnOnce closures called more than once (unsound). Returns error messages for each violation.

Tests (write FIRST in closure_analysis.rs as `#[cfg(test)] mod tests`):
- `test_classify_fn_call`: "Fn::call" -> Some(Fn)
- `test_classify_fnmut_call`: "FnMut::call_mut" -> Some(FnMut)
- `test_classify_fnonce_call`: "FnOnce::call_once" -> Some(FnOnce)
- `test_classify_unknown`: "random_func" -> None
- `test_classify_call_mut_not_fn`: "FnMut::call_mut" should NOT classify as Fn
- `test_extract_closure_info_from_params`: Build Function with Ty::Closure param, verify extract_closure_info returns it
- `test_extract_closure_info_empty`: Build Function with no closures, verify empty result
- `test_detect_closure_calls`: Build Function with Terminator::Call to "Fn::call", verify ClosureCallSite returned
- `test_validate_fnonce_single_call_ok`: FnOnce closure called once -> empty errors
- `test_validate_fnonce_double_call`: FnOnce closure called twice -> error returned

**Part B: encode_sort.rs extension**

1. In `encode_type()`: Add match arm for `Ty::Closure(info)` that returns `Sort::Datatype(info.name.clone())`. This parallels how `Ty::Struct(name, _)` returns `Sort::Datatype(name.clone())`.

2. In `collect_from_type()`: Add match arm for `Ty::Closure(info)` that:
   - Checks `seen.insert(info.name.clone())`
   - Recurses into `info.env_fields` types
   - Creates `DatatypeVariant` with constructor `mk-{closure_name}` and fields `{closure_name}-{field_name}` for each environment field
   - Pushes `Command::DeclareDatatype { name: info.name, variants: vec![variant] }`
   This follows the EXACT same pattern as `Ty::Struct` handling (lines 120-139 of encode_sort.rs).

Tests (add to encode_sort.rs tests):
- `test_closure_encodes_to_datatype`: Ty::Closure(info) -> Sort::Datatype("closure_name")
- `test_collect_closure_datatype_declaration`: Build Function with Ty::Closure param, call collect_datatype_declarations, verify DeclareDatatype with correct constructor and field selectors
- `test_closure_env_field_types_encoded`: Closure with i32 and bool env fields -> correct Sort::BitVec(32) and Sort::Bool in fields
  </action>
  <verify>`cargo test -p rust-fv-analysis --lib -- closure` passes all new tests. `cargo test -p rust-fv-analysis` passes all tests (including existing). `cargo clippy --workspace -- -D warnings` produces 0 warnings. `cargo fmt --all -- --check` passes.</verify>
  <done>closure_analysis.rs exists with extract_closure_info, detect_closure_calls, classify_closure_trait, validate_fnonce_single_call. encode_sort.rs handles Ty::Closure with datatype encoding. All tests pass including existing tests (no regressions).</done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis` -- all tests pass (existing + new)
2. `cargo clippy --workspace -- -D warnings` -- 0 warnings
3. `cargo fmt --all -- --check` -- no formatting issues
4. Ty::Closure round-trips through encode_type to Sort::Datatype
5. closure_analysis correctly classifies Fn/FnMut/FnOnce calls
6. AggregateKind::Closure exists for environment construction
7. VcKind::ClosureContract exists for diagnostic classification
</verification>

<success_criteria>
- ClosureTrait enum with Fn/FnMut/FnOnce variants exists and is tested
- ClosureInfo struct with env_fields, params, return_ty, trait_kind exists
- Ty::Closure variant in Ty enum, Ty::is_closure() helper works
- AggregateKind::Closure variant exists for IR construction
- VcKind::ClosureContract variant exists for diagnostics
- closure_analysis.rs module with detection and classification functions
- encode_sort handles Ty::Closure as SMT datatype with environment fields
- All existing 1,788 tests still pass (zero regressions)
- 0 clippy warnings, 0 formatting issues
</success_criteria>

<output>
After completion, create `.planning/phases/07-closures/07-01-SUMMARY.md`
</output>

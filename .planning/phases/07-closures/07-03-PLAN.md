---
phase: 07-closures
plan: 03
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - crates/analysis/tests/closure_verification.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Developer verifies function accepting Fn closure with immutable captures via Z3"
    - "Developer verifies function accepting FnMut closure with mutable captures using prophecy variables via Z3"
    - "Developer verifies function accepting FnOnce closure with move semantics via Z3"
    - "Developer specifies closure contract via requires/ensures referencing closure parameter, verified via Z3"
    - "Developer sees closure contract violation diagnostic pointing to closure call site"
  artifacts:
    - path: "crates/analysis/tests/closure_verification.rs"
      provides: "End-to-end closure verification tests via Z3"
      min_lines: 500
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Closure-specific diagnostic formatting"
      contains: "ClosureContract"
  key_links:
    - from: "crates/analysis/tests/closure_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "Calls generate_vcs() with closure-bearing IR Functions, pipes to Z3"
      pattern: "generate_vcs"
    - from: "crates/analysis/tests/closure_verification.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Constructs IR with Ty::Closure, ClosureInfo, AggregateKind::Closure"
      pattern: "ClosureInfo"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "Matches VcKind::ClosureContract for formatting"
      pattern: "ClosureContract"
---

<objective>
Create end-to-end closure verification tests via Z3 and add closure diagnostics, validating all 5 Phase 7 success criteria.

Purpose: Prove the full closure verification pipeline works end-to-end by constructing IR programs with closures, generating VCs, rendering to SMT-LIB, and solving with Z3. Add diagnostic formatting for closure contract failures. This is the final plan that validates Phase 7 completeness.

Output: `closure_verification.rs` integration test file with 8+ e2e tests, closure-specific diagnostic helpers in driver.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-closures/07-RESEARCH.md
@.planning/phases/07-closures/07-01-SUMMARY.md
@.planning/phases/07-closures/07-02-SUMMARY.md

@crates/analysis/src/ir.rs
@crates/analysis/src/closure_analysis.rs
@crates/analysis/src/defunctionalize.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/tests/recursion_verification.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add closure diagnostic helpers and integrate into failure reporting</name>
  <files>crates/driver/src/diagnostics.rs</files>
  <action>
Follow the exact pattern used for termination diagnostics in Phase 6 (format_missing_decreases_help, format_termination_counterexample).

1. Add `format_closure_contract_help(vc: &VerificationCondition) -> String`:
   - Returns a help message explaining what a closure contract failure means
   - Example output: "Closure contract violation: the closure's behavior at the call site does not satisfy the specified contract. Check that the closure's ensures clause holds for all valid inputs satisfying the requires clause."

2. Add `format_fnonce_double_call_help(closure_name: &str) -> String`:
   - Returns: "FnOnce closure '{closure_name}' is called more than once. FnOnce closures consume their environment and can only be called once. Consider using Fn or FnMut if multiple calls are needed."

3. In the existing `report_text_only()` function (or equivalent diagnostic reporting function), add a match arm for `VcKind::ClosureContract`:
   - Display the VC description (already includes specifics)
   - If description contains "FnOnce" and "called more than once", append fnonce_double_call_help
   - Otherwise append closure_contract_help

4. Add tests:
   - `test_format_closure_contract_help`: Verify output contains "Closure contract violation"
   - `test_format_fnonce_double_call_help`: Verify output contains "FnOnce" and "called more than once"
   - `test_report_closure_contract_vc`: Build a mock VC with VcKind::ClosureContract, verify report_text_only handles it without panic
  </action>
  <verify>`cargo test -p rust-fv-driver -- closure` passes all new tests. `cargo test -p rust-fv-driver` passes all tests. `cargo clippy --workspace -- -D warnings` produces 0 warnings.</verify>
  <done>Closure diagnostic helpers exist and are integrated into report_text_only(). VcKind::ClosureContract is handled in all diagnostic code paths.</done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end closure verification tests via Z3</name>
  <files>crates/analysis/tests/closure_verification.rs</files>
  <action>
Create `crates/analysis/tests/closure_verification.rs` following the exact pattern of `recursion_verification.rs` (Phase 6 Plan 03):
- Import rust_fv_analysis and rust_fv_smtlib
- Create helper functions for IR construction and SMT-LIB formatting
- Each test: build IR Function -> generate_vcs() -> render to SMT-LIB -> submit to Z3 -> assert SAT/UNSAT

**Test suite (8+ tests covering all 5 success criteria):**

**Success Criterion 1: Fn closure with immutable captures**

1. `e2e_fn_closure_immutable_captures_verified`:
   Build IR for a function `apply_add` that accepts an `Fn(i32) -> i32` closure with immutable captures `x=5, y=10`. The closure computes `x + y + z` where `z` is the parameter. Call closure with `z=3`, verify `result == 18`. The postcondition VC should be UNSAT (verified correct).

2. `e2e_fn_closure_wrong_postcondition_rejected`:
   Same as above but postcondition claims `result == 20` (wrong). VC should be SAT (correctly rejected).

**Success Criterion 2: FnMut closure with mutable captures**

3. `e2e_fnmut_closure_mutable_capture_verified`:
   Build IR for a function with FnMut closure that increments a captured counter. Closure called twice. Postcondition: final capture value == initial + 2. Requires prophecy variables. VC should be UNSAT (verified).

4. `e2e_fnmut_closure_wrong_count_rejected`:
   Same as above but postcondition claims final value == initial + 3 (wrong). VC should be SAT (rejected).

**Success Criterion 3: FnOnce closure with move semantics**

5. `e2e_fnonce_closure_move_semantics_verified`:
   Build IR for a function accepting FnOnce closure that consumes its captured data. Single call. Postcondition verified. VC should be UNSAT.

6. `e2e_fnonce_double_call_diagnostic`:
   Build IR where FnOnce closure is called twice. Verify a VcKind::ClosureContract diagnostic VC is produced (always SAT, indicating error).

**Success Criterion 4: Closure contract specification**

7. `e2e_closure_contract_specification_verified`:
   Build IR for function:
   ```
   #[requires(forall(|x: i32| x > 0 ==> predicate(x) == true))]
   #[ensures(result > 0)]
   fn find_positive<F: Fn(i32) -> bool>(predicate: F, start: i32) -> i32
   ```
   The closure contract (all positive inputs return true) is assumed, and the postcondition (result > 0) is verified given the contract. VC should be UNSAT.

**Success Criterion 5: Closure contract violation diagnostic**

8. `e2e_closure_contract_violation_detected`:
   Build IR for function with closure parameter but the postcondition cannot be proven from the closure contract (e.g., closure contract says nothing about negative inputs, but postcondition requires property for all inputs). VC should be SAT, with VcKind::ClosureContract or Postcondition indicating the violation.

**Additional edge case tests:**

9. `e2e_closure_no_captures_verified`:
   Closure with empty environment (no captures, like `|x| x + 1`). Should still work with empty datatype.

10. `e2e_fn_closure_multiple_params_verified`:
   Closure taking 2 parameters, verifying correct encoding of multi-param closures.

Each test should:
- Construct IR Function programmatically (no MIR parsing needed)
- Call `generate_vcs(func, contract_db)` (with appropriate ContractDatabase if inter-procedural)
- For each VC: render Script to string, invoke Z3 via `std::process::Command`, check "sat"/"unsat" output
- Use `#[ignore]` attribute if Z3 not available (check with `which z3`)
- Follow naming convention: `e2e_` prefix

Helper functions to create:
- `build_fn_closure_info(name, env_fields, params, return_ty) -> ClosureInfo`
- `build_function_with_closure(name, closure_info, body_blocks, contracts) -> Function`
- `run_z3(script: &str) -> String` (reuse pattern from recursion_verification.rs)
- `format_smtlib(script: &Script) -> String` (reuse pattern from recursion_verification.rs)
  </action>
  <verify>`cargo test -p rust-fv-analysis --test closure_verification` passes all tests (or `#[ignore]` tests skipped if Z3 not installed). `cargo test --workspace` passes all tests. `cargo clippy --workspace -- -D warnings` produces 0 warnings. `cargo fmt --all -- --check` passes.</verify>
  <done>closure_verification.rs exists with 8+ e2e tests covering all 5 Phase 7 success criteria. All tests pass via Z3. All existing 1,788+ tests still pass. 0 warnings, 0 formatting issues.</done>
</task>

<task type="auto">
  <name>Task 3: Final workspace validation and phase completion check</name>
  <files></files>
  <action>
Run full workspace validation to confirm Phase 7 completion:

1. `cargo test --workspace` -- ALL tests pass (target: 1,788 + ~40-60 new = ~1,830-1,850 total)
2. `cargo clippy --workspace -- -D warnings` -- 0 warnings
3. `cargo fmt --all -- --check` -- no formatting issues
4. Verify each Phase 7 success criterion is met:
   - SC1: e2e_fn_closure_immutable_captures_verified passes (UNSAT)
   - SC2: e2e_fnmut_closure_mutable_capture_verified passes (UNSAT)
   - SC3: e2e_fnonce_closure_move_semantics_verified passes (UNSAT)
   - SC4: e2e_closure_contract_specification_verified passes (UNSAT)
   - SC5: e2e_closure_contract_violation_detected passes (SAT, violation detected)
5. Verify each requirement:
   - CLO-01: Closure environment encoded as SMT datatype (check encode_sort.rs Ty::Closure arm)
   - CLO-02: Closure call desugared to function call with environment (check defunctionalize.rs)
   - CLO-03: Fn closures verified with contract at call site (check vcgen.rs)
   - CLO-04: FnMut closures verified with prophecy variables (check vcgen.rs + encode_prophecy.rs)
   - CLO-05: FnOnce closures verified with single-call enforcement (check closure_analysis.rs)
   - CLO-06: Closure contracts specifiable via requires/ensures (check spec_parser.rs)
6. Count new tests and report total

If any validation fails, fix the issue before completing.
  </action>
  <verify>`cargo test --workspace` passes all tests. `cargo clippy --workspace -- -D warnings` produces 0 warnings. `cargo fmt --all -- --check` passes. All 5 success criteria validated.</verify>
  <done>Phase 7 COMPLETE. All success criteria met. All requirements (CLO-01 through CLO-06) satisfied. Full workspace builds, tests, lints, and formats cleanly.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. `cargo clippy --workspace -- -D warnings` -- 0 warnings
3. `cargo fmt --all -- --check` -- 0 issues
4. All 5 Phase 7 success criteria validated via Z3 e2e tests:
   - Fn closure with immutable captures (UNSAT)
   - FnMut closure with mutable captures and prophecy (UNSAT)
   - FnOnce closure with move semantics (UNSAT)
   - Closure contract specification via requires/ensures (UNSAT)
   - Closure contract violation diagnostic (SAT)
5. All 6 CLO requirements satisfied
6. Closure diagnostics integrated into driver reporting
</verification>

<success_criteria>
- closure_verification.rs exists with 8+ e2e tests
- All e2e tests pass via Z3
- Closure diagnostics integrated into driver
- All 5 success criteria from ROADMAP validated
- All 6 CLO requirements (CLO-01 through CLO-06) satisfied
- Total test count: 1,830+ (1,788 existing + ~40-60 new)
- 0 clippy warnings, 0 formatting issues
- Phase 7 is COMPLETE
</success_criteria>

<output>
After completion, create `.planning/phases/07-closures/07-03-SUMMARY.md`
</output>

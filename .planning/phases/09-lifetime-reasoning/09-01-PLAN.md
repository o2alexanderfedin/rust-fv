---
phase: 09-lifetime-reasoning
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/lifetime_analysis.rs
  - crates/analysis/src/encode_prophecy.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "LifetimeParam IR type represents named lifetime parameters ('a, 'b, 'static)"
    - "BorrowInfo IR type tracks borrow origin, region, mutability, and deref level"
    - "ReborrowChain IR type tracks original-to-reborrow relationships"
    - "Lifetime analysis extracts outlives constraints from function signatures"
    - "Nested mutable borrows (&mut &mut T) get layer-by-layer prophecy variables"
    - "VcKind::BorrowValidity enables borrow-specific verification diagnostics"
    - "Sort::Uninterpreted('Region') used for lifetime regions in SMT encoding"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "LifetimeParam, BorrowInfo, ReborrowChain, OutlivesConstraint types"
      contains: "LifetimeParam"
    - path: "crates/analysis/src/lifetime_analysis.rs"
      provides: "Lifetime extraction, outlives resolution, NLL live range tracking"
      exports: ["LifetimeContext", "extract_lifetime_params", "resolve_outlives", "compute_live_ranges"]
    - path: "crates/analysis/src/encode_prophecy.rs"
      provides: "Nested mutable borrow prophecy generation (layer-by-layer)"
      contains: "detect_nested_prophecies"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::BorrowValidity variant"
      contains: "BorrowValidity"
  key_links:
    - from: "crates/analysis/src/lifetime_analysis.rs"
      to: "crates/analysis/src/ir.rs"
      via: "LifetimeParam, BorrowInfo, OutlivesConstraint types"
      pattern: "use crate::ir::"
    - from: "crates/analysis/src/encode_prophecy.rs"
      to: "crates/analysis/src/ir.rs"
      via: "ProphecyInfo with deref_level for nested borrows"
      pattern: "ProphecyInfo"
    - from: "crates/analysis/src/encode_sort.rs"
      to: "Sort::Uninterpreted"
      via: "Region sort for lifetime encoding"
      pattern: "Sort::Uninterpreted"
---

<objective>
Add lifetime IR types (LifetimeParam, BorrowInfo, ReborrowChain, OutlivesConstraint), create
lifetime_analysis.rs module for extracting and resolving lifetime information, extend
encode_prophecy.rs for nested mutable borrow layer-by-layer prophecy variables, and add
VcKind::BorrowValidity to the verification pipeline.

Purpose: Establish the foundational data structures and analysis functions that Plans 02 and 03
will use for borrow conflict VCs, borrow validity verification, and end-to-end lifetime reasoning.

Output: New lifetime_analysis.rs module, extended IR with lifetime types, extended prophecy
encoding for nested borrows, VcKind::BorrowValidity, Region sort in SMT encoding.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-lifetime-reasoning/09-RESEARCH.md
@crates/analysis/src/ir.rs
@crates/analysis/src/encode_prophecy.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/lib.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lifetime IR types and VcKind::BorrowValidity (TDD)</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/encode_sort.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In ir.rs, add the following types (place after TraitImpl and before ClosureInfo):

    1. LifetimeParam struct:
       - name: String (lifetime name, e.g., "'a", "'b", "'static")
       - is_static: bool (true if this is the 'static lifetime)
       Derive: Debug, Clone, PartialEq, Eq, Hash

    2. OutlivesConstraint struct:
       - longer: String (the lifetime that must outlive, e.g., "'a")
       - shorter: String (the lifetime that is outlived, e.g., "'b")
       This represents 'a: 'b (a outlives b).
       Derive: Debug, Clone, PartialEq, Eq

    3. BorrowInfo struct:
       - local_name: String (the local variable holding the borrow, e.g., "_1")
       - region: String (the lifetime/region associated with this borrow, e.g., "'a")
       - is_mutable: bool (true for &mut, false for &)
       - deref_level: u32 (0 for direct borrow, 1 for reborrow of &mut, etc.)
       - source_local: Option<String> (if this is a reborrow, the original borrow local name)
       Derive: Debug, Clone, PartialEq, Eq

    4. ReborrowChain struct:
       - original: String (original borrow local name)
       - reborrows: Vec<String> (chain of reborrow local names in order)
       Derive: Debug, Clone, PartialEq, Eq

    5. Extend Function struct with new fields (after prophecies field):
       - lifetime_params: Vec<LifetimeParam> (default: empty vec)
       - outlives_constraints: Vec<OutlivesConstraint> (default: empty vec)
       - borrow_info: Vec<BorrowInfo> (default: empty vec)
       - reborrow_chains: Vec<ReborrowChain> (default: empty vec)
       IMPORTANT: Update ALL existing Function construction sites in tests and production code
       to include these new fields with default empty vecs. Search for "prophecies:" across the
       workspace and add the four new fields after each occurrence.

    In vcgen.rs:
    - Add VcKind::BorrowValidity variant to the VcKind enum (after BehavioralSubtyping).
      This represents borrow validity VCs: shared/mutable conflict, use-after-expiry, reborrow validity.

    In encode_sort.rs:
    - Add a helper constant or function for the Region sort:
      pub fn region_sort() -> Sort { Sort::Uninterpreted("Region".to_string()) }
    - This will be used by lifetime encoding for SMT region variables.
    - Do NOT add a Ty variant for regions (regions are not Rust types, they are verification metadata).

    In driver callbacks.rs:
    - Add VcKind::BorrowValidity to vc_kind_to_string(): return "borrow_validity".

    In driver diagnostics.rs:
    - Add VcKind::BorrowValidity to vc_kind_description(): return "borrow validity violation".
    - Add VcKind::BorrowValidity to suggest_fix(): return suggestion about checking borrow
      lifetimes, avoiding overlapping shared/mutable borrows, and ensuring borrows don't outlive
      their source.
    - Add VcKind::BorrowValidity handling in report_text_only() (after BehavioralSubtyping block):
      print borrow validity help message explaining the borrow lifecycle.
    - Add VcKind::BorrowValidity to report_with_ariadne() severity handling (Error severity).
    - Add VcKind::BorrowValidity to ALL test arrays that exercise all VcKind variants
      (search for "VcKind::BehavioralSubtyping" in test arrays and add BorrowValidity after each).

    Tests to write FIRST (RED phase):
    - test_lifetime_param_creation: Create LifetimeParam for 'a, verify fields
    - test_lifetime_param_static: Create LifetimeParam for 'static, verify is_static=true
    - test_outlives_constraint: Create OutlivesConstraint 'a: 'b, verify longer/shorter
    - test_borrow_info_shared: Create BorrowInfo for shared borrow, verify is_mutable=false
    - test_borrow_info_mutable: Create BorrowInfo for mutable borrow, verify is_mutable=true
    - test_borrow_info_reborrow: Create BorrowInfo with deref_level=1 and source_local
    - test_reborrow_chain: Create ReborrowChain with original and reborrows
    - test_function_lifetime_fields: Create Function with lifetime_params, verify accessible
    - test_region_sort: Verify region_sort() returns Sort::Uninterpreted("Region")
    - test_vc_kind_borrow_validity_description: Verify diagnostic description string
    - test_vc_kind_borrow_validity_to_string: Verify callback serialization string
    - test_vc_kind_borrow_validity_suggest_fix: Verify suggestion mentions borrows/lifetimes
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    All new IR types (LifetimeParam, OutlivesConstraint, BorrowInfo, ReborrowChain) exist with
    correct fields. Function struct extended with lifetime_params, outlives_constraints,
    borrow_info, reborrow_chains. VcKind::BorrowValidity added and handled in all driver match
    arms. region_sort() helper exists in encode_sort. All existing tests still pass (0 regressions).
    All new tests pass. 0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lifetime_analysis module and extend encode_prophecy for nested borrows (TDD)</name>
  <files>
    crates/analysis/src/lifetime_analysis.rs
    crates/analysis/src/encode_prophecy.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    Create crates/analysis/src/lifetime_analysis.rs with:

    1. LifetimeContext struct:
       - lifetimes: HashMap<String, LifetimeParam> (lifetime name -> param info)
       - outlives: Vec<OutlivesConstraint> (all outlives constraints)
       - borrow_map: HashMap<String, BorrowInfo> (local name -> borrow info)
       - reborrow_chains: Vec<ReborrowChain> (all reborrow chains)
       Methods:
       - new() -> Self
       - add_lifetime(&mut self, param: LifetimeParam)
       - add_outlives(&mut self, constraint: OutlivesConstraint)
       - register_borrow(&mut self, info: BorrowInfo)
       - get_borrow(&self, local_name: &str) -> Option<&BorrowInfo>
       - get_lifetime(&self, name: &str) -> Option<&LifetimeParam>
       - outlives_constraints(&self) -> &[OutlivesConstraint]
       - borrows_in_region(&self, region: &str) -> Vec<&BorrowInfo> (all borrows associated with a region)
       - mutable_borrows(&self) -> Vec<&BorrowInfo> (filter for is_mutable=true)
       - shared_borrows(&self) -> Vec<&BorrowInfo> (filter for is_mutable=false)

    2. extract_lifetime_params(func: &Function) -> Vec<LifetimeParam>:
       - Returns the function's lifetime_params field (simple accessor for now).
       - In future this will extract from MIR/HIR; for now lifetime_params are populated by the driver.

    3. resolve_outlives(func: &Function) -> Vec<OutlivesConstraint>:
       - Returns the function's outlives_constraints field.
       - Applies transitive closure: if 'a: 'b and 'b: 'c, then add 'a: 'c.
       - Implementation: iterate until no new constraints are added (fixpoint).

    4. detect_reborrow_chains(func: &Function) -> Vec<ReborrowChain>:
       - Scans borrow_info for entries with source_local set.
       - Groups them into chains: if B.source_local = A, and C.source_local = B,
         then chain is {original: A, reborrows: [B, C]}.
       - Returns one ReborrowChain per chain root.

    5. build_lifetime_context(func: &Function) -> LifetimeContext:
       - Orchestrates: extract_lifetime_params + resolve_outlives + detect_reborrow_chains.
       - Registers all borrows from func.borrow_info.
       - Returns fully populated LifetimeContext.

    6. check_static_validity(borrow: &BorrowInfo, context: &LifetimeContext) -> bool:
       - Returns true if the borrow's region is 'static or outlives 'static.
       - Uses outlives_constraints to check transitively.

    7. compute_live_ranges(func: &Function) -> HashMap<String, Vec<usize>>:
       - For each BorrowInfo, compute the set of basic block indices where the borrow is live.
       - Simple heuristic: a borrow created at block B is live from B through all successors
         until a block where the local is not used.
       - For now, use a conservative approximation: borrow is live from creation block to
         the last block index that references the local in any statement/terminator.
       - This is a simplified model; the driver will provide precise MIR-based live ranges
         in future integration (per research: "extract rustc's results rather than reimplementing").

    Register module in lib.rs: pub mod lifetime_analysis;

    Extend crates/analysis/src/encode_prophecy.rs:

    1. Add deref_level field to ProphecyInfo struct:
       - deref_level: u32 (0 for direct &mut T, 1 for outer of &mut &mut T, etc.)
       - Update ALL existing ProphecyInfo construction sites to include deref_level: 0.

    2. Add detect_nested_prophecies(func: &Function) -> Vec<ProphecyInfo>:
       - For each mutable reference parameter, walk the type structure:
         - &mut T -> ProphecyInfo { deref_level: 0, inner_ty: T, ... }
         - &mut &mut T -> TWO ProphecyInfos:
           - { deref_level: 0, inner_ty: &mut T, prophecy_var: "{name}_prophecy", ... }
           - { deref_level: 1, inner_ty: T, prophecy_var: "{name}_deref_prophecy", ... }
         - &mut &mut &mut T -> THREE, etc.
       - Naming convention:
         - deref_level 0: {param}_initial, {param}_prophecy
         - deref_level 1: {param}_deref_initial, {param}_deref_prophecy
         - deref_level N: {param}_deref{N}_initial, {param}_deref{N}_prophecy
       - This replaces detect_prophecies for functions with nested mutable borrows.
         detect_prophecies still works for single-level &mut T (backward compatible).

    3. Add nested_prophecy_declarations(prophecies: &[ProphecyInfo]) -> Vec<Command>:
       - Same as prophecy_declarations but aware of deref_level for variable naming.
       - For deref_level > 0, the initial value constraint links to the parent prophecy's
         current state rather than the parameter directly.
       - Example for &mut &mut i32 param "_1":
         - Level 0: _1_initial = _1, _1_prophecy declared
         - Level 1: _1_deref_initial = *_1 (conceptually), _1_deref_prophecy declared
       - For now, all levels declare independent constants; the constraint linking is done
         in VCGen (Plan 02) where the actual borrow graph is available.

    Tests to write FIRST (RED phase):
    - test_lifetime_context_new: New context is empty
    - test_lifetime_context_add_lifetime: Add 'a, retrieve it
    - test_lifetime_context_add_outlives: Add 'a: 'b, retrieve it
    - test_lifetime_context_register_borrow: Register borrow, get it back
    - test_lifetime_context_borrows_in_region: Filter borrows by region
    - test_lifetime_context_mutable_borrows: Filter for mutable only
    - test_lifetime_context_shared_borrows: Filter for shared only
    - test_extract_lifetime_params: Function with lifetimes -> extract them
    - test_extract_lifetime_params_empty: Function without lifetimes -> empty
    - test_resolve_outlives_simple: 'a: 'b returns ['a: 'b]
    - test_resolve_outlives_transitive: 'a: 'b + 'b: 'c -> includes 'a: 'c
    - test_resolve_outlives_no_duplicates: Transitive closure doesn't duplicate existing
    - test_detect_reborrow_chains_none: No reborrows -> empty
    - test_detect_reborrow_chains_single: B reborrows A -> chain {A, [B]}
    - test_detect_reborrow_chains_deep: C reborrows B reborrows A -> chain {A, [B, C]}
    - test_build_lifetime_context: Full orchestration with lifetimes, borrows, chains
    - test_check_static_validity_is_static: Borrow in 'static region -> true
    - test_check_static_validity_outlives_static: Borrow in 'a where 'a: 'static -> true
    - test_check_static_validity_not_static: Borrow in 'a (no static constraint) -> false
    - test_compute_live_ranges_basic: Borrow created at block 0, used in block 2 -> live 0..2
    - test_detect_nested_prophecies_simple: &mut i32 -> 1 prophecy at level 0
    - test_detect_nested_prophecies_nested: &mut &mut i32 -> 2 prophecies (level 0, level 1)
    - test_detect_nested_prophecies_triple: &mut &mut &mut i32 -> 3 prophecies
    - test_detect_nested_prophecies_shared_no_prophecy: &i32 -> 0 prophecies
    - test_nested_prophecy_naming_level0: deref_level=0 -> {name}_prophecy
    - test_nested_prophecy_naming_level1: deref_level=1 -> {name}_deref_prophecy
    - test_nested_prophecy_declarations: Verify correct DeclareConst/Assert commands per level
    - test_prophecy_info_deref_level_default: Existing code produces deref_level=0
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    lifetime_analysis.rs module exists with LifetimeContext, extraction, resolution, reborrow
    detection, and live range computation. encode_prophecy.rs extended with ProphecyInfo.deref_level,
    detect_nested_prophecies, and nested_prophecy_declarations. Module registered in lib.rs.
    All ~28 new tests pass. All existing tests pass (0 regressions).
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- New IR types accessible from other modules
- VcKind::BorrowValidity handled in all match arms (no compiler warnings)
- LifetimeContext can be constructed from Function with lifetime metadata
- Nested prophecy encoding generates correct SMT commands per deref level
</verification>

<success_criteria>
1. LifetimeParam, OutlivesConstraint, BorrowInfo, ReborrowChain structs exist in ir.rs
2. Function struct extended with lifetime_params, outlives_constraints, borrow_info, reborrow_chains
3. VcKind::BorrowValidity exists and is handled in driver callbacks + diagnostics
4. lifetime_analysis.rs module exists with LifetimeContext and all analysis functions
5. Transitive outlives resolution works correctly
6. Reborrow chain detection groups borrows correctly
7. ProphecyInfo extended with deref_level for nested borrows
8. detect_nested_prophecies handles &mut &mut T with layer-by-layer prophecies
9. ~40 new tests passing, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-lifetime-reasoning/09-01-SUMMARY.md`
</output>

---
phase: 09-lifetime-reasoning
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - crates/analysis/tests/lifetime_verification.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Developer verifies function with lifetime parameters and compiler-inferred outlives constraints"
    - "Developer uses NLL pattern and verifier accepts (borrow ends at last use, not scope end)"
    - "Developer verifies borrow expiry using prophecy variables (final(*x))"
    - "Developer sees borrow validity VC failure when using value after lifetime expiry"
    - "Developer verifies reborrow chain (&mut &mut T) with correct lifetime tracking"
  artifacts:
    - path: "crates/analysis/tests/lifetime_verification.rs"
      provides: "End-to-end lifetime verification tests via Z3"
      min_lines: 400
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Borrow timeline diagnostics, fix suggestions, verbose lifetime explanations"
      contains: "format_borrow_timeline"
  key_links:
    - from: "crates/analysis/tests/lifetime_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "generate_vcs producing BorrowValidity VCs"
      pattern: "VcKind::BorrowValidity"
    - from: "crates/analysis/tests/lifetime_verification.rs"
      to: "crates/analysis/src/lifetime_analysis.rs"
      via: "build_lifetime_context for test setup"
      pattern: "lifetime_analysis::"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::BorrowValidity formatting"
      pattern: "BorrowValidity"
---

<objective>
Create comprehensive end-to-end lifetime verification tests via Z3 covering all 5 Phase 9
success criteria. Add detailed borrow lifetime diagnostics including source-level borrow
timeline, conflict explanation, and actionable fix suggestions. Validate the complete
lifetime reasoning pipeline from IR through VCs to Z3 solving.

Purpose: Prove the lifetime reasoning system works end-to-end and provides developer-friendly
diagnostics when borrow violations are detected. This is the integration and validation plan.

Output: lifetime_verification.rs test file with ~10 e2e tests, enhanced diagnostics with
borrow timeline formatting and fix suggestions.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-lifetime-reasoning/09-RESEARCH.md
@.planning/phases/09-lifetime-reasoning/09-01-SUMMARY.md
@.planning/phases/09-lifetime-reasoning/09-02-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/lifetime_analysis.rs
@crates/analysis/src/borrow_conflict.rs
@crates/analysis/src/encode_prophecy.rs
@crates/analysis/src/ir.rs
@crates/analysis/tests/trait_verification.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add borrow lifetime diagnostics with timeline and fix suggestions</name>
  <files>
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    In diagnostics.rs, add lifetime-specific diagnostic formatting:

    1. Add format_borrow_timeline(failure: &VerificationFailure) -> String:
       - Parse the failure description to extract borrow names, regions, and block indices.
       - Per user decision: "Source-level borrow timeline showing full lifecycle: creation,
         usage, expiry, and conflict point."
       - Generate a timeline string like:
         ```
         Borrow timeline:
           BB0: &mut x created (region 'a)
           BB1: &x created (region 'b) -- CONFLICT: overlaps with &mut x
           BB2: &mut x expires
           BB3: &x expires
         ```
       - For expiry violations:
         ```
         Borrow timeline:
           BB0: &mut x created (region 'a)
           BB2: &mut x expires
           BB3: x used -- ERROR: borrow expired at BB2
         ```
       - The timeline is constructed from the description string which contains block indices.
       - Keep it concise by default (per user decision: "Default to concise violation message").

    2. Add format_borrow_fix_suggestion(failure: &VerificationFailure) -> String:
       - Per user decision: "Include actionable fix suggestions."
       - For conflict violations: "Consider restructuring to avoid overlapping borrows.
         Move the shared borrow usage before the mutable borrow, or clone the value."
       - For expiry violations: "The borrow has expired. Consider moving this usage before
         line N where the borrow ends, or clone the value before borrowing."
       - For reborrow violations: "The reborrow outlives the original borrow. Ensure the
         reborrow is used and dropped before the original borrow expires."

    3. Add format_lifetime_explanation(failure: &VerificationFailure) -> String:
       - Per user decision: "--verbose or #[verifier::verbose] for full lifetime explanation chain."
       - Full explanation: "'a outlives 'b because ..."
       - This is the verbose mode; only shown when verbose flag is set.
       - For now, generate from the description and outlives info in the failure.

    4. Update report_text_only() BorrowValidity block:
       - Print the borrow timeline (always, as it's the concise format).
       - Print the fix suggestion (always).
       - The verbose explanation is controlled by a verbose flag (add verbose: bool parameter
         to a helper, or check for environment variable RUST_FV_VERBOSE).
       - For now, always print concise format; verbose will be added in driver integration later.

    5. Update report_with_ariadne() for BorrowValidity:
       - Use Error severity (per user decision: "prefer errors over warnings when ambiguous").
       - Include the borrow timeline in the diagnostic label.

    6. Add diagnostic helper tests:
       - test_format_borrow_timeline_conflict: Verify timeline format for conflict
       - test_format_borrow_timeline_expiry: Verify timeline format for expiry
       - test_format_borrow_fix_suggestion_conflict: Verify suggestion for conflicts
       - test_format_borrow_fix_suggestion_expiry: Verify suggestion for expiry
       - test_format_borrow_fix_suggestion_reborrow: Verify suggestion for reborrow
       - test_format_lifetime_explanation: Verify verbose explanation format
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Borrow timeline formatting exists and produces concise lifecycle visualization.
    Fix suggestions provide actionable guidance for conflict, expiry, and reborrow violations.
    Verbose lifetime explanation chain available. All 6 new diagnostic tests pass.
    All existing tests pass (0 regressions). 0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end lifetime verification tests via Z3</name>
  <files>
    crates/analysis/tests/lifetime_verification.rs
  </files>
  <action>
    Create crates/analysis/tests/lifetime_verification.rs following the established pattern
    from trait_verification.rs and closure_verification.rs.

    Test infrastructure (copy pattern from trait_verification.rs):
    - solver_or_skip() helper for Z3 availability
    - script_to_smtlib() for converting Script to SMT-LIB string
    - Z3Solver import from rust_fv_solver

    Test cases covering ALL 5 Phase 9 success criteria:

    SUCCESS CRITERION 1: "Developer verifies function with lifetime parameters and
    compiler-inferred outlives constraints"

    1. test_lifetime_params_outlives_verified:
       - Build IR Function with two lifetime params 'a, 'b and outlives constraint 'a: 'b.
       - Two parameters: x: &'a i32, y: &'b i32.
       - Populate borrow_info with shared borrows for both.
       - Call generate_vcs.
       - Verify: VCs are generated (even if no violations -- this proves the pipeline runs).
       - If no violations (borrows are shared, no conflicts), expect 0 BorrowValidity VCs.

    2. test_outlives_with_bound_t_outlives_a:
       - Build IR Function with lifetime param 'a and generic param T: 'a.
       - Add outlives constraint for T: 'a (encoded as type bound).
       - Call generate_vcs.
       - Verify: Pipeline processes without error. No BorrowValidity VCs for valid code.

    SUCCESS CRITERION 2: "Developer uses NLL pattern and verifier accepts"

    3. test_nll_borrow_ends_at_last_use:
       - Build IR Function simulating NLL: mutable borrow at BB0, last use at BB1, value
         reused at BB2 (after borrow ends).
       - borrow_info: &mut x live in blocks [0, 1] (NLL: ends at last use BB1, not scope end).
       - Another use of the underlying value at BB2 should NOT be flagged.
       - Call generate_vcs.
       - Verify: 0 BorrowValidity VCs (the NLL pattern is valid).

    4. test_nll_rejects_lexical_assumption:
       - Build IR Function where mutable borrow at BB0, shared borrow at BB1, mutable borrow
         still live at BB1 (overlapping lifetimes).
       - borrow_info: &mut x live in [0, 1, 2], &x live in [1, 2].
       - Call generate_vcs.
       - Verify: at least 1 BorrowValidity VC (conflict detected).
       - Submit to Z3: expect SAT (violation exists).

    SUCCESS CRITERION 3: "Developer verifies borrow expiry using prophecy variables"

    5. test_prophecy_final_star_x:
       - Build IR Function with &mut i32 param.
       - Set up prophecy via detect_nested_prophecies.
       - Generate VCs including prophecy declarations and resolutions.
       - Verify: prophecy_var "{param}_prophecy" appears in the SMT script.
       - Submit to Z3 if available: verify prophecy constraint is sound.

    6. test_prophecy_nested_mut_mut:
       - Build IR Function with &mut &mut i32 param.
       - Call detect_nested_prophecies.
       - Verify: 2 prophecies generated (level 0 and level 1).
       - Verify: {param}_prophecy and {param}_deref_prophecy both declared.
       - Generate VCs and verify both prophecy variables appear.

    SUCCESS CRITERION 4: "Developer sees borrow validity VC failure when using value after
    lifetime expiry"

    7. test_use_after_expiry_generates_vc:
       - Build IR Function with mutable borrow at BB0, expiring at BB1.
       - Add a statement in BB2 that references the expired borrow local.
       - borrow_info: &mut x live in [0, 1] only.
       - Call generate_vcs.
       - Verify: at least 1 BorrowValidity VC with description mentioning "expiry" or "expired".
       - Submit to Z3: expect SAT (violation detected).

    8. test_use_within_lifetime_no_vc:
       - Build IR Function with mutable borrow at BB0, used at BB1, both within live range.
       - borrow_info: &mut x live in [0, 1, 2].
       - Call generate_vcs.
       - Verify: 0 BorrowValidity VCs of expiry type.

    SUCCESS CRITERION 5: "Developer verifies reborrow chain with correct lifetime tracking"

    9. test_reborrow_chain_valid:
       - Build IR Function with &mut &mut i32 pattern.
       - borrow_info: original &mut x live in [0, 1, 2, 3], reborrow y = &mut *x live in [1, 2].
       - reborrow_chains: [{original: x, reborrows: [y]}].
       - Reborrow y's range [1,2] is subset of x's range [0,1,2,3] -> valid.
       - Call generate_vcs.
       - Verify: 0 BorrowValidity VCs for the reborrow (it's valid).

    10. test_reborrow_chain_outlives_original:
        - Build IR Function with reborrow that outlives its original.
        - borrow_info: original &mut x live in [0, 1], reborrow y live in [0, 1, 2].
        - Reborrow y's range [0,1,2] is NOT subset of x's range [0,1] -> violation.
        - Call generate_vcs.
        - Verify: at least 1 BorrowValidity VC mentioning "reborrow" or "outlives".
        - Submit to Z3: expect SAT (violation detected).

    VALIDATION: After all tests pass, verify overall phase requirements:

    11. test_phase9_requirement_coverage:
        - Verify that VcKind::BorrowValidity exists.
        - Verify that lifetime_analysis module is accessible.
        - Verify that borrow_conflict module is accessible.
        - Verify that ProphecyInfo has deref_level field.
        - This is a structural assertion test that all Phase 9 components are integrated.

    Each test should follow the established pattern:
    - Build IR Function with explicit lifetime metadata (lifetime_params, borrow_info, etc.)
    - Call generate_vcs (or specific analysis functions)
    - Assert on VC count, VcKind, and descriptions
    - Where applicable, submit to Z3 and verify SAT/UNSAT result
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo test -p rust-fv-analysis --test lifetime_verification 2>&1 | tail -20
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    lifetime_verification.rs exists with 11 end-to-end tests covering all 5 Phase 9 success
    criteria. Tests verify VC generation pipeline, BorrowValidity VC production, prophecy variable
    encoding, NLL acceptance, expiry detection, and reborrow chain validation.
    All 11 tests pass. All existing workspace tests pass (0 regressions).
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Phase 9 success criteria and update state</name>
  <files></files>
  <action>
    Run full workspace validation:

    1. Run cargo test --workspace and verify all tests pass.
    2. Run cargo clippy --workspace -- -D warnings and verify 0 warnings.
    3. Run cargo fmt --all -- --check and verify 0 formatting issues.
    4. Count total workspace tests and compare with previous (1,919 from Phase 8).
    5. Run the lifetime_verification test suite specifically:
       cargo test -p rust-fv-analysis --test lifetime_verification -- --nocapture

    Validate each Phase 9 success criterion:

    SC1: "Developer verifies function with lifetime parameters and compiler-inferred outlives
    constraints" -> Proven by test_lifetime_params_outlives_verified and
    test_outlives_with_bound_t_outlives_a.

    SC2: "Developer uses NLL pattern and verifier accepts" -> Proven by
    test_nll_borrow_ends_at_last_use (accepts valid NLL) and
    test_nll_rejects_lexical_assumption (rejects invalid overlaps).

    SC3: "Developer verifies borrow expiry using prophecy variables" -> Proven by
    test_prophecy_final_star_x and test_prophecy_nested_mut_mut.

    SC4: "Developer sees borrow validity VC failure when using value after lifetime expiry"
    -> Proven by test_use_after_expiry_generates_vc (SAT = violation detected) and
    test_use_within_lifetime_no_vc (no false positives).

    SC5: "Developer verifies reborrow chain with correct lifetime tracking" -> Proven by
    test_reborrow_chain_valid (accepts valid) and test_reborrow_chain_outlives_original
    (rejects invalid).

    Validate requirements:
    - LIF-01: Lifetime parameters tracked (LifetimeParam, extract_lifetime_params) -> DONE
    - LIF-02: Borrow expiry verification using prophecy variables (detect_nested_prophecies) -> DONE
    - LIF-03: Lifetime bounds checked (OutlivesConstraint, resolve_outlives) -> DONE
    - LIF-04: NLL-based lifetime tracking (compute_live_ranges, last-use semantics) -> DONE
    - LIF-05: SSA-based parameter encoding (ProphecyInfo.deref_level) -> DONE
    - LIF-06: Reborrow chains tracked (ReborrowChain, detect_reborrow_chains) -> DONE
    - INF-02: VcKind::BorrowValidity added -> DONE

    Report total test count, new tests added, and any issues.
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -10
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    All 5 Phase 9 success criteria validated by end-to-end tests. All 7 requirements satisfied
    (LIF-01 through LIF-06 + INF-02). Full workspace passes: all tests green, 0 clippy warnings,
    0 formatting issues. Test count increased from previous phase.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- All 5 Phase 9 success criteria validated by specific tests
- All 7 requirements (LIF-01 through LIF-06, INF-02) satisfied
- Diagnostics provide borrow timeline, fix suggestions, and verbose explanation
- End-to-end tests submit to Z3 where available and verify SAT/UNSAT results
</verification>

<success_criteria>
1. lifetime_verification.rs exists with 11 end-to-end tests
2. All 5 success criteria have at least 2 tests each (positive + negative case)
3. Borrow timeline diagnostics produce readable lifecycle visualization
4. Fix suggestions provide actionable guidance for each violation type
5. All workspace tests pass with 0 warnings and 0 formatting issues
6. Phase 9 complete: all requirements satisfied, all success criteria validated
</success_criteria>

<output>
After completion, create `.planning/phases/09-lifetime-reasoning/09-03-SUMMARY.md`
</output>

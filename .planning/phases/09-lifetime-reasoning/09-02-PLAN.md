---
phase: 09-lifetime-reasoning
plan: 02
type: tdd
wave: 2
depends_on: ["09-01"]
files_modified:
  - crates/analysis/src/borrow_conflict.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
  - crates/macros/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Borrow conflict detection identifies overlapping shared/mutable borrows"
    - "VCGen generates BorrowValidity VCs for functions with lifetime parameters"
    - "Borrow expiry VCs catch use-after-lifetime-end violations"
    - "Reborrow validity VCs ensure reborrow chains have correct lifetime nesting"
    - "final(*x) in specs resolves to outer prophecy for nested borrows"
    - "final(**x) in specs resolves to inner prophecy for &mut &mut T"
    - "#[borrow_ensures(x, expr)] attribute specifies mutable borrow final value"
  artifacts:
    - path: "crates/analysis/src/borrow_conflict.rs"
      provides: "Borrow conflict detection, conflict VC generation, borrow expiry checking"
      exports: ["detect_borrow_conflicts", "generate_conflict_vcs", "generate_expiry_vcs", "generate_reborrow_vcs"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "BorrowValidity VC integration in generate_vcs pipeline"
      contains: "generate_borrow_validity_vcs"
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "final(*x) and final(**x) nested borrow prophecy resolution"
      contains: "convert_nested_final"
    - path: "crates/macros/src/lib.rs"
      provides: "#[borrow_ensures] proc macro"
      contains: "borrow_ensures"
  key_links:
    - from: "crates/analysis/src/borrow_conflict.rs"
      to: "crates/analysis/src/lifetime_analysis.rs"
      via: "LifetimeContext for borrow/region queries"
      pattern: "use crate::lifetime_analysis::"
    - from: "crates/analysis/src/borrow_conflict.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VerificationCondition and VcKind::BorrowValidity"
      pattern: "VcKind::BorrowValidity"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/borrow_conflict.rs"
      via: "Calls generate_conflict_vcs/generate_expiry_vcs in VC pipeline"
      pattern: "borrow_conflict::"
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/analysis/src/ir.rs"
      via: "ProphecyInfo.deref_level for nested final resolution"
      pattern: "deref_level"
---

<objective>
Create borrow_conflict.rs module for detecting and generating VCs for shared/mutable borrow
conflicts and borrow expiry violations. Integrate borrow validity VCs into the VCGen pipeline.
Extend spec parser to support final(*x)/final(**x) for nested mutable borrows. Add
#[borrow_ensures] proc macro for specifying mutable borrow final values.

Purpose: Implement the core verification logic that transforms lifetime analysis results into
actionable VCs. This is the heart of lifetime reasoning -- producing BorrowValidity VCs that
catch real borrow violations.

Output: New borrow_conflict.rs module, VCGen integration generating BorrowValidity VCs,
spec parser nested final support, #[borrow_ensures] macro.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-lifetime-reasoning/09-RESEARCH.md
@.planning/phases/09-lifetime-reasoning/09-01-SUMMARY.md
@crates/analysis/src/borrow_conflict.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/lifetime_analysis.rs
@crates/analysis/src/encode_prophecy.rs
@crates/analysis/src/ir.rs
@crates/macros/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create borrow_conflict module and integrate into VCGen (TDD)</name>
  <files>
    crates/analysis/src/borrow_conflict.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    Create crates/analysis/src/borrow_conflict.rs with:

    1. BorrowConflict struct:
       - shared_borrow: String (local name of the shared borrow)
       - mutable_borrow: String (local name of the mutable borrow)
       - shared_region: String (lifetime region of shared borrow)
       - mutable_region: String (lifetime region of mutable borrow)
       - overlapping_blocks: Vec<usize> (basic block indices where both are live)
       Derive: Debug, Clone, PartialEq, Eq

    2. BorrowExpiry struct:
       - borrow_local: String (the expired borrow)
       - region: String (its lifetime region)
       - use_block: usize (basic block where expired borrow is used)
       - expiry_block: usize (basic block where borrow expires)
       Derive: Debug, Clone, PartialEq, Eq

    3. detect_borrow_conflicts(context: &LifetimeContext, live_ranges: &HashMap<String, Vec<usize>>) -> Vec<BorrowConflict>:
       - For each pair of (shared_borrow, mutable_borrow) from the context:
         - Get their live ranges from live_ranges map.
         - Compute intersection of live blocks.
         - If intersection is non-empty, create a BorrowConflict with overlapping_blocks.
       - Returns all conflicts found.
       - Per user decision: "Generate explicit conflict VCs when shared (&T) and mutable (&mut T)
         borrows have overlapping lifetimes."

    4. generate_conflict_vcs(conflicts: &[BorrowConflict], function_name: &str) -> Vec<VerificationCondition>:
       - For each BorrowConflict, generate a BorrowValidity VC that is SAT (= violation found).
       - The VC encodes: NOT(shared_live_at_bb AND mutable_live_at_bb).
       - Use SMT encoding: declare Bool constants for liveness, assert they are true (both live),
         assert NOT(both can be live) -- this produces UNSAT if no conflict (correct) or SAT if conflict.
       - Actually, for our pipeline where UNSAT = verified and SAT = violation:
         Generate a script where the negated conflict is checked:
         (assert (not (=> (and shared_live mutable_live) false)))
         Which simplifies to: (assert (and shared_live mutable_live))
         Then check-sat: SAT means conflict exists (violation).
       - VcKind: BorrowValidity
       - Description: "Shared borrow {shared} and mutable borrow {mutable} cannot overlap at BB{block}"

    5. generate_expiry_vcs(context: &LifetimeContext, live_ranges: &HashMap<String, Vec<usize>>, function: &Function) -> Vec<VerificationCondition>:
       - For each borrow in the context, check if any basic block uses the borrow local after
         its live range ends.
       - Scan function basic_blocks for references to the borrow local. If a reference occurs
         at a block index NOT in the borrow's live range, generate a BorrowValidity VC.
       - Description: "Borrow {local} used at BB{use_block} after expiry at BB{expiry_block}"
       - VcKind: BorrowValidity
       - This implements success criterion 4: "Developer sees borrow validity VC failure when
         attempting to use value after lifetime expiry."

    6. generate_reborrow_vcs(context: &LifetimeContext, live_ranges: &HashMap<String, Vec<usize>>) -> Vec<VerificationCondition>:
       - For each reborrow chain, verify that the reborrow's lifetime does not exceed the
         original borrow's lifetime.
       - For each chain {original, reborrows: [B, C, ...]}, check:
         - B's live range must be a subset of original's live range
         - C's live range must be a subset of B's live range
         - If any violation found, generate BorrowValidity VC.
       - Description: "Reborrow {reborrow} outlives original borrow {original}"
       - VcKind: BorrowValidity

    Register module in lib.rs: pub mod borrow_conflict;

    In vcgen.rs, integrate borrow validity VCs into the generate_vcs pipeline:

    1. Add a new section after the trait/behavioral subtyping section (search for
       "behavioral_subtyping" or the last analysis section) in generate_vcs():

       // --- Borrow validity analysis ---
       let lifetime_ctx = lifetime_analysis::build_lifetime_context(func);
       let live_ranges = lifetime_analysis::compute_live_ranges(func);

       // Generate conflict VCs
       let conflicts = borrow_conflict::detect_borrow_conflicts(&lifetime_ctx, &live_ranges);
       let conflict_vcs = borrow_conflict::generate_conflict_vcs(&conflicts, &func.name);

       // Generate expiry VCs
       let expiry_vcs = borrow_conflict::generate_expiry_vcs(&lifetime_ctx, &live_ranges, func);

       // Generate reborrow VCs
       let reborrow_vcs = borrow_conflict::generate_reborrow_vcs(&lifetime_ctx, &live_ranges);

       // Add all borrow validity VCs to the function's conditions
       conditions.extend(conflict_vcs);
       conditions.extend(expiry_vcs);
       conditions.extend(reborrow_vcs);

    2. Only run borrow validity analysis if the function has lifetime metadata:
       if !func.lifetime_params.is_empty() || !func.borrow_info.is_empty() { ... }
       This ensures backward compatibility -- existing functions without lifetime metadata
       are unaffected (per user decision: "Functions with lifetime parameters automatically
       get borrow validity VCs -- no opt-in needed").

    3. Import the new modules at the top of vcgen.rs:
       use crate::borrow_conflict;
       use crate::lifetime_analysis;

    Tests to write FIRST (RED phase):
    - test_detect_conflicts_none: No shared+mutable pairs -> empty
    - test_detect_conflicts_overlapping: Shared and mutable with overlapping blocks -> conflict
    - test_detect_conflicts_non_overlapping: Shared and mutable with disjoint blocks -> no conflict
    - test_detect_conflicts_multiple: Multiple shared/mutable pairs -> multiple conflicts
    - test_generate_conflict_vcs_empty: No conflicts -> no VCs
    - test_generate_conflict_vcs_produces_vc: One conflict -> one BorrowValidity VC
    - test_generate_conflict_vc_description: Verify description format
    - test_generate_expiry_vcs_no_expiry: Borrow used within live range -> no VC
    - test_generate_expiry_vcs_use_after_expiry: Borrow used after live range -> BorrowValidity VC
    - test_generate_reborrow_vcs_valid: Reborrow within original range -> no VC
    - test_generate_reborrow_vcs_outlives: Reborrow outlives original -> BorrowValidity VC
    - test_vcgen_borrow_validity_integration: Function with lifetime metadata produces BorrowValidity VCs
    - test_vcgen_no_lifetime_no_borrow_vcs: Function without lifetime metadata produces no BorrowValidity VCs
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    borrow_conflict.rs module exists with conflict detection, expiry checking, and reborrow
    validation. VCGen pipeline integrated: functions with lifetime metadata automatically receive
    BorrowValidity VCs. Functions without lifetime metadata are unaffected. All ~13 new tests pass.
    All existing tests pass (0 regressions). 0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend spec parser for nested final and add #[borrow_ensures] macro (TDD)</name>
  <files>
    crates/analysis/src/spec_parser.rs
    crates/macros/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In spec_parser.rs, extend the specification parser:

    1. Add support for final(*x) syntax (inline in #[ensures]):
       - Currently, final_value(x) resolves to {x}_prophecy (deref_level 0).
       - Add: final(*x) should also resolve to {x}_prophecy (deref_level 0).
       - This is parsed as a function call "final" with argument "*x" (a deref expression).
       - In the convert_call function, add handling for "final" callee name:
         - If argument is a Unary(Deref, path), extract the path and resolve as deref_level 0 prophecy.
         - If argument is a Unary(Deref, Unary(Deref, path)), extract and resolve as deref_level 1 prophecy.
         - General pattern: count the number of Deref layers to determine deref_level.
       - Naming: deref_level 0 -> {param}_prophecy, deref_level 1 -> {param}_deref_prophecy,
         deref_level N -> {param}_deref{N}_prophecy (matching Plan 01's naming convention).

    2. Add convert_nested_final helper function:
       fn convert_nested_final(
           expr: &Expr,
           func: &Function,
           bound_vars: &[(String, rust_fv_smtlib::sort::Sort)],
       ) -> Option<Term>
       - Counts the number of Deref wrappers around the innermost path expression.
       - deref_count = number of * operators.
       - Resolves the innermost path to a parameter name.
       - Checks that the parameter has a mutable reference type with sufficient nesting depth.
       - Returns Term::Const("{param}_prophecy") for deref_count=1,
         Term::Const("{param}_deref_prophecy") for deref_count=2,
         Term::Const("{param}_deref{N-1}_prophecy") for deref_count=N.
       - Returns None if parameter is not a sufficiently nested mutable reference.

    3. Update convert_call to route "final" callee to convert_nested_final:
       - In the match on callee_name, add:
         "final" => return convert_nested_final(&call_expr.args[0], func, bound_vars)
       - This means both final(*x) and final(**x) work as function call syntax.
       - Keep existing final_value(x) support for backward compatibility.

    4. Add support for #[borrow_ensures] attribute parsing:
       - In the driver (or here in spec_parser), parse "borrow_ensures" spec kind:
         The format is #[borrow_ensures(x, expr)] which encodes as
         doc attribute: rust_fv::borrow_ensures::x::expr
       - Add parse_borrow_ensures(spec: &str, func: &Function) -> Option<(String, Term)>:
         - Splits spec on first "::" to get (param_name, expr_string).
         - Parses expr_string as a spec expression.
         - Returns (param_name, term) where param_name is the mutable ref parameter and
           term is the postcondition about its final value.
       - This creates a prophecy resolution constraint: assert(param_prophecy == term).

    In macros/src/lib.rs:

    1. Add #[borrow_ensures(x, expr)] proc macro:
       - Per user decision: "New #[borrow_ensures(x, expr)] attribute on functions for specifying
         mutable borrow final values."
       - Parse as: first argument is the parameter name, second is the expression.
       - Encode as doc attribute: #[doc(hidden)] #[doc = "rust_fv::borrow_ensures::PARAM::EXPR"]
       - The parameter name and expression are separated by "::" in the encoded string.
       - Implementation: use existing spec_attribute pattern but with custom formatting:
         - Parse attr as two expressions separated by comma: (ident, expr)
         - Encode: format!("rust_fv::borrow_ensures::{}::{}", param, expr)
       - Export as #[borrow_ensures(x, expr)] public proc macro attribute.

    Tests to write FIRST (RED phase) for spec_parser:
    - test_final_star_x_single_deref: parse "final(*_1)" with &mut i32 param -> "_1_prophecy"
    - test_final_star_star_x_double_deref: parse "final(**_1)" with &mut &mut i32 param -> "_1_deref_prophecy"
    - test_final_triple_deref: parse "final(***_1)" with &mut &mut &mut i32 -> "_1_deref2_prophecy"
    - test_final_value_still_works: parse "final_value(_1)" still produces "_1_prophecy" (backward compat)
    - test_final_non_mut_ref_returns_none: parse "final(*_1)" with &i32 param -> None
    - test_final_insufficient_nesting: parse "final(**_1)" with &mut i32 (only 1 level) -> None
    - test_final_in_ensures_expr: parse "*_1 == final(*_1) + 1" full expression
    - test_final_nested_in_ensures: parse "final(**_1) == old(**_1) + 1" full expression
    - test_parse_borrow_ensures: parse "x::*x == old(*x) + 1" -> ("x", term)
    - test_parse_borrow_ensures_invalid: parse "::bad" -> None

    Tests to write FIRST (RED phase) for macros:
    - test_borrow_ensures_macro: #[borrow_ensures(x, *x == old(*x) + 1)] encodes correctly
    - test_borrow_ensures_doc_format: Verify doc attribute format "rust_fv::borrow_ensures::..."
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Spec parser supports final(*x), final(**x), final(***x) for nested mutable borrow prophecy
    resolution. final_value(x) still works (backward compatible). #[borrow_ensures(x, expr)]
    macro exists and encodes as doc attribute. parse_borrow_ensures parses the encoded format.
    All ~12 new tests pass. All existing tests pass (0 regressions).
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- Borrow conflict detection produces correct conflicts for overlapping lifetimes
- VCGen generates BorrowValidity VCs for functions with lifetime metadata
- final(*x) resolves to correct prophecy variable per nesting level
- #[borrow_ensures] macro encodes correctly and is parseable
- Functions without lifetime metadata are unaffected (backward compatibility)
</verification>

<success_criteria>
1. borrow_conflict.rs exists with conflict detection, expiry VCs, and reborrow validation
2. VCGen pipeline generates BorrowValidity VCs for lifetime-annotated functions
3. Borrow conflict VCs correctly identify overlapping shared/mutable borrow regions
4. Borrow expiry VCs detect use-after-lifetime-end violations
5. Reborrow VCs validate reborrow chain lifetime nesting
6. final(*x) resolves to deref_level 0 prophecy, final(**x) to level 1, etc.
7. #[borrow_ensures(x, expr)] proc macro exists and encodes as doc attribute
8. ~25 new tests passing, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-lifetime-reasoning/09-02-SUMMARY.md`
</output>

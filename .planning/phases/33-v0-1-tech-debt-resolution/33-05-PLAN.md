---
phase: 33-v0-1-tech-debt-resolution
plan: 05
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/tests/float_verification.rs
  - crates/analysis/src/float_verification.rs
  - .planning/phases/11-floating-point-verification/11-VERIFICATION.md
autonomous: true
requirements:
  - FLOAT-PLACEHOLDER-01
must_haves:
  truths:
    - "Float VCs contain real encoded SMT terms (encode_operand output) instead of Term::Const('lhs') and Term::Const('rhs') placeholder strings"
    - "All existing float_verification.rs tests continue to pass (0 regressions)"
    - "Phase 11 VERIFICATION.md upgraded from 'passed with notes' to 'passed'"
    - "v0.1 milestone audit tech_debt item for Phase 11 is closed"
  artifacts:
    - path: "crates/analysis/src/float_verification.rs"
      provides: "generate_float_vcs() with real operand encoding via encode_operand()"
      contains: "encode_operand"
    - path: "crates/analysis/tests/float_verification.rs"
      provides: "Tests that assert VC terms do NOT contain 'lhs'/'rhs' placeholder strings"
      contains: "test_float_vc_uses_real_operand_terms"
    - path: ".planning/phases/11-floating-point-verification/11-VERIFICATION.md"
      provides: "Updated status"
      contains: "status: passed"
  key_links:
    - from: "crates/analysis/src/float_verification.rs"
      to: "crates/analysis/src/encode_term.rs"
      via: "encode_operand() called with Rvalue::BinaryOp lhs/rhs operands"
      pattern: "encode_operand"
    - from: "crates/analysis/tests/float_verification.rs"
      to: "crates/analysis/src/float_verification.rs"
      via: "generate_float_vcs() called; VC script text inspected for real variable names"
      pattern: "generate_float_vcs"
---

<objective>
Replace the placeholder operand terms (`Term::Const("lhs")` and `Term::Const("rhs")`) in `float_verification.rs` line 122-124 with real encoded terms using the existing `encode_operand()` from `encode_term.rs`. Use TDD: write failing tests that expect real variable names in SMT output, then implement the fix.

Purpose: Close the Phase 11 tech debt item — the real IEEE 754 encoding infrastructure (`encode_operand`, `encode_fp_binop`) already exists in `encode_term.rs`; this plan wires it into `generate_float_vcs()`.

Output: Float VCs reference actual IR operand terms (`x`, `y`, `_0` etc.) instead of the literal strings "lhs" and "rhs". Phase 11 VERIFICATION.md upgraded to `passed`.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-floating-point-verification/11-VERIFICATION.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From crates/analysis/src/encode_term.rs:
```rust
// Line 15: already imported in float_verification.rs's sibling files
pub fn encode_operand(op: &Operand) -> Term {
    match op {
        Operand::Copy(place) | Operand::Move(place) => encode_place(place),
        Operand::Constant(c) => encode_constant(c),
    }
}

pub fn encode_fp_binop(op: BinOp, lhs: &Term, rhs: &Term) -> Term {
    // Returns Term::FpAdd/FpSub/FpMul/FpDiv with RNE rounding mode
}

pub fn encode_float_constant(value: f64, fty: FloatTy) -> Term {
    // Returns Term::FpLit for float literals
}
```

From crates/analysis/src/float_verification.rs (current placeholder at lines 120-124):
```rust
// CURRENT (to be replaced):
let result_term = Term::Const(place.local.clone());
let lhs_term = Term::Const("lhs".to_string());    // PLACEHOLDER
let rhs_term = Term::Const("rhs".to_string());    // PLACEHOLDER
let operands = vec![lhs_term, rhs_term];

// AFTER FIX (using encode_operand from encode_term.rs):
if let Rvalue::BinaryOp(_op, lhs_operand, rhs_operand) = rvalue {
    let result_term = Term::Const(place.local.clone());
    let lhs_term = encode_operand(lhs_operand);   // e.g. Term::Const("x")
    let rhs_term = encode_operand(rhs_operand);   // e.g. Term::Const("y")
    let operands = vec![lhs_term, rhs_term];
    // ... existing nan_propagation_vc / infinity_overflow_vc calls ...
}
```

From crates/analysis/ir.rs Operand enum:
```rust
pub enum Operand {
    Copy(Place),
    Move(Place),
    Constant(Constant),
}
```

Existing test helper in float_verification.rs (test file, line 44-83):
```rust
fn build_float_add_function(param_ty: FloatTy) -> Function {
    // params: [Local::new("x", ...), Local::new("y", ...)]
    // BinaryOp(BinOp::Add, Operand::Move(Place::local("x")), Operand::Move(Place::local("y")))
}
```
</interfaces>
</context>

<feature>
  <name>Float VC real operand encoding</name>
  <files>crates/analysis/tests/float_verification.rs
crates/analysis/src/float_verification.rs</files>
  <behavior>
    After the fix, generate_float_vcs() for a function with params x and y doing x + y must:
    - Emit NaN propagation VC whose SMT text does NOT contain the string "lhs" or "rhs"
    - Emit NaN propagation VC whose SMT text DOES contain "x" and "y" (the actual param names)
    - Emit Infinity overflow VC with the same property (no "lhs"/"rhs", yes "x"/"y")

    Concrete test cases:
    1. test_float_vc_uses_real_operand_terms (RED test):
       - Build float_add_function(F32), call generate_float_vcs()
       - Get the NaN VC script text via script_to_smtlib()
       - Assert: script text does NOT contain "\"lhs\"" or "\"rhs\""
       - Assert: script text DOES contain "x" or "y"
       This test will FAIL (RED) before the fix because current output contains "lhs"/"rhs".

    2. test_float_vc_mul_uses_real_operand_terms (RED test):
       - Build float_mul_function(F64), call generate_float_vcs()
       - Same assertions as above for both NaN and Infinity VCs

    3. test_float_vc_div_uses_real_operand_terms (RED test):
       - Build float_div_function(F32), call generate_float_vcs()
       - Same assertions

    After the fix, all RED tests become GREEN. All previously passing tests remain GREEN.
  </behavior>
  <implementation>
    TDD:
    RED — Add 3 failing tests. Run; confirm FAIL because "lhs"/"rhs" appear in current output.
    GREEN — In generate_float_vcs(), change the block that constructs lhs_term/rhs_term:
      - The pattern match `if let Rvalue::BinaryOp(op, _lhs, _rhs) = rvalue` already captures operands
      - Change `_lhs` to `lhs_op` and `_rhs` to `rhs_op` (remove the underscore suppressors)
      - Add `use crate::encode_term::encode_operand;` import at top of float_verification.rs
      - Replace `Term::Const("lhs".to_string())` with `encode_operand(lhs_op)`
      - Replace `Term::Const("rhs".to_string())` with `encode_operand(rhs_op)`
    REFACTOR — None expected. Change is minimal (3 lines replaced, 1 import added).
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED — Add 3 failing tests asserting real operand terms in SMT output</name>
  <files>crates/analysis/tests/float_verification.rs</files>
  <action>
    Step 1 — Read the test file to understand exact imports and existing test patterns:
    Check lines 1-50 for imports and existing test structure.

    Step 2 — Append 3 new test functions to float_verification.rs after the existing tests:

    ```rust
    // --- Phase 33 Plan 05: Real operand encoding tests ---
    // These tests are RED before the fix (current output contains "lhs"/"rhs" placeholder strings).

    #[test]
    fn test_float_vc_uses_real_operand_terms() {
        let func = build_float_add_function(FloatTy::F32);
        let vcs = rust_fv_analysis::float_verification::generate_float_vcs(&func);
        assert!(!vcs.is_empty(), "Expected at least 1 float VC");

        let nan_vc = &vcs[0];
        let smt = script_to_smtlib(&nan_vc.script);

        // These assertions fail BEFORE the fix (placeholder terms present):
        assert!(!smt.contains("\"lhs\""), "SMT should not contain placeholder 'lhs', got: {smt}");
        assert!(!smt.contains("\"rhs\""), "SMT should not contain placeholder 'rhs', got: {smt}");
        // After the fix, the actual param names x/y appear:
        assert!(smt.contains("x") || smt.contains("y"),
            "SMT should reference actual param names (x or y), got: {smt}");
    }

    #[test]
    fn test_float_vc_mul_uses_real_operand_terms() {
        let func = build_float_mul_function(FloatTy::F64);
        let vcs = rust_fv_analysis::float_verification::generate_float_vcs(&func);
        assert!(!vcs.is_empty(), "Expected at least 1 float VC for f64 mul");

        for vc in &vcs {
            let smt = script_to_smtlib(&vc.script);
            assert!(!smt.contains("\"lhs\""),
                "VC '{}' SMT should not contain placeholder 'lhs': {smt}", vc.description);
            assert!(!smt.contains("\"rhs\""),
                "VC '{}' SMT should not contain placeholder 'rhs': {smt}", vc.description);
        }
    }

    #[test]
    fn test_float_vc_div_uses_real_operand_terms() {
        let func = build_float_div_function(FloatTy::F32);
        let vcs = rust_fv_analysis::float_verification::generate_float_vcs(&func);
        assert_eq!(vcs.len(), 2, "Expected 2 VCs for f32 div (NaN + Infinity)");

        for vc in &vcs {
            let smt = script_to_smtlib(&vc.script);
            assert!(!smt.contains("\"lhs\""),
                "VC '{}' should use real terms not 'lhs': {smt}", vc.description);
            assert!(!smt.contains("\"rhs\""),
                "VC '{}' should use real terms not 'rhs': {smt}", vc.description);
        }
    }
    ```

    Note: `generate_float_vcs` may need to be made `pub` if it isn't already. Check the function visibility in float_verification.rs and add `pub` if needed.

    Step 3 — Run the tests to confirm RED state:
    ```bash
    cargo test -p rust-fv-analysis --test float_verification test_float_vc_uses_real_operand_terms -- --nocapture 2>&1 | tail -20
    ```
    The tests must FAIL at this point. If they pass, the implementation is already done and Task 2 can be skipped (just update VERIFICATION.md).
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test float_verification test_float_vc_uses_real_operand_terms 2>&1 | grep -E "FAILED|test result"</automated>
  </verify>
  <done>3 new test functions added to float_verification.rs. Tests compile. The 3 new tests FAIL (RED) because current output contains "lhs"/"rhs" placeholder strings.</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN — Replace placeholder terms with encode_operand() + update VERIFICATION.md</name>
  <files>crates/analysis/src/float_verification.rs
crates/analysis/tests/float_verification.rs
.planning/phases/11-floating-point-verification/11-VERIFICATION.md</files>
  <action>
    Step 1 — Read float_verification.rs lines 1-10 to check existing imports, and lines 100-145 to see the current placeholder code.

    Step 2 — Add the import for encode_operand at the top of float_verification.rs:
    ```rust
    // Add to existing use statements in crates/analysis/src/float_verification.rs:
    use crate::encode_term::encode_operand;
    ```

    Step 3 — In generate_float_vcs(), replace the placeholder block (lines 120-124).
    Current:
    ```rust
    if let Rvalue::BinaryOp(op, _lhs, _rhs) = rvalue {
        if !is_float_arithmetic(op) {
            continue;
        }
        // ...
        let result_term = Term::Const(place.local.clone());
        let lhs_term = Term::Const("lhs".to_string());    // PLACEHOLDER
        let rhs_term = Term::Const("rhs".to_string());    // PLACEHOLDER
        let operands = vec![lhs_term, rhs_term];
    ```
    Replace with:
    ```rust
    if let Rvalue::BinaryOp(op, lhs_op, rhs_op) = rvalue {
        if !is_float_arithmetic(op) {
            continue;
        }
        // ...
        let result_term = Term::Const(place.local.clone());
        let lhs_term = encode_operand(lhs_op);   // real encoding — no more "lhs" placeholder
        let rhs_term = encode_operand(rhs_op);   // real encoding — no more "rhs" placeholder
        let operands = vec![lhs_term, rhs_term];
    ```

    Step 4 — Run the full float_verification test suite to confirm all 3 new tests turn GREEN and no existing tests regressed:
    ```bash
    cargo test -p rust-fv-analysis --test float_verification 2>&1
    ```

    Step 5 — Run full workspace tests to confirm 0 regressions:
    ```bash
    cargo test --workspace 2>&1 | tail -5
    ```

    Step 6 — Run clippy + fmt:
    ```bash
    cargo clippy -p rust-fv-analysis 2>&1 | grep -E "^error|^warning"
    cargo fmt -p rust-fv-analysis -- --check
    ```

    Step 7 — Update 11-VERIFICATION.md:
    - Change `status: passed_with_notes` (or `passed with notes`) to `status: passed`
    - In the "Notes" or "Placeholder Terms" section, update to: "RESOLVED — placeholder terms replaced with encode_operand() calls in Phase 33 Plan 05. Float VCs now reference actual IR operand variable names."
    - Add a line: "Phase 11 tech debt item CLOSED — encode_operand() wired into generate_float_vcs(). 2026-02-27"
    - Do not change any other content.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis --test float_verification 2>&1 | grep "test result"</automated>
  </verify>
  <done>All float_verification.rs tests pass (3 new GREEN + all prior tests GREEN). grep for "lhs" or "rhs" in float_verification.rs src shows no more placeholder Term::Const("lhs") strings. 11-VERIFICATION.md status = passed.</done>
</task>

</tasks>

<verification>
```bash
# All float tests pass
cargo test -p rust-fv-analysis --test float_verification 2>&1 | grep "test result"
# No placeholder strings remain in the implementation
grep -n '"lhs"\|"rhs"' /Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/src/float_verification.rs
# encode_operand is now imported/used
grep -n "encode_operand" /Users/alexanderfedin/Projects/hapyy/rust-fv/crates/analysis/src/float_verification.rs
# VERIFICATION.md updated
grep "^status:" /Users/alexanderfedin/Projects/hapyy/rust-fv/.planning/phases/11-floating-point-verification/11-VERIFICATION.md
# No workspace regressions
cargo test --workspace 2>&1 | tail -3
```
</verification>

<success_criteria>
- 3 new tests in float_verification.rs pass GREEN (assert no "lhs"/"rhs" placeholder strings in SMT output)
- All existing float_verification.rs tests continue to pass (0 regressions)
- float_verification.rs source: no `Term::Const("lhs"` or `Term::Const("rhs"` strings remain
- encode_operand() imported and used for both lhs and rhs operands
- Full workspace test: 0 failures
- Phase 11 VERIFICATION.md status = `passed` (was `passed with notes`)
- cargo clippy: 0 new errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/33-v0-1-tech-debt-resolution/33-05-SUMMARY.md`
</output>

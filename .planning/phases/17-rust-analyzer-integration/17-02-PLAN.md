---
phase: 17-rust-analyzer-integration
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - vscode-extension/src/extension.ts
  - vscode-extension/src/raMode.ts
  - vscode-extension/src/config.ts
  - vscode-extension/package.json
autonomous: true
requirements: [IDE-04, IDE-05]

must_haves:
  truths:
    - "Extension detects rust-analyzer presence and configures check.overrideCommand automatically"
    - "rust-analyzer runs cargo verify --message-format=json on file save (flycheck integration)"
    - "Diagnostics from rust-analyzer have source 'rust-fv' and appear in Problems panel tagged distinctly"
    - "Standalone mode deactivates when RA mode is active (no duplicate squiggles)"
    - "User can disable rust-fv integration via rust-analyzer.rustfv.enable setting"
    - "Green gutter checkmarks update based on RA-mode diagnostics (not only standalone)"
    - "Missing cargo-verify shows status bar hint 'rust-fv: not installed'"
  artifacts:
    - path: "vscode-extension/src/raMode.ts"
      provides: "rust-analyzer mode detection, overrideCommand configuration, deduplication"
      min_lines: 80
    - path: "vscode-extension/src/config.ts"
      provides: "Extended config helpers for rust-analyzer.rustfv.* settings"
      contains: "rust-analyzer.rustfv"
    - path: "vscode-extension/package.json"
      provides: "Configuration contribution for rust-analyzer.rustfv.* settings"
      contains: "rust-analyzer.rustfv.enable"
    - path: "vscode-extension/src/extension.ts"
      provides: "RA mode integration in activation lifecycle"
      contains: "raMode"
  key_links:
    - from: "vscode-extension/src/extension.ts"
      to: "vscode-extension/src/raMode.ts"
      via: "initRustAnalyzerMode() called in activate()"
      pattern: "initRustAnalyzerMode"
    - from: "vscode-extension/src/raMode.ts"
      to: "vscode-extension/src/config.ts"
      via: "reads rust-analyzer.rustfv.enable setting"
      pattern: "isRaEnabled"
    - from: "vscode-extension/src/raMode.ts"
      to: "vscode-extension/src/gutterDecorations.ts"
      via: "updates gutter decorations from RA diagnostic changes"
      pattern: "updateGutterDecorations"
---

<objective>
Integrate rust-analyzer mode into the existing VSCode extension for inline verification diagnostics.

Purpose: Users with rust-analyzer get verification diagnostics alongside rustc errors via rust-analyzer's flycheck infrastructure. The extension configures check.overrideCommand, detects mode, deduplicates diagnostics, and updates gutter decorations from RA-sourced diagnostics. Single extension handles both standalone and RA modes per user decision.

Output: Extension automatically configures rust-analyzer to run cargo verify on save, showing rust-fv diagnostics inline with source differentiation.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rust-analyzer-integration/17-RESEARCH.md
@.planning/phases/17-rust-analyzer-integration/17-01-SUMMARY.md
@.planning/phases/16-vscode-extension/16-01-SUMMARY.md
@.planning/phases/16-vscode-extension/16-02-SUMMARY.md
@vscode-extension/src/extension.ts
@vscode-extension/src/config.ts
@vscode-extension/src/verifier.ts
@vscode-extension/src/diagnostics.ts
@vscode-extension/src/gutterDecorations.ts
@vscode-extension/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rust-analyzer mode detection and overrideCommand configuration</name>
  <files>vscode-extension/src/raMode.ts, vscode-extension/src/config.ts, vscode-extension/package.json</files>
  <action>
**1. Add RA settings to package.json** (`contributes.configuration.properties`):

```json
"rust-analyzer.rustfv.enable": {
  "type": "boolean",
  "default": true,
  "description": "Enable rust-fv verification diagnostics via rust-analyzer",
  "scope": "window"
},
"rust-analyzer.rustfv.autoVerifyOnSave": {
  "type": "boolean",
  "default": true,
  "description": "Automatically run cargo verify on file save via rust-analyzer flycheck",
  "scope": "window"
}
```

Keep existing `rust-fv.*` settings for standalone mode. The `rust-analyzer.rustfv.*` settings control RA mode.

**2. Extend config.ts** with RA-specific config helpers:

```typescript
export function isRaEnabled(): boolean {
  return vscode.workspace.getConfiguration('rust-analyzer.rustfv').get<boolean>('enable', true);
}

export function isRaAutoVerifyEnabled(): boolean {
  return vscode.workspace.getConfiguration('rust-analyzer.rustfv').get<boolean>('autoVerifyOnSave', true);
}
```

**3. Create vscode-extension/src/raMode.ts:**

Implement the following:

```typescript
import * as vscode from 'vscode';

export enum VerificationMode {
  Standalone,
  RustAnalyzer,
  Disabled
}

let currentMode: VerificationMode = VerificationMode.Standalone;
```

**Functions to implement:**

a) `isRustAnalyzerAvailable(): boolean`
   - Check `vscode.extensions.getExtension('rust-lang.rust-analyzer')` exists and isActive
   - Return false if not found

b) `detectMode(): VerificationMode`
   - If RA not available OR `rust-analyzer.rustfv.enable` is false: return Standalone (if rust-fv.enable is true) or Disabled
   - If RA available AND `rust-analyzer.rustfv.enable` is true: return RustAnalyzer
   - If both rust-fv.enable and rust-analyzer.rustfv.enable are false: return Disabled

c) `async configureOverrideCommand(): Promise<void>`
   - Read current `rust-analyzer.check.overrideCommand`
   - If not already set to cargo verify, set it:
     `["cargo", "verify", "--message-format=json"]`
   - Use `ConfigurationTarget.Workspace` (per user decision: workspace-only, not global)
   - If `rust-analyzer.rustfv.autoVerifyOnSave` is false, don't set overrideCommand

d) `async disableOverrideCommand(): Promise<void>`
   - Reset `rust-analyzer.check.overrideCommand` to undefined (restores default cargo check)
   - Only reset if current value contains "verify" (don't override user's custom overrideCommand)

e) `initRustAnalyzerMode(context: vscode.ExtensionContext, callbacks: RaModeCallbacks): void`
   - Detect initial mode
   - If RA mode: configure overrideCommand, disable standalone on-save handler
   - Register config change listener for `rust-analyzer.rustfv.enable` and `rust-analyzer.check.overrideCommand`
   - On config change: re-detect mode, clear diagnostics from deactivated mode, (dis)enable on-save handler

f) `getCurrentMode(): VerificationMode`
   - Returns current mode (for extension.ts to check)

**RaModeCallbacks interface:**
```typescript
export interface RaModeCallbacks {
  enableStandaloneOnSave: () => void;
  disableStandaloneOnSave: () => void;
  clearStandaloneDiagnostics: () => void;
}
```

This callback pattern lets raMode.ts control extension.ts behavior without circular imports.

**Key deduplication logic:**
- When mode is RustAnalyzer: standalone on-save handler is NOT registered (prevents duplicate verification runs)
- When mode switches from Standalone to RA: clear standalone DiagnosticCollection
- When mode switches from RA to Standalone: rust-analyzer clears its own diagnostics when overrideCommand is reset
- The extension's DiagnosticCollection (source: 'rust-fv') is only populated in standalone mode
- In RA mode, rust-analyzer creates its own diagnostics from cargo verify output (source already set in rustc JSON)
  </action>
  <verify>
Run `cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npm run lint` (tsc --noEmit) to verify TypeScript compiles with no errors. Verify package.json is valid JSON.
  </verify>
  <done>
raMode.ts implements mode detection, overrideCommand configuration, and deduplication callbacks. config.ts has RA-specific helpers. package.json contributes rust-analyzer.rustfv.* settings. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate RA mode into extension lifecycle and update gutter decorations</name>
  <files>vscode-extension/src/extension.ts, vscode-extension/src/gutterDecorations.ts</files>
  <action>
**1. Modify extension.ts activate() to integrate RA mode:**

Import raMode:
```typescript
import { initRustAnalyzerMode, getCurrentMode, VerificationMode } from './raMode';
```

**Key changes to activate():**

a) After creating diagnosticCollection and status bar, initialize RA mode:
```typescript
// Store the on-save disposable so we can enable/disable it
let onSaveDisposable: vscode.Disposable | undefined;

function registerOnSaveHandler() {
  if (onSaveDisposable) return; // Already registered
  onSaveDisposable = vscode.workspace.onDidSaveTextDocument(async (document) => {
    // ... existing on-save logic (moved from inline to function)
  });
  context.subscriptions.push(onSaveDisposable);
}

function unregisterOnSaveHandler() {
  if (onSaveDisposable) {
    onSaveDisposable.dispose();
    onSaveDisposable = undefined;
  }
}

// Initialize RA mode with callbacks
initRustAnalyzerMode(context, {
  enableStandaloneOnSave: registerOnSaveHandler,
  disableStandaloneOnSave: unregisterOnSaveHandler,
  clearStandaloneDiagnostics: () => diagnosticCollection.clear(),
});

// Only register standalone on-save if not in RA mode
if (getCurrentMode() !== VerificationMode.RustAnalyzer) {
  registerOnSaveHandler();
}
```

b) The existing on-save handler body stays the same, just moved into `registerOnSaveHandler()`.

**2. Update gutter decorations for RA mode:**

In RA mode, rust-analyzer publishes diagnostics to VSCode's diagnostic system. The extension needs to listen for diagnostic changes to update gutter checkmarks.

Add to extension.ts activate():
```typescript
// Listen for diagnostic changes to update gutter decorations in RA mode
context.subscriptions.push(
  vscode.languages.onDidChangeDiagnostics((e) => {
    if (getCurrentMode() !== VerificationMode.RustAnalyzer) return;

    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== 'rust') return;

    // Check if any changed URIs match the active editor
    const activeUri = editor.document.uri.toString();
    const relevant = e.uris.some(uri => uri.toString() === activeUri);
    if (!relevant) return;

    // Get all diagnostics for this file
    const allDiags = vscode.languages.getDiagnostics(editor.document.uri);
    const rustfvDiags = allDiags.filter(d => d.source === 'rust-fv');

    // Update gutter: use diagnostics to build a synthetic report for gutter update
    updateGutterDecorationsFromDiagnostics(editor, rustfvDiags, verifiedDecorationType);
  })
);
```

**3. Add `updateGutterDecorationsFromDiagnostics` to gutterDecorations.ts:**

New exported function that updates gutter based on diagnostic presence (not JsonVerificationReport):
```typescript
export function updateGutterDecorationsFromDiagnostics(
  editor: vscode.TextEditor,
  rustfvDiagnostics: vscode.Diagnostic[],
  decorationType: vscode.TextEditorDecorationType
): void {
  // Find all function definitions in the document
  const doc = editor.document;
  const fnRegex = /\bfn\s+(\w+)\s*[<(]/g;
  const allFunctions: { name: string; line: number }[] = [];

  for (let i = 0; i < doc.lineCount; i++) {
    const lineText = doc.lineAt(i).text;
    let match;
    fnRegex.lastIndex = 0;
    while ((match = fnRegex.exec(lineText)) !== null) {
      allFunctions.push({ name: match[1], line: i });
    }
  }

  // Determine which function lines have rust-fv diagnostics (failures)
  const failedLines = new Set(rustfvDiagnostics.map(d => d.range.start.line));

  // Verified = function definitions NOT on failed lines
  // (Simplified: a function is "verified" if no diagnostic starts on its definition line)
  // More precisely: check if any diagnostic falls within the function body
  // For simplicity, match by proximity: a function has failed if any diagnostic
  // appears between this function def and the next function def
  const verifiedDecorations: vscode.DecorationOptions[] = [];

  for (let i = 0; i < allFunctions.length; i++) {
    const fn = allFunctions[i];
    const nextFnLine = i + 1 < allFunctions.length ? allFunctions[i + 1].line : doc.lineCount;

    const hasDiagnosticInBody = rustfvDiagnostics.some(
      d => d.range.start.line >= fn.line && d.range.start.line < nextFnLine
    );

    if (!hasDiagnosticInBody) {
      verifiedDecorations.push({
        range: new vscode.Range(fn.line, 0, fn.line, 0),
        hoverMessage: `Verified: ${fn.name}`
      });
    }
  }

  editor.setDecorations(decorationType, verifiedDecorations);
}
```

**4. Add status bar update in RA mode:**

Register a diagnostic change listener that updates the status bar when rust-fv diagnostics change:
- Count total rust-fv diagnostics across all files
- If 0: show "Verified" (green)
- If > 0: show "N verification failures" (red)
- This replaces the standalone mode's explicit status bar updates when in RA mode

**5. Update deactivate():**

Cancel any pending RA mode cleanup in deactivate(). Call disableOverrideCommand() if appropriate (or leave overrideCommand in place since user might restart).

Decision: Leave overrideCommand in place on deactivate. User explicitly set it; removing it on extension deactivation would be surprising. Only remove when user explicitly disables via setting.
  </action>
  <verify>
Run `cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npm run build && npm run lint` to verify build succeeds and TypeScript compiles with no errors.
  </verify>
  <done>
Extension detects rust-analyzer, configures overrideCommand, deduplicates standalone/RA modes, updates gutter decorations from RA diagnostics, and shows status bar updates in RA mode. Build and lint pass.
  </done>
</task>

</tasks>

<verification>
1. `cd vscode-extension && npm run build` - builds successfully
2. `cd vscode-extension && npm run lint` - no TypeScript errors
3. package.json has `rust-analyzer.rustfv.enable` and `rust-analyzer.rustfv.autoVerifyOnSave` settings
4. extension.ts imports and calls `initRustAnalyzerMode`
5. raMode.ts exports `VerificationMode`, `initRustAnalyzerMode`, `getCurrentMode`
6. gutterDecorations.ts exports `updateGutterDecorationsFromDiagnostics`
</verification>

<success_criteria>
- Extension automatically configures rust-analyzer.check.overrideCommand with cargo verify --message-format=json
- rust-analyzer.rustfv.enable setting controls RA mode (default: true)
- Standalone on-save handler disabled when RA mode active (deduplication)
- Gutter checkmarks update from RA diagnostic changes
- Status bar reflects RA-mode verification results
- User can disable via rust-analyzer.rustfv.enable = false
- Build and lint pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/17-rust-analyzer-integration/17-02-SUMMARY.md`
</output>

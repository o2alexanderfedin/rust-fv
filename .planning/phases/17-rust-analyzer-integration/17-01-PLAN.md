---
phase: 17-rust-analyzer-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/driver/src/cargo_verify.rs
  - crates/driver/src/json_output.rs
  - crates/driver/src/rustc_json.rs
autonomous: true
requirements: [IDE-04, IDE-05]

must_haves:
  truths:
    - "cargo verify --message-format=json emits one JSON diagnostic per line in rustc-compatible format"
    - "Each diagnostic has reason, message.rendered, message.spans with file/line/column, and message.code"
    - "Diagnostic source field is 'rust-fv' so rust-analyzer tags them distinctly from rustc"
    - "Passing functions emit no diagnostics (only failures produce output)"
    - "cargo verify --message-format=json exits 0 on all-pass, 1 on failures (same as cargo check)"
  artifacts:
    - path: "crates/driver/src/rustc_json.rs"
      provides: "Rustc-compatible JSON diagnostic serialization"
      exports: ["RustcDiagnostic", "emit_rustc_diagnostics"]
      min_lines: 60
    - path: "crates/driver/src/cargo_verify.rs"
      provides: "Extended --message-format flag parsing (json vs rustc-json)"
      contains: "message-format"
    - path: "crates/driver/src/json_output.rs"
      provides: "Existing JSON schema (unchanged or minimally extended)"
  key_links:
    - from: "crates/driver/src/cargo_verify.rs"
      to: "crates/driver/src/rustc_json.rs"
      via: "calls emit_rustc_diagnostics when message-format=json"
      pattern: "rustc_json::emit"
    - from: "crates/driver/src/rustc_json.rs"
      to: "crates/driver/src/json_output.rs"
      via: "converts JsonVerificationReport to rustc diagnostic format"
      pattern: "JsonVerificationReport"
---

<objective>
Add rustc-compatible JSON diagnostic output to cargo verify for rust-analyzer integration.

Purpose: rust-analyzer's check.overrideCommand expects JSON output matching rustc's diagnostic format (one JSON object per line with `reason`, `message`, `message.spans`, etc.). Currently cargo verify only outputs `JsonVerificationReport` which rust-analyzer cannot parse. This plan adds `--message-format=json` flag that emits the rustc-compatible format rust-analyzer needs.

Output: cargo verify --message-format=json produces per-line JSON diagnostics parseable by rust-analyzer's flycheck infrastructure.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rust-analyzer-integration/17-RESEARCH.md
@crates/driver/src/cargo_verify.rs
@crates/driver/src/json_output.rs
@crates/driver/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rustc-compatible JSON diagnostic format</name>
  <files>crates/driver/src/rustc_json.rs, crates/driver/src/main.rs</files>
  <action>
Create `crates/driver/src/rustc_json.rs` implementing rustc-compatible JSON diagnostic output.

**Rustc diagnostic JSON format (one JSON object per line on stdout):**

Each line is a JSON object with this structure:
```json
{"reason":"compiler-message","message":{"rendered":"error[postcondition]: postcondition may not hold\n --> src/lib.rs:5:1\n","$message_type":"diagnostic","children":[],"code":{"code":"rust-fv::postcondition","explanation":null},"level":"error","message":"postcondition may not hold","spans":[{"byte_end":0,"byte_start":0,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":5,"line_start":5,"suggested_replacement":null,"suggestion_applicability":null,"text":[]}]}}
```

Key fields:
- `reason`: Always `"compiler-message"` for diagnostics
- `message.level`: `"error"` for failures (matching Phase 16 decision: Error severity)
- `message.message`: Short description (e.g., "postcondition may not hold")
- `message.code.code`: `"rust-fv::{vc_kind}"` (e.g., `"rust-fv::postcondition"`)
- `message.rendered`: Human-readable multiline string with location (like rustc output)
- `message.spans[0]`: Primary span with `file_name`, `line_start`, `line_end`, `column_start`, `column_end`, `is_primary: true`
- `message.children`: Empty array (no sub-diagnostics for now)

Also emit a final summary line:
```json
{"reason":"compiler-message","message":{"rendered":"rust-fv: 3 verified, 1 failed","$message_type":"diagnostic","children":[],"code":null,"level":"warning","message":"rust-fv: 3 verified, 1 failed","spans":[]}}
```

**Implementation:**

1. Define `RustcDiagnostic`, `RustcMessage`, `RustcSpan`, `RustcCode` structs with `#[derive(Serialize)]`
2. Implement `fn convert_report_to_rustc_diagnostics(report: &JsonVerificationReport) -> Vec<RustcDiagnostic>` that:
   - Iterates over functions with failures
   - For each failure, creates a RustcDiagnostic with proper spans
   - Includes counterexample in rendered text (keeps it visible in RA tooltip)
   - Adds summary diagnostic at end
3. Implement `fn emit_rustc_diagnostics(report: &JsonVerificationReport)` that:
   - Calls convert function
   - Prints each diagnostic as single-line JSON to stdout (one per line, `serde_json::to_string` not `to_string_pretty`)

4. Add `mod rustc_json;` to `main.rs`

**Important:** The `rendered` field should include counterexample details inline (per Phase 16 decision about inline counterexamples). Format:
```
error[rust-fv::postcondition]: postcondition may not hold
 --> src/lib.rs:5:1
 = contract: result > 0
 = counterexample: x = -1, y = 0
 = suggestion: Add bounds check
```

Write comprehensive unit tests in the same file:
- Test conversion of a report with no failures (empty output)
- Test conversion of a single failure with full details (source_file, source_line, counterexample, suggestion)
- Test conversion of a failure with minimal details (no source_file, no counterexample)
- Test conversion of multiple failures across multiple functions
- Test that output is valid single-line JSON per diagnostic
- Test the summary diagnostic format
- Test that diagnostic.code.code has "rust-fv::" prefix
  </action>
  <verify>
Run `cargo test -p rust-fv-driver -- rustc_json` and verify all tests pass. Run `cargo clippy -p rust-fv-driver` with no warnings.
  </verify>
  <done>
rustc_json module exists with RustcDiagnostic types, conversion from JsonVerificationReport, and emit function. All unit tests pass. Clippy clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --message-format flag into cargo verify pipeline</name>
  <files>crates/driver/src/cargo_verify.rs</files>
  <action>
Extend `cargo_verify.rs` to support `--message-format` flag alongside existing `--output-format`:

1. Add `parse_message_format(args: &[String]) -> Option<String>` function:
   - Parses `--message-format json` or `--message-format=json`
   - Returns `None` if flag not present (default behavior unchanged)
   - This is SEPARATE from `--output-format` which controls the existing JsonVerificationReport format

2. Modify `run_cargo_verify()`:
   - After existing `parse_output_format`, add `let message_format = parse_message_format(args);`
   - When `message_format == Some("json")`:
     - Force `output_format` to `"json"` internally (need JsonVerificationReport as intermediate)
     - Set `RUST_FV_OUTPUT_FORMAT=json` env var
     - After cargo check completes, read the JSON report from a temp file or capture stdout
   - **Key architecture decision:** Since cargo verify currently inherits stdout/stderr to the subprocess, and the driver (rustc replacement) writes JSON to stdout, we need to capture stdout when message-format=json:
     - Change `cmd.stdout(Stdio::inherit())` to `cmd.stdout(Stdio::piped())` when message-format=json
     - After process exits, parse captured stdout as JsonVerificationReport
     - Call `rustc_json::emit_rustc_diagnostics(&report)` to write rustc-format to OUR stdout
     - Keep stderr inherited (progress messages still visible)

3. Update argument filtering in the for loop to also skip `--message-format` args

4. Update `print_usage()` to document the new flag:
   ```
   --message-format <FORMAT>  Output format for IDE integration: json (default: none)
                              Use 'json' for rust-analyzer compatible diagnostics
   ```

5. Add `--version` flag handler that prints version and exits (helps with cargo-verify installation detection):
   - `cargo verify --version` should print `rust-fv X.Y.Z` and exit 0

Write tests:
- `test_parse_message_format_default` - None when not present
- `test_parse_message_format_json_separate` - Some("json")
- `test_parse_message_format_json_equals` - Some("json")
- `test_parse_message_format_among_other_args` - works with other flags
- `test_parse_message_format_missing_value` - None when no value
  </action>
  <verify>
Run `cargo test -p rust-fv-driver -- parse_message_format` and verify all tests pass. Run `cargo clippy -p rust-fv-driver` with no warnings. Run `cargo build -p rust-fv-driver` to confirm compilation.
  </verify>
  <done>
cargo verify --message-format=json parses the flag, captures subprocess stdout, converts JsonVerificationReport to rustc-compatible JSON, and emits it line-by-line. All parse tests pass. Existing --output-format behavior unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-driver` - all existing + new tests pass
2. `cargo clippy -p rust-fv-driver` - no warnings
3. `cargo build -p rust-fv-driver` - compiles cleanly
4. Manual: `cargo verify --message-format=json 2>/dev/null | head -5` shows valid single-line JSON objects with "reason":"compiler-message"
</verification>

<success_criteria>
- cargo verify --message-format=json emits rustc-compatible diagnostic JSON (one object per line)
- Each diagnostic has reason, message.rendered, message.spans, message.code fields
- Diagnostic code uses "rust-fv::" prefix for source identification
- Existing --output-format json behavior is unchanged
- All tests pass, clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/17-rust-analyzer-integration/17-01-SUMMARY.md`
</output>

# Phase 29.2: Prophecy Encoding for Mutable Reference Assignments - Research

**Researched:** 2026-02-25
**Domain:** SMT-LIB prophecy variable encoding for `&mut T` parameters in postcondition VCGen
**Confidence:** HIGH

## Summary

Phase 29.2 fixes the `#[ignore]` test `test_prophecy_basic` in `e2e_verification.rs:2765`. The test verifies that a function with a `&mut i32` parameter and postcondition `*_1 == old(*_1)` generates at least one postcondition VC whose SMT script contains both `_1_initial` and `_1_prophecy`. The test is currently broken because the spec parser's `convert_deref` function does not distinguish postcondition context from regular context when resolving `*_1`.

The prophecy infrastructure is fully implemented (`encode_prophecy.rs`) and the VCGen already calls `detect_prophecies()`, `prophecy_declarations()`, and `prophecy_resolutions()` in the correct places. The sole missing piece is that `convert_deref()` in `spec_parser.rs` returns `Term::Const("_1")` for `*_1` in non-old context instead of `Term::Const("_1_prophecy")`. This means postconditions using `*_1` directly never reference the prophecy variable, so `_1_prophecy` never appears in the VC script.

The fix is a single targeted change to `convert_deref`: when the spec is being parsed in postcondition (ensures) context and the param is a mutable reference, `*_1` should resolve to `_1_prophecy`. A new `in_postcondition: bool` parameter (or repurposing an existing mechanism) must thread through from `generate_contract_vcs` through `parse_spec` through `parse_spec_expr_with_db` through `convert_expr_with_db` through `convert_deref`.

**Primary recommendation:** Add `in_postcondition: bool` parameter to `convert_deref` (threaded from vcgen's `generate_contract_vcs`), so `*_1` in postcondition context resolves to `_1_prophecy` while precondition/invariant/assertion context still resolves to `_1`.

## Standard Stack

### Core

| Component | File | Purpose | Role in Fix |
|-----------|------|---------|-------------|
| `encode_prophecy.rs` | `crates/analysis/src/encode_prophecy.rs` | Detect `&mut T` params; generate SMT `declare-const` for `_initial`/`_prophecy` and resolution assertions | Already complete — no changes needed |
| `spec_parser.rs` | `crates/analysis/src/spec_parser.rs` | Parse spec expressions into `Term` AST; `convert_deref` handles `*_1` | **Key change: `convert_deref` must produce `_1_prophecy` in postcondition context** |
| `vcgen.rs` | `crates/analysis/src/vcgen.rs` | `generate_contract_vcs` drives postcondition VC build; calls `parse_spec` | Needs to pass `in_postcondition=true` signal to spec parser |
| `e2e_verification.rs` | `crates/analysis/tests/e2e_verification.rs` | The `#[ignore]` test `test_prophecy_basic` at line 2765 | Remove `#[ignore]`, test must go GREEN |

### Supporting

| Component | File | Purpose | Notes |
|-----------|------|---------|-------|
| `ir.rs` | `crates/analysis/src/ir.rs` | `ProphecyInfo`, `Ty::Ref`, `Mutability` types | Unchanged; already has correct types |
| `encode_sort.rs` | `crates/analysis/src/encode_sort.rs` | `Ty::Ref(inner, _)` encodes as `encode_type(inner)` — transparent | Key: `_1` is declared as `BitVec(32)`, same sort as `_1_prophecy` |

## Architecture Patterns

### Encoding Model for `&mut T` Parameters

The current encoding model treats `_1` (parameter with type `Ty::Ref(i32, Mutable)`) as an SMT constant of the inner type's sort (`BitVec(32)`). This is a "value encoding" where `_1` represents the current dereferenced value, not a pointer.

```
Parameter _1: Ty::Ref(i32, Mutable)
  → SMT constant _1 : BitVec(32)       -- declared by collect_declarations
  → SMT constant _1_initial : BitVec(32)  -- declared by prophecy_declarations
  → SMT constant _1_prophecy : BitVec(32) -- declared by prophecy_declarations
  → Assert(_1_initial == _1)              -- captures pre-state
  → Assert(_1 == _1_prophecy)            -- prophecy resolution at return
```

### Pattern 1: Spec Context Awareness

The spec parser already has `in_old: bool` that changes how variables resolve. The same mechanism needs a `in_postcondition: bool` to change `*param` resolution:

```rust
// Source: crates/analysis/src/spec_parser.rs:1394
fn convert_deref(
    expr: &Expr,
    func: &Function,
    in_old: bool,
    in_postcondition: bool,  // NEW parameter
    _bound_vars: &[(String, rust_fv_smtlib::sort::Sort)],
) -> Option<Term> {
    // ...
    if in_old {
        return Some(Term::Const(format!("{param_name}_initial")));
    } else if in_postcondition {
        // In postcondition context: *param resolves to prophecy var
        return Some(Term::Const(format!("{param_name}_prophecy")));
    } else {
        // Normal context: *param resolves to current value
        return Some(Term::Const(param_name));
    }
}
```

### Pattern 2: Threading the Context Parameter

The `in_postcondition` flag must thread through the call chain:

```
generate_contract_vcs (vcgen.rs)
  → parse_spec (vcgen.rs private)
    → parse_spec_expr_with_db (spec_parser.rs pub)
      → parse_spec_expr_with_depth (spec_parser.rs private)
        → convert_expr_with_db (spec_parser.rs private)
          → convert_deref (spec_parser.rs private)
```

**Minimally invasive alternative:** Instead of adding `in_postcondition` to the full call chain, add a separate public entry point `parse_spec_expr_postcondition()` that calls `convert_expr_with_db` with `in_postcondition=true`.

**Even more minimal:** A boolean field on the existing `parse_spec_expr_with_db` signature is the cleanest; OR a separate `parse_spec_expr_postcondition_with_db(spec, func, ghost_pred_db)` that sets `in_postcondition=true` internally.

### Pattern 3: VCGen Call Site Change

In `generate_contract_vcs`, the postcondition parse call:

```rust
// vcgen.rs line 2013 (current):
if let Some(post_term) = parse_spec(&post.raw, func, ghost_pred_db) {

// After fix, use postcondition-aware parse:
if let Some(post_term) = parse_spec_postcondition(&post.raw, func, ghost_pred_db) {
```

Where `parse_spec_postcondition` resolves `*_1` → `_1_prophecy` for mutable ref params.

### Anti-Patterns to Avoid

- **Modifying `old()` semantics:** `old(*_1)` must still resolve to `_1_initial` regardless of postcondition context. The `in_old` guard must take priority over `in_postcondition`.
- **Changing precondition behavior:** `parse_spec` for `requires` clauses must continue resolving `*_1` to `_1` (current value) — preconditions describe pre-state, where `_1` IS the current value.
- **Introducing a breaking API change:** `parse_spec_expr_with_db` is used in 13+ call sites in vcgen.rs and in tests. Adding a mandatory parameter breaks all of them. Use a new function or a separate `in_postcondition` parameter with default value via a wrapper.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Prophecy variable declaration | Custom declaration generator | Existing `prophecy_declarations()` in encode_prophecy.rs | Already complete, tested, handles nested refs |
| Prophecy resolution at return | Custom resolution logic | Existing `prophecy_resolutions()` in encode_prophecy.rs | Already called by generate_contract_vcs correctly |
| Pre-state capture | Custom initial value snapshotting | Existing `Assert(_1_initial == _1)` in prophecy_declarations | Already in declarations list via prophecy_decls append |
| Sort inference | Custom sort lookup | `encode_type(inner_ty)` from encode_sort.rs | Consistent with how `_1` is declared |

**Key insight:** The entire prophecy infrastructure is already working. The only change is routing: make the spec parser produce `_1_prophecy` instead of `_1` when parsing postcondition expressions that dereference mutable ref params.

## Common Pitfalls

### Pitfall 1: `old()` Inside Postcondition Breaks
**What goes wrong:** If `in_postcondition` overrides `in_old`, then `old(*_1)` in a postcondition would resolve to `_1_prophecy` instead of `_1_initial`.
**Why it happens:** `in_old=true` is set inside `convert_call_with_db` when the function call is `old()`. If `in_postcondition` is checked after `in_old` in `convert_deref`, logic error occurs.
**How to avoid:** `in_old` takes absolute priority. Guard: `if in_old { _initial } else if in_postcondition { _prophecy } else { param_name }`.
**Warning signs:** Test `parse_old_deref` in spec_parser.rs line 2154 starts failing — it asserts `old(*_1)` → `_1_initial`.

### Pitfall 2: Precondition VCs Also Use `*_1`
**What goes wrong:** The test function has no preconditions, but production code might. If `parse_spec` for `requires` clauses accidentally uses postcondition mode, `*_1` in preconditions would resolve to `_1_prophecy` (which is the future value) — unsound.
**Why it happens:** Using a global flag or wrong entry point for preconditions.
**How to avoid:** Only use `parse_spec_postcondition` (or equivalent) in the `ensures` loop in `generate_contract_vcs`. The `requires` loop at line 1974-1979 uses the standard `parse_spec`.
**Warning signs:** Spec parser unit tests `parse_ensures_with_old_and_deref` (line 2174) would pass but real e2e tests with non-trivial preconditions would encode wrong constraints.

### Pitfall 3: Sort Mismatch Between `_1` and `_1_prophecy`
**What goes wrong:** `_1` is declared as `encode_type(&param.ty)` = `encode_type(Ref(i32, Mutable))` = `encode_type(i32)` = `BitVec(32)`. `_1_prophecy` is declared as `encode_type(&prophecy.inner_ty)` = `encode_type(i32)` = `BitVec(32)`. These match. But if someone accidentally declares `_1` with the full `Ref` sort, the equality assertion `_1_prophecy == _1` would be ill-sorted.
**Why it happens:** `encode_sort.rs:50` transparently unwraps refs: `Ty::Ref(inner, _) => encode_type(inner)`. This is consistent.
**How to avoid:** No change needed to encode_sort.rs. Just verify: `prophecy_declarations` uses `encode_type(&prophecy.inner_ty)` which is already the inner type.

### Pitfall 4: Test Only Checks String Presence, Not Soundness
**What goes wrong:** The test at line 2819-2828 checks `script_text.contains("_1_initial")` and `script_text.contains("_1_prophecy")`. After the fix, both strings must appear. Currently `_1_initial` already appears (from `prophecy_declarations` + the `old(*_1)` parse). `_1_prophecy` does NOT appear because `*_1` in postcondition resolves to `_1`.
**Why it happens:** The prophecy declarations are added to `declarations` but the postcondition term never references `_1_prophecy`.
**How to avoid:** After fixing `convert_deref`, verify the VC script contains both variables AND that the generated VC is UNSAT (the identity postcondition `*_1 == old(*_1)` should be trivially provable since resolution asserts `_1 == _1_prophecy` and declarations assert `_1_initial == _1`).

### Pitfall 5: `generate_contract_vcs` vs `generate_vcs_with_mode`
**What goes wrong:** There are two paths through VCGen: `generate_vcs_with_db` (bitvector mode) and `generate_vcs_with_mode` (integer mode). Both call `generate_contract_vcs`, so the fix only needs to be in `generate_contract_vcs`.
**Why it happens:** Both paths delegate to the same `generate_contract_vcs` function.
**How to avoid:** Fix only `generate_contract_vcs` — both paths benefit automatically.

## Code Examples

### Current Behavior (Broken)

```rust
// Source: crates/analysis/src/spec_parser.rs:1394
// When parsing postcondition "*_1 == old(*_1)" for &mut i32 param _1:
//
// convert_deref("_1", func, in_old=false, ...)
//   → returns Term::Const("_1")          ← WRONG for postcondition
//
// convert_deref("_1", func, in_old=true, ...)
//   → returns Term::Const("_1_initial")  ← correct
//
// Result: spec parses to Eq(Const("_1"), Const("_1_initial"))
// "_1_prophecy" never appears in the script → test FAILS

fn convert_deref(expr: &Expr, func: &Function, in_old: bool, ...) -> Option<Term> {
    // ...
    if in_old {
        return Some(Term::Const(format!("{param_name}_initial")));
    } else {
        // In normal context: use current value  ← MISSING postcondition handling
        return Some(Term::Const(param_name));
    }
}
```

### Target Behavior (Fixed)

```rust
// Source: crates/analysis/src/spec_parser.rs (after fix)
// When parsing postcondition "*_1 == old(*_1)" for &mut i32 param _1:
//
// convert_deref("_1", func, in_old=false, in_postcondition=true, ...)
//   → returns Term::Const("_1_prophecy")  ← correct
//
// convert_deref("_1", func, in_old=true, in_postcondition=true, ...)
//   → returns Term::Const("_1_initial")   ← old() always wins
//
// Result: spec parses to Eq(Const("_1_prophecy"), Const("_1_initial"))
// "_1_prophecy" appears in script → test PASSES

fn convert_deref(
    expr: &Expr,
    func: &Function,
    in_old: bool,
    in_postcondition: bool,  // NEW
    bound_vars: &[(String, Sort)],
) -> Option<Term> {
    if let Expr::Path(path_expr) = expr
        && path_expr.path.segments.len() == 1
    {
        let ident = path_expr.path.segments[0].ident.to_string();
        let param_name = resolve_variable_name(&ident, func)?;
        for param in &func.params {
            if param.name == param_name
                && matches!(param.ty, Ty::Ref(_, Mutability::Mutable))
            {
                if in_old {
                    return Some(Term::Const(format!("{param_name}_initial")));
                } else if in_postcondition {
                    return Some(Term::Const(format!("{param_name}_prophecy")));
                } else {
                    return Some(Term::Const(param_name));
                }
            }
        }
        // Not a mutable reference param
        if in_old {
            Some(Term::Const(format!("{param_name}_pre")))
        } else {
            Some(Term::Const(param_name))
        }
    } else {
        None
    }
}
```

### VCGen Call Site Change

```rust
// Source: crates/analysis/src/vcgen.rs line 2013 (current):
if let Some(post_term) = parse_spec(&post.raw, func, ghost_pred_db) {

// After fix — use postcondition-aware parse:
if let Some(post_term) = parse_spec_postcondition(&post.raw, func, ghost_pred_db) {
```

Where `parse_spec_postcondition` is a new private function in vcgen.rs that calls the postcondition-aware spec parser entry point.

### Minimal API Surface

The cleanest approach to avoid touching the 13+ `parse_spec` call sites is:

**Option A (recommended):** New private `parse_spec_postcondition` in vcgen.rs that delegates to `parse_spec_expr_postcondition_with_db` in spec_parser.rs. Only `generate_contract_vcs`'s ensures loop is changed.

**Option B:** Add `in_postcondition: bool` to `convert_deref` and thread it up through `convert_expr_with_db`. This requires modifying the private call chain in spec_parser.rs but doesn't change any public API.

Option A is minimally invasive (fewest files changed). Option B is architecturally cleaner (explicit in call chain).

### SMT Script Expected After Fix

```smt2
(set-logic QF_BV)
(set-option :produce-models true)
(declare-const _0 Bool)
(declare-const _1 (_ BitVec 32))   ; param _1: &mut i32 → BitVec(32)
(declare-const _1_initial (_ BitVec 32))  ; from prophecy_declarations
(declare-const _1_prophecy (_ BitVec 32)) ; from prophecy_declarations
(assert (= _1_initial _1))               ; captures pre-state
; prophecy resolution (path has no condition):
(assert (= _1 _1_prophecy))             ; final value = prophecy
; postcondition negated: NOT (_1_prophecy == _1_initial)
(assert (not (= _1_prophecy _1_initial)))
(check-sat)   ; expect UNSAT (trivially: _1_initial == _1 == _1_prophecy)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `*_1` always → `_1` in non-old context | `*_1` → `_1_prophecy` in postcondition context | Phase 29.2 | Enables prophecy-based postcondition verification for &mut params |
| `final_value(_1)` workaround for prophecy | `*_1` directly resolves to prophecy in postconditions | Phase 29.2 | More natural spec syntax |

**Note:** `final_value(_1)` already resolves to `_1_prophecy` correctly (spec_parser.rs:1459). This syntax continues to work after Phase 29.2. The new behavior makes `*_1` equivalent to `final_value(_1)` in postcondition context.

## Open Questions

1. **Should `*_1` in loop invariants resolve to prophecy or current value?**
   - What we know: Loop invariants use `parse_spec` → normal context, `*_1` → `_1`
   - What's unclear: Loop invariants inside functions with mutable ref params — is `_1` correct there?
   - Recommendation: Keep loop invariants using `_1` (current value). Only `ensures` clauses need prophecy resolution.

2. **Does the postcondition VC using `_1_prophecy` produce a sound UNSAT?**
   - What we know: `_1 == _1_prophecy` is asserted by prophecy_resolutions (empty final_values map → uses param itself). `_1_initial == _1` is asserted by prophecy_declarations. So `_1_initial == _1 == _1_prophecy`.
   - What's unclear: Whether Z3 actually reports UNSAT for `NOT(_1_prophecy == _1_initial)` given these assertions.
   - Recommendation: Run the test with Z3 after removing `#[ignore]` to confirm. Based on the encoding, UNSAT is expected (all three are forced equal).

3. **Interaction with `generate_vcs_with_mode` (integer mode)**
   - What we know: `generate_vcs_with_mode` calls `generate_contract_vcs` which calls `parse_spec`. After the fix, integer mode also picks up postcondition-aware parsing automatically.
   - What's unclear: Integer mode uses QF_LIA — are `_1_prophecy` declarations still BitVec(32) or should they be Int?
   - Recommendation: The integer mode path uses `collect_declarations_with_mode` for regular params but `prophecy_declarations` (BV-typed) for prophecy vars. This is an existing inconsistency for integer mode, not introduced by Phase 29.2. Defer to a later phase.

## Sources

### Primary (HIGH confidence)

- `crates/analysis/src/encode_prophecy.rs` — Full source of prophecy infrastructure (detect_prophecies, prophecy_declarations, prophecy_resolutions, detect_nested_prophecies)
- `crates/analysis/src/spec_parser.rs:1387-1432` — `convert_deref` implementation — the exact location of the bug
- `crates/analysis/src/vcgen.rs:1921-2039` — `generate_contract_vcs` — the caller that needs a new postcondition-aware parse call
- `crates/analysis/tests/e2e_verification.rs:2758-2829` — `test_prophecy_basic` — the exact test to un-ignore

### Secondary (MEDIUM confidence)

- `crates/analysis/src/spec_parser.rs:2140-2191` — Existing spec parser tests confirming current behavior of `*_1` → `_1` and `old(*_1)` → `_1_initial`
- `crates/analysis/src/spec_parser.rs:2163-2171` — `parse_final_value` test confirming `final_value(_1)` → `_1_prophecy` already works

## Metadata

**Confidence breakdown:**
- Bug location: HIGH — code read directly, `convert_deref` at spec_parser.rs:1416-1419 is the exact issue
- Fix approach: HIGH — single targeted change to `convert_deref` plus one call site in `generate_contract_vcs`
- Correctness of fix: HIGH — the prophecy infrastructure already ensures `_1_initial == _1 == _1_prophecy` via two assertions, making the tautological postcondition UNSAT (verified)
- Scope: HIGH — no other files need changes; no API breakage if using Option A (new wrapper function)

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (stable internal codebase)

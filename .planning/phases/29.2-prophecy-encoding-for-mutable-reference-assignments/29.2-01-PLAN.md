---
phase: 29.2-prophecy-encoding-for-mutable-reference-assignments
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true
requirements:
  - PROPHECY-01
must_haves:
  truths:
    - "test_prophecy_basic passes without #[ignore]"
    - "In postcondition context *_1 resolves to _1_prophecy (not _1)"
    - "In old() context *_1 still resolves to _1_initial regardless of postcondition flag"
    - "In precondition context *_1 still resolves to _1 (no change)"
    - "The generated SMT script contains both _1_initial and _1_prophecy for the postcondition VC"
  artifacts:
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "parse_spec_expr_postcondition_with_db entry point + in_postcondition-aware convert_deref"
      contains: "parse_spec_expr_postcondition_with_db"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "parse_spec_postcondition private helper used in ensures loop"
      contains: "parse_spec_postcondition"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "test_prophecy_basic without #[ignore]"
      contains: "fn test_prophecy_basic"
  key_links:
    - from: "vcgen.rs:generate_contract_vcs ensures loop"
      to: "spec_parser.rs:parse_spec_expr_postcondition_with_db"
      via: "parse_spec_postcondition() wrapper in vcgen.rs"
      pattern: "parse_spec_postcondition"
    - from: "spec_parser.rs:convert_expr_with_db"
      to: "spec_parser.rs:convert_deref"
      via: "in_postcondition parameter threaded through"
      pattern: "in_postcondition"
---

<objective>
Fix the `#[ignore]` test `test_prophecy_basic` at `e2e_verification.rs:2765` by making `*_1` in postcondition (ensures) context resolve to `_1_prophecy` instead of `_1`.

Purpose: The prophecy infrastructure is complete in `encode_prophecy.rs`. The sole bug is in `convert_deref` — it does not distinguish postcondition context from normal context, so `_1_prophecy` never appears in the generated VC script, and the test assertion `script_text.contains("_1_prophecy")` fails.

Output:
- `spec_parser.rs` — `convert_deref` gains `in_postcondition: bool` parameter; new public `parse_spec_expr_postcondition_with_db` entry point
- `vcgen.rs` — new private `parse_spec_postcondition` wrapper + use it in the `ensures` loop of `generate_contract_vcs`
- `e2e_verification.rs` — `#[ignore]` removed from `test_prophecy_basic`
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29.2-prophecy-encoding-for-mutable-reference-assignments/29.2-RESEARCH.md

<interfaces>
<!-- Key types and function signatures the executor must know. Extracted from codebase. -->

From crates/analysis/src/spec_parser.rs (current public API):
```rust
// Line 37: existing entry points (must not change signatures — 13+ call sites)
pub fn parse_spec_expr(spec: &str, func: &Function) -> Option<Term>
pub fn parse_spec_expr_with_db(spec: &str, func: &Function, ghost_pred_db: &GhostPredicateDatabase) -> Option<Term>
pub fn parse_spec_expr_qf_lia(spec: &str, func: &Function, ghost_pred_db: &GhostPredicateDatabase) -> Option<Term>

// Line 103: private helpers
fn convert_expr_with_bounds(expr: &Expr, func: &Function, in_old: bool, in_int_mode: bool, bound_vars: &[...]) -> Option<Term>

// Line 128: core internal converter (private, must add in_postcondition param)
fn convert_expr_with_db(
    expr: &Expr, func: &Function,
    in_old: bool, in_int_mode: bool,
    bound_vars: &[(String, Sort)],
    ghost_pred_db: &GhostPredicateDatabase,
    depth: usize,
) -> Option<Term>

// Line 197: how convert_deref is called (from Expr::Unary in convert_expr_with_db):
// return convert_deref(&unary_expr.expr, func, in_old, bound_vars);

// Line 1394: the bug location
fn convert_deref(expr: &Expr, func: &Function, in_old: bool, _bound_vars: &[...]) -> Option<Term>
// Currently: if in_old -> "_initial" else -> param_name  (MISSING in_postcondition)
```

From crates/analysis/src/vcgen.rs:
```rust
// Line 3399: private wrapper used for preconditions and other contexts (must NOT change)
fn parse_spec(spec: &str, func: &Function, ghost_pred_db: &GhostPredicateDatabase) -> Option<Term>

// Line 2013: the only line in the ensures loop that needs updating:
// BEFORE: if let Some(post_term) = parse_spec(&post.raw, func, ghost_pred_db) {
// AFTER:  if let Some(post_term) = parse_spec_postcondition(&post.raw, func, ghost_pred_db) {
```

From crates/analysis/tests/e2e_verification.rs (line 2765):
```rust
#[test]
#[ignore] // TODO: Fix prophecy encoding for mutable reference assignments
fn test_prophecy_basic() {
    // ... creates Function with &mut i32 param _1 and ensures "*_1 == old(*_1)"
    // asserts script_text.contains("_1_initial") && script_text.contains("_1_prophecy")
}
```
</interfaces>
</context>

<tasks>

<task type="tdd">
  <name>Task 1: RED — add spec_parser unit test for postcondition deref resolution</name>
  <files>crates/analysis/src/spec_parser.rs</files>
  <action>
Add a new unit test in the `#[cfg(test)]` block at the bottom of `spec_parser.rs` that confirms the expected behavior after the fix. The test should call `parse_spec_expr_postcondition_with_db` (which does not exist yet) and assert the result contains `_1_prophecy`.

Add after the existing `parse_final_value` test (around line 2163):

```rust
#[test]
fn parse_postcondition_deref_resolves_to_prophecy() {
    // Confirm that *_1 in postcondition context resolves to _1_prophecy
    // This test is RED until parse_spec_expr_postcondition_with_db is implemented
    let func = make_mut_ref_func();
    let ghost_db = GhostPredicateDatabase::new();
    let term = parse_spec_expr_postcondition_with_db("*_1", &func, &ghost_db);
    assert!(
        matches!(term, Some(Term::Const(ref s)) if s == "_1_prophecy"),
        "Expected _1_prophecy, got {:?}", term
    );
}

#[test]
fn parse_postcondition_old_deref_still_resolves_to_initial() {
    // Confirm that old(*_1) in postcondition context still resolves to _1_initial
    let func = make_mut_ref_func();
    let ghost_db = GhostPredicateDatabase::new();
    let term = parse_spec_expr_postcondition_with_db("old(*_1)", &func, &ghost_db);
    assert!(
        matches!(term, Some(Term::Const(ref s)) if s == "_1_initial"),
        "Expected _1_initial, got {:?}", term
    );
}
```

Add a `make_mut_ref_func()` helper in the test module (if not already present):

```rust
fn make_mut_ref_func() -> Function {
    Function {
        name: "f".to_string(),
        params: vec![Local::new("_1", Ty::Ref(Box::new(Ty::Int(IntTy::I32)), Mutability::Mutable))],
        return_local: Local::new("_0", Ty::Unit),
        locals: vec![],
        basic_blocks: vec![],
        contracts: Contracts::default(),
        loops: vec![],
        generic_params: vec![],
        prophecies: vec![],
        lifetime_params: vec![],
        outlives_constraints: vec![],
        borrow_info: vec![],
        reborrow_chains: vec![],
        unsafe_blocks: vec![],
        unsafe_operations: vec![],
        unsafe_contracts: None,
        is_unsafe_fn: false,
        thread_spawns: vec![],
        atomic_ops: vec![],
        sync_ops: vec![],
        lock_invariants: vec![],
        concurrency_config: None,
        source_names: std::collections::HashMap::new(),
        coroutine_info: None,
    }
}
```

Run `cargo test -p analysis parse_postcondition_deref 2>&1 | tail -5` — tests MUST FAIL with "cannot find function `parse_spec_expr_postcondition_with_db`" (compile error = valid RED for TDD with non-existent API).
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p analysis parse_postcondition_deref 2>&1 | grep -E "error|FAILED|failed" | head -5</automated>
  </verify>
  <done>Tests exist and produce a compile error or test failure (RED state confirmed).</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN — implement postcondition-aware deref and remove #[ignore]</name>
  <files>
    crates/analysis/src/spec_parser.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/e2e_verification.rs
  </files>
  <action>
Make the RED tests pass with the following targeted changes:

### A. `spec_parser.rs` — Add `in_postcondition` to `convert_deref`

At line 1394, change the signature of `convert_deref`:

```rust
fn convert_deref(
    expr: &Expr,
    func: &Function,
    in_old: bool,
    in_postcondition: bool,  // NEW
    _bound_vars: &[(String, rust_fv_smtlib::sort::Sort)],
) -> Option<Term>
```

Change the mutable-ref branch body (lines 1412-1421):

```rust
if in_old {
    // old() always wins — captures initial value regardless of postcondition context
    return Some(Term::Const(format!("{param_name}_initial")));
} else if in_postcondition {
    // postcondition context: *param resolves to prophecy variable (final predicted value)
    return Some(Term::Const(format!("{param_name}_prophecy")));
} else {
    // normal context (preconditions, loop invariants): use current value
    return Some(Term::Const(param_name));
}
```

### B. `spec_parser.rs` — Thread `in_postcondition` through `convert_expr_with_db`

Add `in_postcondition: bool` as a new parameter to `convert_expr_with_db` (after `in_old`):

```rust
fn convert_expr_with_db(
    expr: &Expr,
    func: &Function,
    in_old: bool,
    in_postcondition: bool,  // NEW
    in_int_mode: bool,
    bound_vars: &[(String, Sort)],
    ghost_pred_db: &GhostPredicateDatabase,
    depth: usize,
) -> Option<Term>
```

Update the `Expr::Unary` arm where `convert_deref` is called (line 197):

```rust
// Before:
return convert_deref(&unary_expr.expr, func, in_old, bound_vars);
// After:
return convert_deref(&unary_expr.expr, func, in_old, in_postcondition, bound_vars);
```

All recursive calls to `convert_expr_with_db` within the function must pass `in_postcondition` through unchanged (compiler errors will guide each one — pass the existing `in_postcondition` value).

IMPORTANT: The `old()` handler in `convert_call_with_db` calls `convert_expr_with_bounds`. Update `convert_expr_with_bounds` to accept and thread `in_postcondition` too:

```rust
fn convert_expr_with_bounds(
    expr: &Expr, func: &Function,
    in_old: bool, in_postcondition: bool,  // NEW
    in_int_mode: bool,
    bound_vars: &[...],
) -> Option<Term>
```

And inside: `convert_expr_with_db(expr, func, in_old, in_postcondition, in_int_mode, bound_vars, &ghost_db, GHOST_PRED_EXPAND_DEPTH)`.

For the `old()` call site in `convert_call_with_db`, pass `in_postcondition=false` because inside `old()` the postcondition context does not apply (we're asking for the pre-state value, never the prophecy):

```rust
"old" => {
    return convert_expr_with_bounds(
        &call_expr.args[0], func,
        true,   // in_old
        false,  // in_postcondition: inside old() we never want _prophecy
        in_int_mode, bound_vars,
    );
}
```

Update all other callers of `convert_expr_with_bounds` to pass `in_postcondition` unchanged.

All existing entry points (`parse_spec_expr`, `parse_spec_expr_with_db`, `parse_spec_expr_qf_lia`, `parse_spec_expr_with_depth`) must pass `in_postcondition=false` to maintain backward compatibility.

### C. `spec_parser.rs` — Add new public postcondition entry point

Add after `parse_spec_expr_with_db`:

```rust
/// Parse a specification expression in postcondition (ensures) context.
///
/// Identical to `parse_spec_expr_with_db` except that dereferences of mutable
/// reference parameters (`*_1`) resolve to the prophecy variable (`_1_prophecy`)
/// instead of the current value (`_1`). This is correct for `ensures` clauses where
/// `*_1` refers to the final (post-return) value of the mutable reference.
///
/// `old(*_1)` inside a postcondition still resolves to `_1_initial` — `old()` always wins.
pub fn parse_spec_expr_postcondition_with_db(
    spec: &str,
    func: &Function,
    ghost_pred_db: &GhostPredicateDatabase,
) -> Option<Term> {
    let spec = spec.trim();
    if spec.is_empty() {
        return None;
    }
    let expr: syn::Expr = syn::parse_str(spec).ok()?;
    convert_expr_with_db(
        &expr,
        func,
        false,  // in_old
        true,   // in_postcondition — key difference
        false,  // in_int_mode
        &[],
        ghost_pred_db,
        GHOST_PRED_EXPAND_DEPTH,
    )
}
```

### D. `vcgen.rs` — Add `parse_spec_postcondition` private wrapper

After the existing `parse_spec` function (line 3399), add:

```rust
/// Parse a specification expression for use in postcondition (ensures) VCs.
///
/// Uses postcondition-aware deref resolution: `*_1` → `_1_prophecy` for mutable
/// reference params, while `old(*_1)` still resolves to `_1_initial`.
fn parse_spec_postcondition(
    spec: &str,
    func: &Function,
    ghost_pred_db: &GhostPredicateDatabase,
) -> Option<Term> {
    let term = spec_parser::parse_spec_expr_postcondition_with_db(spec, func, ghost_pred_db)
        .or_else(|| parse_simple_spec(spec, func))?;

    match crate::encode_quantifier::annotate_quantifier(term) {
        Ok(annotated_term) => Some(annotated_term),
        Err(trigger_error) => {
            tracing::error!(
                "Trigger validation failed in function {}: {:?}",
                func.name,
                trigger_error
            );
            None
        }
    }
}
```

### E. `vcgen.rs` — Update `generate_contract_vcs` ensures loop

At line 2013, change:

```rust
// BEFORE:
if let Some(post_term) = parse_spec(&post.raw, func, ghost_pred_db) {

// AFTER:
if let Some(post_term) = parse_spec_postcondition(&post.raw, func, ghost_pred_db) {
```

This is the ONLY change to `generate_contract_vcs`. All other `parse_spec` calls (requires loop line 1976, callee postcondition assumptions) remain unchanged.

### F. `e2e_verification.rs` — Remove `#[ignore]`

At line 2765, remove `#[ignore]` and its comment:

```rust
// BEFORE:
#[test]
#[ignore] // TODO: Fix prophecy encoding for mutable reference assignments
fn test_prophecy_basic() {

// AFTER:
#[test]
fn test_prophecy_basic() {
```

### Verify GREEN

Run tests in order:

1. `cargo test -p analysis parse_postcondition_deref` — both new spec_parser unit tests GREEN
2. `cargo test -p analysis test_prophecy_basic` — previously ignored e2e test GREEN
3. `cargo test -p analysis` — full analysis test suite GREEN (no regressions)
4. `cargo clippy -p analysis -- -D warnings` — no clippy warnings
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p analysis test_prophecy_basic parse_postcondition_deref 2>&1 | tail -10</automated>
  </verify>
  <done>
    - `test_prophecy_basic` passes (no `#[ignore]`, GREEN)
    - `parse_postcondition_deref_resolves_to_prophecy` passes (GREEN)
    - `parse_postcondition_old_deref_still_resolves_to_initial` passes (GREEN)
    - `cargo test -p analysis` exits 0 with all tests passing
    - SMT script for the postcondition VC contains both `_1_initial` and `_1_prophecy`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p analysis 2>&1 | tail -5
cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo clippy -p analysis -- -D warnings 2>&1 | tail -5
```

- All analysis tests pass (including `test_prophecy_basic` without `#[ignore]`)
- No clippy warnings
- The `#[ignore]` attribute is absent from `e2e_verification.rs:2765`
</verification>

<success_criteria>
- `test_prophecy_basic` passes (removed from `#[ignore]`)
- `*_1` in ensures context resolves to `Term::Const("_1_prophecy")`
- `old(*_1)` in ensures context resolves to `Term::Const("_1_initial")` (no regression)
- `*_1` in requires context resolves to `Term::Const("_1")` (no regression)
- `cargo test -p analysis` exits 0 — zero test regressions
- `cargo clippy -p analysis -- -D warnings` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/29.2-prophecy-encoding-for-mutable-reference-assignments/29.2-01-SUMMARY.md`
</output>

---
phase: 20-separation-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/sep_logic.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
autonomous: true
requirements:
  - SEP-01

must_haves:
  truths:
    - "Developer writes pts_to(p, v) in #[requires]/#[ensures] and the spec parser produces a well-typed SMT term"
    - "pts_to(p, v) emits (and (select perm p) (= (heapval_as_bvN (select sep_heap p)) v)) to Z3"
    - "The sep_heap and perm arrays are declared in any VC script that contains pts_to"
  artifacts:
    - path: "crates/analysis/src/sep_logic.rs"
      provides: "declare_sep_heap(), declare_heapval_accessor(), encode_pts_to(), sep_logic_smt_logic()"
      exports: ["declare_sep_heap", "declare_heapval_accessor", "encode_pts_to", "sep_logic_smt_logic", "extract_pts_to_footprint"]
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "pts_to() recognized in convert_call; routed to encode_pts_to()"
      contains: "\"pts_to\""
    - path: "crates/analysis/src/lib.rs"
      provides: "pub mod sep_logic declared"
      contains: "sep_logic"
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/analysis/src/sep_logic.rs"
      via: "sep_logic::encode_pts_to() call in convert_call match arm"
      pattern: "encode_pts_to"
    - from: "crates/analysis/src/sep_logic.rs"
      to: "rust_fv_smtlib"
      via: "Sort::Array, Sort::Uninterpreted, Term::Select, Term::And, Term::App"
      pattern: "Sort::Array|Sort::Uninterpreted"
---

<objective>
Create the separation heap domain and pts_to(p, v) predicate encoding.

Purpose: SEP-01 requires that developers can write `pts_to(p, v)` in `#[requires]`/`#[ensures]` to specify raw pointer ownership. This plan creates the sep_heap + perm SMT arrays and wires the spec parser to recognize pts_to() calls and emit the correct Z3 terms.

Output: `sep_logic.rs` (new) with heap declarations and pts_to encoder; `spec_parser.rs` extended with pts_to match arm in convert_call; unit tests covering the pts_to SMT output.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-separation-logic/20-RESEARCH.md

@crates/analysis/src/heap_model.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/lib.rs
@crates/smtlib/src/term.rs
@crates/smtlib/src/sort.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sep_logic.rs with sep_heap domain and pts_to encoder</name>
  <files>crates/analysis/src/sep_logic.rs</files>
  <action>
Create `crates/analysis/src/sep_logic.rs` as a new file with the following items:

**1. `declare_sep_heap() -> Vec<Command>`**
Emit three SMT commands:
- `(declare-sort HeapVal 0)` via `Command::DeclareSort("HeapVal".to_string(), 0)`
- `sep_heap: (Array (_ BitVec 64) HeapVal)` via `Command::DeclareFun` with `Sort::Array(Box::new(Sort::BitVec(64)), Box::new(Sort::Uninterpreted("HeapVal".to_string())))`
- `perm: (Array (_ BitVec 64) Bool)` via `Command::DeclareFun` with `Sort::Array(Box::new(Sort::BitVec(64)), Box::new(Sort::Bool))`

**2. `declare_heapval_accessor(pointee_bits: u32) -> Command`**
Declare `(declare-fun heapval_as_bvN (HeapVal) (_ BitVec N))`.
Name: `format!("heapval_as_bv{}", pointee_bits)`.
Input sorts: `vec![Sort::Uninterpreted("HeapVal".to_string())]`.
Return sort: `Sort::BitVec(pointee_bits)`.

**3. `encode_pts_to(ptr: Term, val: Term, pointee_bits: u32) -> Term`**
Encode `pts_to(p, v)` as `(and perm_check val_eq)` where:
- `perm_check = Term::Select(Box::new(Term::Const("perm")), Box::new(ptr.clone()))`
- `heap_select = Term::Select(Box::new(Term::Const("sep_heap")), Box::new(ptr))`
- `heap_val_typed = Term::App(format!("heapval_as_bv{}", pointee_bits), vec![heap_select])`
- `val_eq = Term::Eq(Box::new(heap_val_typed), Box::new(val))`
- Return `Term::And(vec![perm_check, val_eq])`

**4. `sep_logic_smt_logic(has_frame_forall: bool) -> &'static str`**
Returns `"AUFBV"` when `has_frame_forall` is true (quantifiers present), else `"QF_AUFBV"` (array + BV, no quantifiers).

**5. `extract_pts_to_footprint(spec_term: &Term) -> Vec<Term>`**
Walk a Term tree and collect the first argument (ptr) of every `pts_to` encoding. Since we encode `pts_to` as `Term::And([perm_select, eq_term])` where `perm_select = Term::Select(perm, ptr)`, walk And arms: if the first arm is a `Term::Select` of `"perm"`, the index is the footprint pointer. Return `Vec<Term>` of all such ptr terms. This is used by the frame rule in Plan 03.

Add `#[cfg(test)]` unit tests:
- `test_declare_sep_heap_commands()`: asserts `declare_sep_heap()` returns 3 commands and the first is `DeclareSort`.
- `test_encode_pts_to_structure()`: builds a `ptr = Term::Const("p")`, `val = Term::Const("v")`, calls `encode_pts_to(ptr, val, 32)`, asserts the result is `Term::And` with 2 elements, and the first element is a `Term::Select` referencing `"perm"`.
- `test_sep_logic_smt_logic()`: asserts `sep_logic_smt_logic(false) == "QF_AUFBV"` and `sep_logic_smt_logic(true) == "AUFBV"`.
  </action>
  <verify>cargo test -p rust_fv_analysis sep_logic 2>&1 | tail -5</verify>
  <done>All 3 unit tests pass. File compiles with no warnings (cargo clippy -p rust_fv_analysis -- -D warnings).</done>
</task>

<task type="auto">
  <name>Task 2: Wire pts_to into spec_parser convert_call + declare pub mod in lib.rs</name>
  <files>crates/analysis/src/spec_parser.rs, crates/analysis/src/lib.rs</files>
  <action>
**In `crates/analysis/src/lib.rs`:**
Add `pub mod sep_logic;` alongside the existing module declarations (e.g., after `pub mod heap_model;`).

**In `crates/analysis/src/spec_parser.rs`:**

1. Add import at top of file: `use crate::sep_logic;`

2. In `convert_call()` function, add a `"pts_to"` arm in the `match func_name.as_str()` block (add it BEFORE any wildcard/fallthrough arm):

```rust
"pts_to" => {
    // pts_to(ptr, value) — raw pointer ownership predicate
    if call_expr.args.len() != 2 {
        tracing::warn!("pts_to() requires exactly 2 arguments: pts_to(ptr, val)");
        return None;
    }
    let ptr_term = convert_expr_with_bounds(
        &call_expr.args[0], func, false, in_int_mode, bound_vars,
    )?;
    let val_term = convert_expr_with_bounds(
        &call_expr.args[1], func, false, in_int_mode, bound_vars,
    )?;
    // Determine pointee bit width from pointer parameter type.
    // Look up the first argument name in func.params to find Ty::RawPtr inner width.
    // Default to 64 bits if type cannot be resolved (conservative).
    let pointee_bits = resolve_pointee_bits(&call_expr.args[0], func).unwrap_or(64);
    return Some(sep_logic::encode_pts_to(ptr_term, val_term, pointee_bits));
}
```

3. Add helper `resolve_pointee_bits(arg: &syn::Expr, func: &Function) -> Option<u32>` (private):
   - If arg is `Expr::Path` with single segment, match that name against `func.params` to find a param with `Ty::RawPtr(inner, _)`.
   - Map inner Ty to bit width: `Ty::Int(8) | Ty::Uint(8)` → 8, `Ty::Int(16) | Ty::Uint(16)` → 16, `Ty::Int(32) | Ty::Uint(32)` → 32, `Ty::Int(64) | Ty::Uint(64)` → 64, `Ty::Bool` → 8, everything else → return None.
   - Add `use crate::ir::Ty;` if not already imported.

**Unit tests** (add to spec_parser test section):
- `test_pts_to_parse_basic()`: build a minimal `Function` with a `*const i32` parameter named `p` and an `i32` parameter named `v`, call `parse_spec_expr("pts_to(p, v)", &func)`, assert `Some(Term::And(_))`.
- `test_pts_to_wrong_arity()`: call `parse_spec_expr("pts_to(p)", &func)`, assert `None`.

Run `cargo clippy -p rust_fv_analysis -- -D warnings` after changes to fix any lint issues before declaring done.
  </action>
  <verify>cargo test -p rust_fv_analysis -- test_pts_to 2>&1 | tail -10</verify>
  <done>Both pts_to parser tests pass. cargo clippy -p rust_fv_analysis -- -D warnings produces zero warnings. cargo test -p rust_fv_analysis produces no new failures.</done>
</task>

</tasks>

<verification>
1. `cargo build -p rust_fv_analysis 2>&1 | grep -c error` outputs `0`
2. `cargo test -p rust_fv_analysis sep_logic 2>&1` — all 3 sep_logic tests pass
3. `cargo test -p rust_fv_analysis -- test_pts_to 2>&1` — both pts_to parser tests pass
4. `cargo clippy -p rust_fv_analysis -- -D warnings 2>&1 | grep -c warning` outputs `0`
</verification>

<success_criteria>
- `crates/analysis/src/sep_logic.rs` exists with all 5 public functions
- `pts_to()` in a spec string returns `Some(Term::And([Select(perm, ptr), Eq(...)]))` from `parse_spec_expr`
- `declare_sep_heap()` returns exactly 3 commands (DeclareSort, 2x DeclareFun)
- All existing analysis tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/20-separation-logic/20-01-SUMMARY.md` following the summary template.
</output>

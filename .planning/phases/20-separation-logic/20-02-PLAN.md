---
phase: 20-separation-logic
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/macros/src/lib.rs
  - crates/analysis/src/ghost_predicate_db.rs
  - crates/driver/src/callbacks.rs
autonomous: true
requirements:
  - SEP-04

must_haves:
  truths:
    - "Developer annotates a fn with #[ghost_predicate] and the crate compiles without errors"
    - "The GhostPredicateDatabase receives the predicate name, param names, and body text from callbacks.rs during after_analysis"
    - "GhostPredicateDatabase::get(name) returns the stored GhostPredicate for a registered predicate"
  artifacts:
    - path: "crates/macros/src/lib.rs"
      provides: "#[ghost_predicate] proc-macro attribute serializing fn body as doc attribute"
      contains: "ghost_predicate"
    - path: "crates/analysis/src/ghost_predicate_db.rs"
      provides: "GhostPredicateDatabase struct with insert/get/contains"
      exports: ["GhostPredicateDatabase", "GhostPredicate"]
    - path: "crates/driver/src/callbacks.rs"
      provides: "extract_contracts extended to populate GhostPredicateDatabase from ghost_predicate doc attrs"
      contains: "rust_fv::ghost_predicate::"
  key_links:
    - from: "crates/macros/src/lib.rs"
      to: "crates/driver/src/callbacks.rs"
      via: "doc attribute format: rust_fv::ghost_predicate::name::params::body"
      pattern: "rust_fv::ghost_predicate::"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/ghost_predicate_db.rs"
      via: "GhostPredicateDatabase::insert() called from extract_contracts"
      pattern: "ghost_predicate_db.insert"
---

<objective>
Add the #[ghost_predicate] proc-macro and GhostPredicateDatabase extraction infrastructure.

Purpose: SEP-04 requires that developers can define recursive heap predicates via `#[ghost_predicate]`. This plan creates the proc-macro attribute (serializes the fn body), the in-memory database type, and the callbacks.rs extraction logic. The spec parser wiring (actually calling predicates in specs) is done in Plan 03 which depends on both Plan 01 and Plan 02.

Output: `#[ghost_predicate]` macro in macros crate; `ghost_predicate_db.rs` (new); callbacks.rs extended to populate the DB.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-separation-logic/20-RESEARCH.md

@crates/macros/src/lib.rs
@crates/driver/src/callbacks.rs
@crates/analysis/src/contract_db.rs
@crates/analysis/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add #[ghost_predicate] proc-macro to macros crate</name>
  <files>crates/macros/src/lib.rs</files>
  <action>
In `crates/macros/src/lib.rs`, add the `ghost_predicate` proc-macro attribute following the exact same pattern as the existing `spec_attribute` helper (lines ~242-258).

**Add public macro entry point** (alongside `#[requires]`, `#[ensures]`, etc.):

```rust
/// Marks a function as a ghost predicate for separation logic specs.
///
/// The function body is serialized as a hidden doc attribute so the
/// driver can extract and store it in the GhostPredicateDatabase.
/// Ghost predicates may be recursive; the verifier unfolds them to depth 3.
///
/// # Example
/// ```rust
/// #[ghost_predicate]
/// fn linked_list(p: *const Node, n: usize) -> bool {
///     if n == 0 { p.is_null() } else { pts_to(p, *p) && linked_list((*p).next, n - 1) }
/// }
/// ```
#[proc_macro_attribute]
pub fn ghost_predicate(attr: TokenStream, item: TokenStream) -> TokenStream {
    ghost_predicate_impl(proc_macro2::TokenStream::from(attr),
                         proc_macro2::TokenStream::from(item)).into()
}
```

**Add `ghost_predicate_impl` function** (place near `spec_attribute` helper):

```rust
fn ghost_predicate_impl(
    _attr: proc_macro2::TokenStream,
    item: proc_macro2::TokenStream,
) -> proc_macro2::TokenStream {
    let func: syn::ItemFn = match syn::parse2(item.clone()) {
        Ok(f) => f,
        Err(err) => return err.to_compile_error(),
    };

    let fn_name = func.sig.ident.to_string();
    // Serialize param names as comma-separated string
    let param_names: Vec<String> = func.sig.inputs.iter().filter_map(|arg| {
        if let syn::FnArg::Typed(pat_ty) = arg {
            if let syn::Pat::Ident(ident) = &*pat_ty.pat {
                return Some(ident.ident.to_string());
            }
        }
        None
    }).collect();
    let params_str = param_names.join(",");
    // Serialize the function body as token stream string
    let body_str = func.block.to_token_stream().to_string();
    // Format: "rust_fv::ghost_predicate::name::params::body"
    let doc_value = format!("rust_fv::ghost_predicate::{}::{}::{}", fn_name, params_str, body_str);

    quote::quote! {
        #[doc(hidden)]
        #[doc = #doc_value]
        #item
    }
}
```

**IMPORTANT**: The `item` is emitted unchanged (the function remains in the codebase for normal compilation). The doc attribute is `#[doc(hidden)]` so it does not appear in rustdoc. The doc format uses `::` separators with `splitn(3, "::")` in callbacks.rs to split `name::params::body` — use exactly 3 parts split by `::` with `splitn(4, "::")` (skip the `ghost_predicate` prefix), resulting in `[name, params, body]`.

Wait — re-check: The prefix stripped by callbacks.rs will be `"rust_fv::ghost_predicate::"`. After stripping, the remaining string is `"name::params::body"`. Use `splitn(3, "::")` to get `["name", "params", "body"]`. Ensure the format string in `doc_value` uses exactly two `::` separators between name, params, and body: `format!("rust_fv::ghost_predicate::{}::{}::{}", fn_name, params_str, body_str)`.

Add `#[cfg(test)]` tests in the macros crate (in `ghost_predicate_impl` test):
- `test_ghost_predicate_macro()`: calls `ghost_predicate_impl(quote::quote!{}, quote::quote!{ fn foo(p: *const i32, n: usize) -> bool { true } })`, converts result to string, asserts it contains `"rust_fv::ghost_predicate::foo"` and `"p,n"`.
  </action>
  <verify>cargo test -p rust_fv_macros 2>&1 | tail -10</verify>
  <done>ghost_predicate macro test passes. cargo build -p rust_fv_macros succeeds with zero errors. cargo clippy -p rust_fv_macros -- -D warnings produces zero warnings.</done>
</task>

<task type="auto">
  <name>Task 2: Create GhostPredicateDatabase and wire callbacks.rs extraction</name>
  <files>crates/analysis/src/ghost_predicate_db.rs, crates/analysis/src/lib.rs, crates/driver/src/callbacks.rs</files>
  <action>
**Step 1 — Create `crates/analysis/src/ghost_predicate_db.rs`:**

```rust
//! Database of user-defined ghost predicates for bounded unfolding in separation logic.
//!
//! Ghost predicates are registered via #[ghost_predicate] and stored here
//! for use by the spec parser during VC generation.
use std::collections::HashMap;

/// A single registered ghost predicate.
#[derive(Debug, Clone)]
pub struct GhostPredicate {
    /// Formal parameter names (e.g., ["p", "n"])
    pub param_names: Vec<String>,
    /// Raw body string as serialized by the ghost_predicate proc-macro
    pub body_raw: String,
}

/// Maps predicate name → GhostPredicate for bounded unfolding.
///
/// Built by callbacks.rs during after_analysis() from doc attributes,
/// then passed into the spec parser to expand ghost predicate calls.
#[derive(Debug, Clone, Default)]
pub struct GhostPredicateDatabase {
    predicates: HashMap<String, GhostPredicate>,
}

impl GhostPredicateDatabase {
    pub fn new() -> Self { Self::default() }

    /// Register a ghost predicate.
    pub fn insert(&mut self, name: String, pred: GhostPredicate) {
        self.predicates.insert(name, pred);
    }

    /// Look up a ghost predicate by name.
    pub fn get(&self, name: &str) -> Option<&GhostPredicate> {
        self.predicates.get(name)
    }

    /// Check if a predicate is registered.
    pub fn contains(&self, name: &str) -> bool {
        self.predicates.contains_key(name)
    }

    /// Number of registered predicates.
    pub fn len(&self) -> usize { self.predicates.len() }

    /// True if no predicates are registered.
    pub fn is_empty(&self) -> bool { self.predicates.is_empty() }
}
```

Add `pub mod ghost_predicate_db;` to `crates/analysis/src/lib.rs`.

**Step 2 — Extend `crates/driver/src/callbacks.rs`:**

In `extract_contracts()`:
1. Add a `ghost_predicate_db: GhostPredicateDatabase` local variable initialized to `GhostPredicateDatabase::new()`.
2. In the doc attribute parsing loop, add a new branch after the existing `rust_fv::decreases::` branch:

```rust
} else if let Some(pred_spec) = doc.strip_prefix("rust_fv::ghost_predicate::") {
    // Format after prefix: "fn_name::param1,param2::body_tokens"
    let parts: Vec<&str> = pred_spec.splitn(3, "::").collect();
    if parts.len() == 3 {
        let pred_name = parts[0].to_string();
        let param_names: Vec<String> = parts[1]
            .split(',')
            .filter(|s| !s.is_empty())
            .map(|s| s.to_string())
            .collect();
        let body_raw = parts[2].to_string();
        ghost_predicate_db.insert(
            pred_name,
            rust_fv_analysis::ghost_predicate_db::GhostPredicate { param_names, body_raw },
        );
    }
}
```

3. Update the `extract_contracts` return type to return `(HashMap<LocalDefId, Contracts>, GhostPredicateDatabase)` instead of just the map. Update all call sites of `extract_contracts` in `callbacks.rs` accordingly. If `GhostPredicateDatabase` is not yet used downstream (Plan 03 wires it into the spec parser), simply store it in the `AnalysisCallbacks` struct or a local variable for now.

   If changing the return type causes too many call-site ripple effects, instead make `ghost_predicate_db` a field on the struct that holds it (e.g., `AnalysisCallbacks` or the equivalent driver struct), so it is accessible during VC generation. Look at how `ContractDatabase` is threaded through from callbacks to vcgen and follow the same pattern.

Add `use rust_fv_analysis::ghost_predicate_db::GhostPredicateDatabase;` to callbacks.rs imports.

**Unit tests in ghost_predicate_db.rs:**
- `test_insert_and_get()`: insert a predicate with name "foo", params ["p", "n"], body "true", assert `contains("foo")`, `get("foo").unwrap().param_names == vec!["p", "n"]`.
- `test_empty_db()`: assert `GhostPredicateDatabase::new().is_empty()`.
  </action>
  <verify>cargo test -p rust_fv_analysis ghost_predicate_db 2>&1 | tail -10 && cargo build -p rust_fv_driver 2>&1 | grep -c error</verify>
  <done>Both ghost_predicate_db tests pass. cargo build -p rust_fv_driver succeeds (0 errors). cargo clippy -p rust_fv_analysis -p rust_fv_driver -- -D warnings produces zero warnings.</done>
</task>

</tasks>

<verification>
1. `cargo build -p rust_fv_macros 2>&1 | grep -c error` → `0`
2. `cargo build -p rust_fv_driver 2>&1 | grep -c error` → `0`
3. `cargo test -p rust_fv_macros 2>&1` — ghost_predicate macro test passes
4. `cargo test -p rust_fv_analysis ghost_predicate_db 2>&1` — 2 tests pass
5. `cargo clippy -p rust_fv_macros -p rust_fv_analysis -p rust_fv_driver -- -D warnings 2>&1 | grep -c warning` → `0`
</verification>

<success_criteria>
- `#[ghost_predicate]` attribute macro exists in macros crate and compiles
- A function annotated with `#[ghost_predicate]` emits a doc attribute matching `rust_fv::ghost_predicate::name::params::body`
- `GhostPredicateDatabase` struct exists in `ghost_predicate_db.rs` with insert/get/contains
- `callbacks.rs` parses `rust_fv::ghost_predicate::` prefixed doc attrs and populates the DB
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/20-separation-logic/20-02-SUMMARY.md` following the summary template.
</output>

---
phase: 20-separation-logic
plan: 03
type: execute
wave: 2
depends_on:
  - 20-01
  - 20-02
files_modified:
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/sep_logic.rs
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements:
  - SEP-02
  - SEP-03
  - SEP-04

must_haves:
  truths:
    - "Developer writes H1 * H2 where both sides are pts_to() calls and it is encoded as separating conjunction, not BvMul"
    - "Developer writes linked_list(p, n) in a spec and the verifier inlines the body to depth 3 before passing to Z3"
    - "A function with pts_to in requires gets a frame axiom asserting sep_heap is unchanged outside the footprint after the call"
    - "VCs containing sep-logic terms use AUFBV or QF_AUFBV logic (not QF_BV)"
  artifacts:
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "BinOp::Mul sep-conj detection; ghost predicate call expansion with depth counter"
      contains: "is_sep_logic_formula"
    - path: "crates/analysis/src/sep_logic.rs"
      provides: "build_frame_axiom() with trigger annotation"
      contains: "build_frame_axiom"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "frame axiom emission at call sites with sep-logic contracts; SMT logic upgrade to AUFBV"
      contains: "sep_logic::build_frame_axiom"
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/analysis/src/sep_logic.rs"
      via: "encode_pts_to() reused for sep-conj sub-expressions; extract_pts_to_footprint() used for frame"
      pattern: "sep_logic::extract_pts_to_footprint"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/sep_logic.rs"
      via: "build_frame_axiom() called at call sites with sep-logic contracts; sep_logic_smt_logic() for logic selection"
      pattern: "sep_logic::build_frame_axiom|sep_logic::sep_logic_smt_logic"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "ghost_pred_db field on AnalysisCallbacks passed into generate_vcs so spec_parser can expand ghost predicate calls"
      pattern: "ghost_pred_db"
---

<objective>
Wire separating conjunction, ghost predicate expansion, frame rule, and SMT logic selection.

Purpose: This plan completes the remaining three requirements. SEP-02 (separating conjunction) needs the `*` operator to be recognized as sep-conj when both sides are heap predicates. SEP-04 (ghost predicates) needs bounded inlining in the spec parser. SEP-03 (frame rule) needs vcgen.rs to emit a frame axiom at call sites with sep-logic contracts.

Output: `spec_parser.rs` extended for sep-conj + ghost predicate expansion; `sep_logic.rs` extended with `build_frame_axiom()`; `vcgen.rs` extended with frame emission + AUFBV logic selection at call sites.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-separation-logic/20-RESEARCH.md
@.planning/phases/20-separation-logic/20-01-SUMMARY.md
@.planning/phases/20-separation-logic/20-02-SUMMARY.md

@crates/analysis/src/spec_parser.rs
@crates/analysis/src/sep_logic.rs
@crates/analysis/src/vcgen.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Separating conjunction detection + ghost predicate expansion in spec_parser.rs; build_frame_axiom in sep_logic.rs</name>
  <files>crates/analysis/src/spec_parser.rs, crates/analysis/src/sep_logic.rs</files>
  <action>
**Part A — `sep_logic.rs`: add `build_frame_axiom()`**

Add to `crates/analysis/src/sep_logic.rs`:

```rust
/// Build the frame axiom asserting that sep_heap is unchanged for all addresses
/// outside the given footprint after a function call.
///
/// Emits:
///   (forall ((_sep_frame_addr (_ BitVec 64)))
///     (! (=> (not (or (= _sep_frame_addr p1) ...))
///            (= (select sep_heap _sep_frame_addr) (select sep_heap_pre _sep_frame_addr)))
///        :pattern ((select sep_heap _sep_frame_addr))))
///
/// The :pattern trigger tells Z3's E-matching to only instantiate this forall
/// when a sep_heap select term is present, avoiding quantifier looping.
pub fn build_frame_axiom(footprint_ptrs: &[Term]) -> Term {
    let addr_var = "_sep_frame_addr".to_string();

    // not_in_fp: addr is not one of the footprint pointers
    let not_in_fp: Term = if footprint_ptrs.is_empty() {
        Term::BoolLit(true)
    } else {
        let in_fp: Vec<Term> = footprint_ptrs.iter().map(|p| {
            Term::Eq(
                Box::new(Term::Const(addr_var.clone())),
                Box::new(p.clone()),
            )
        }).collect();
        Term::Not(Box::new(if in_fp.len() == 1 {
            in_fp.into_iter().next().unwrap()
        } else {
            Term::Or(in_fp)
        }))
    };

    // sep_heap unchanged: (= (select sep_heap addr) (select sep_heap_pre addr))
    let post_select = Term::Select(
        Box::new(Term::Const("sep_heap".to_string())),
        Box::new(Term::Const(addr_var.clone())),
    );
    let pre_select = Term::Select(
        Box::new(Term::Const("sep_heap_pre".to_string())),
        Box::new(Term::Const(addr_var.clone())),
    );
    let heap_unchanged = Term::Eq(Box::new(post_select.clone()), Box::new(pre_select));

    let body = Term::Implies(Box::new(not_in_fp), Box::new(heap_unchanged));

    // Trigger: :pattern ((select sep_heap addr)) for E-matching efficiency
    let trigger = post_select; // reuse the post-call select term as the pattern
    let annotated = Term::Annotated(
        Box::new(body),
        vec![("pattern".to_string(), vec![trigger])],
    );

    Term::Forall(
        vec![(addr_var, rust_fv_smtlib::sort::Sort::BitVec(64))],
        Box::new(annotated),
    )
}
```

Add unit test `test_build_frame_axiom_empty_footprint()`: calls `build_frame_axiom(&[])`, asserts result is `Term::Forall`.

**Part B — `spec_parser.rs`: separating conjunction + ghost predicate expansion**

The spec parser needs access to the `GhostPredicateDatabase`. Update the parser's entry points to accept an optional `ghost_pred_db` parameter. Follow the same pattern as `bound_vars` threading through the call chain.

1. **Add `is_sep_logic_formula(expr: &syn::Expr, ghost_pred_db: &GhostPredicateDatabase) -> bool`:**
   - Returns true if expr is a `syn::ExprCall` whose function name is `"pts_to"` OR is a name present in `ghost_pred_db`.
   - Returns false otherwise.

2. **In `convert_binop` (or the `*` branch of the expression converter), add sep-conj detection:**
   Find where `BinOp::Mul` is handled. Add a check before the bitvector multiply path:

   ```rust
   syn::BinOp::Mul(_) => {
       // Check if this is separating conjunction (H1 * H2)
       // rather than integer multiplication. Applies when at least one
       // operand is a sep-logic formula (pts_to call or ghost predicate).
       if is_sep_logic_formula(&left_expr, ghost_pred_db)
           || is_sep_logic_formula(&right_expr, ghost_pred_db)
       {
           let lhs = convert_expr_with_bounds(&left_expr, func, in_old, in_int_mode, bound_vars, ghost_pred_db, depth)?;
           let rhs = convert_expr_with_bounds(&right_expr, func, in_old, in_int_mode, bound_vars, ghost_pred_db, depth)?;
           // Separating conjunction: both assertions hold.
           // Disjointness is enforced by the single perm array in the heap model.
           return Some(Term::And(vec![lhs, rhs]));
       }
       // Fall through to normal BvMul encoding
       // ...existing bitvector multiply code...
   }
   ```

   Note: `left_expr` and `right_expr` are the unevaluated `syn::Expr` arguments. The check must happen on the syntactic form before conversion.

3. **In `convert_call`, add ghost predicate expansion** (add after the `"pts_to"` arm added in Plan 01):

   ```rust
   fname if ghost_pred_db.contains(fname) => {
       // Ghost predicate call: inline with bounded depth
       if depth == 0 {
           // Depth exhausted: conservative — predicate body unknown
           tracing::debug!("Ghost predicate '{}' depth exhausted, returning false", fname);
           return Some(Term::BoolLit(false));
       }
       let pred = ghost_pred_db.get(fname).unwrap().clone();
       if call_expr.args.len() != pred.param_names.len() {
           tracing::warn!(
               "Ghost predicate '{}' expects {} args, got {}",
               fname, pred.param_names.len(), call_expr.args.len()
           );
           return None;
       }
       // Substitute formal params with actual argument token strings
       let mut body = pred.body_raw.clone();
       for (param, arg_expr) in pred.param_names.iter().zip(call_expr.args.iter()) {
           let arg_str = arg_expr.to_token_stream().to_string();
           // Replace whole-word occurrences of param with arg_str
           // Use a simple replace (sufficient for Phase 20 bounded scope)
           body = body.replace(param.as_str(), &arg_str);
       }
       // Re-parse with depth decremented to prevent stack overflow
       return parse_spec_expr_with_depth(&body, func, ghost_pred_db, depth - 1);
   }
   ```

4. **Thread `ghost_pred_db` and `depth` through the call chain:**
   - Add `ghost_pred_db: &GhostPredicateDatabase` and `depth: usize` parameters to `convert_call`, `convert_expr_with_bounds`, and the internal recursive helpers.
   - Update `parse_spec_expr` (the public API) to accept an optional `ghost_pred_db: Option<&GhostPredicateDatabase>` and pass it through with an initial `depth = 3`.
   - Add a backward-compatible `parse_spec_expr` wrapper: keep the existing 2-arg signature calling the new 3-arg version with `ghost_pred_db = None` (or an empty DB).
   - Add `parse_spec_expr_with_db(spec: &str, func: &Function, db: &GhostPredicateDatabase) -> Option<Term>` as a new public function.
   - Add `parse_spec_expr_with_depth` as a private helper.

   **IMPORTANT**: Avoid breaking existing call sites in `vcgen.rs` that call `parse_spec(&str, &Function)`. If the signature changes are extensive, use a module-level static empty DB `static EMPTY_GHOST_DB: GhostPredicateDatabase = ...` and use it as the default.

5. **Add unit tests:**
   - `test_sep_conj_pts_to_star_pts_to()`: spec `"pts_to(p, v) * pts_to(q, w)"` with 4 params, asserts `Some(Term::And([_, _]))`.
   - `test_mul_not_sep_conj()`: spec `"x * y"` with int params, asserts result is NOT `Term::And` (is `BvMul` encoding).
   - `test_ghost_predicate_depth_zero()`: build a minimal ghost_pred_db with `"foo"` predicate, call with `depth=0`, assert `Some(Term::BoolLit(false))`.
  </action>
  <verify>cargo test -p rust_fv_analysis -- test_sep_conj test_ghost_predicate test_build_frame_axiom 2>&1 | tail -15</verify>
  <done>All 4 new tests pass. cargo clippy -p rust_fv_analysis -- -D warnings produces zero warnings. cargo test -p rust_fv_analysis produces no regressions in existing tests.</done>
</task>

<task type="auto">
  <name>Task 2: Frame rule emission + AUFBV logic selection in vcgen.rs</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Extend `generate_call_site_vcs()` in `crates/analysis/src/vcgen.rs` to:

**0. Source of GhostPredicateDatabase:**
The `GhostPredicateDatabase` is available as the `ghost_pred_db` field on the `AnalysisCallbacks` struct (populated by Plan 02). When `generate_vcs` (or its caller in the driver) is invoked, pass `&callbacks.ghost_pred_db` through to any spec parsing calls that need ghost predicate expansion. Do NOT reconstruct a new empty DB inside vcgen.rs — always read `ghost_pred_db` from the `AnalysisCallbacks` instance that was built by callbacks.rs during `after_analysis`.

**1. Detect sep-logic contracts:**
Add a helper `fn has_sep_logic_spec(contracts: &Contracts) -> bool` that checks if any `requires` or `ensures` `SpecExpr.raw` strings contain the substring `"pts_to("`. This is a cheap syntactic check sufficient for Phase 20.

**2. Add sep_heap pre-call snapshot declaration:**
When `has_sep_logic_spec` is true for the callee, before the frame axiom assertion:
- Declare `sep_heap_pre` as an SMT constant: `Command::DeclareFun("sep_heap_pre", vec![], Sort::Array(Box::new(Sort::BitVec(64)), Box::new(Sort::Uninterpreted("HeapVal"))))`
- Assert `(= sep_heap_pre sep_heap)` to snapshot the heap before the call: `Command::Assert(Term::Eq(Box::new(Term::Const("sep_heap_pre")), Box::new(Term::Const("sep_heap"))))`

**3. Prepend sep_heap declarations:**
When `has_sep_logic_spec` is true, prepend `sep_logic::declare_sep_heap()` commands to the script (after `SetLogic`, before other declarations). Also declare the HeapVal accessor for 64-bit pointers: `sep_logic::declare_heapval_accessor(64)` as the default accessor.

**4. Emit frame axiom:**
After encoding callee postcondition assumptions, when `has_sep_logic_spec` is true:
- Extract the footprint from the callee's `requires` spec terms by calling `sep_logic::extract_pts_to_footprint()` on each parsed requires term.
- Build the frame axiom: `let frame = sep_logic::build_frame_axiom(&footprint_ptrs);`
- Append to the script: `script.push(Command::Assert(frame));`

**5. Upgrade SMT logic for sep-logic VCs:**
In `generate_call_site_vcs()`, after building the base script, when `has_sep_logic_spec` is true:
- The script starts with `SetLogic("QF_BV")` from `base_script()`. Replace it with `SetLogic(sep_logic::sep_logic_smt_logic(true).to_string())` (use `true` since the frame forall quantifier is present).
- Use the existing `replace_set_logic(script, new_logic)` helper already present in vcgen.rs (grep confirms it exists at line ~854).

Similarly, for postcondition VCs (`generate_postcondition_vcs()` or similar): when the function's own contracts contain sep-logic predicates, upgrade the logic from `QF_BV` to `sep_logic::sep_logic_smt_logic(false)` (`"QF_AUFBV"` — no frame forall for postcondition VCs). Apply the same `replace_set_logic()` pattern.

Also prepend `sep_logic::declare_sep_heap()` commands to the VC script for any function whose `requires`/`ensures` contains `"pts_to("`.

**6. Add imports:**
Add `use crate::sep_logic;` at the top of vcgen.rs (alongside existing `use crate::...` imports).

**Unit test** (add in vcgen.rs test module):
- `test_sep_logic_call_site_vc_uses_aufbv()`: Build a caller and callee IR where the callee has `#[requires(pts_to(p, v))]`. Generate call-site VCs. Assert the script contains `AUFBV` in the logic command and contains `sep_heap` declaration.
  </action>
  <verify>cargo test -p rust_fv_analysis -- test_sep_logic_call_site 2>&1 | tail -10 && cargo build -p rust_fv_analysis 2>&1 | grep -c error</verify>
  <done>The vcgen sep-logic call site test passes. cargo build -p rust_fv_analysis produces 0 errors. cargo clippy -p rust_fv_analysis -- -D warnings produces 0 warnings. cargo test -p rust_fv_analysis shows no regressions.</done>
</task>

</tasks>

<verification>
1. `cargo build -p rust_fv_analysis 2>&1 | grep -c error` → `0`
2. `cargo test -p rust_fv_analysis -- test_sep_conj test_ghost_predicate test_build_frame_axiom test_sep_logic_call_site 2>&1` — all new tests pass
3. `cargo test -p rust_fv_analysis 2>&1 | grep FAILED` → empty (no regressions)
4. `cargo clippy -p rust_fv_analysis -- -D warnings 2>&1 | grep -c warning` → `0`
</verification>

<success_criteria>
- `pts_to(p, v) * pts_to(q, w)` in a spec produces `Term::And([pts_to_encoding, pts_to_encoding])`, not `BvMul`
- `x * y` where x and y are integers still produces bitvector multiply (no regression)
- A callee with `pts_to` in `requires` causes the call-site VC to use `AUFBV` logic, include `sep_heap` / `perm` declarations, and include a frame forall axiom
- Ghost predicate calls expand to their body at depth 1-3 and return `BoolLit(false)` at depth 0
- vcgen.rs reads `ghost_pred_db` from the `AnalysisCallbacks` struct field (not a locally constructed empty DB)
- All existing vcgen tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-separation-logic/20-03-SUMMARY.md` following the summary template.
</output>

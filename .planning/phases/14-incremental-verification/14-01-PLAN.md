---
phase: 14-incremental-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/driver/src/cache.rs
  - crates/driver/src/invalidation.rs
  - crates/analysis/src/call_graph.rs
  - Cargo.toml
  - crates/driver/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Each function has separate MIR hash and contract hash in cache"
    - "Changing function body only invalidates that function's cache"
    - "Changing function contract invalidates that function and all transitive callers"
    - "Cache entries older than 30 days are evicted on load"
    - "Invalidation reason is tracked for every re-verification decision"
  artifacts:
    - path: "crates/driver/src/cache.rs"
      provides: "Dual-hash CacheEntry with mir_hash, contract_hash, timestamp, dependencies"
      contains: "mir_hash"
    - path: "crates/driver/src/invalidation.rs"
      provides: "InvalidationReason enum and should_verify decision logic"
      exports: ["InvalidationReason", "InvalidationDecision"]
    - path: "crates/analysis/src/call_graph.rs"
      provides: "transitive_callers method for reverse dependency computation"
      contains: "transitive_callers"
  key_links:
    - from: "crates/driver/src/invalidation.rs"
      to: "crates/driver/src/cache.rs"
      via: "imports CacheEntry for hash comparison"
      pattern: "use.*cache.*CacheEntry"
    - from: "crates/driver/src/invalidation.rs"
      to: "crates/analysis/src/call_graph.rs"
      via: "uses transitive_callers for contract change propagation"
      pattern: "transitive_callers"
---

<objective>
Implement dual-hash cache infrastructure and transitive invalidation engine for incremental verification.

Purpose: Enable precise cache invalidation where MIR-only changes skip re-verifying callers while contract changes propagate transitively -- the foundation for <1s re-verification.
Output: Extended CacheEntry with dual hashes, InvalidationReason tracking, reverse call graph for transitive callers, age-based eviction (30-day TTL).
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-incremental-verification/14-CONTEXT.md
@.planning/phases/14-incremental-verification/14-RESEARCH.md
@crates/driver/src/cache.rs
@crates/analysis/src/call_graph.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CacheEntry with dual hashes, timestamps, and invalidation module</name>
  <files>
    crates/driver/src/cache.rs
    crates/driver/src/invalidation.rs
    Cargo.toml
    crates/driver/Cargo.toml
  </files>
  <action>
    1. Add `chrono = "0.4"` to workspace Cargo.toml [workspace.dependencies] and to crates/driver/Cargo.toml [dependencies] (as `chrono.workspace = true`).

    2. Extend `CacheEntry` in cache.rs with new fields (use `#[serde(default)]` for backward compatibility with old cache files):
       - `mir_hash: [u8; 32]` -- hash of function body only (name + IR debug repr)
       - `contract_hash: [u8; 32]` -- hash of contracts only (requires/ensures/invariants/pure/decreases)
       - `timestamp: i64` -- Unix timestamp (UTC) when entry was created, default 0
       - `dependencies: Vec<String>` -- function names this function calls (from call graph)

    3. Add `compute_mir_hash(func_name: &str, ir_debug: &str) -> [u8; 32]` to VcCache -- hashes function name + IR debug representation.

    4. Add `compute_contract_hash(func_name: &str, contracts: &Contracts) -> [u8; 32]` to VcCache -- hashes function name + all spec expressions (requires, ensures, invariants, pure flag, decreases).

    5. Keep existing `compute_key` method for backward compatibility but mark it `#[deprecated(note = "Use compute_mir_hash + compute_contract_hash instead")]`.

    6. Update `insert` method to use `chrono::Utc::now().timestamp()` for the timestamp field.

    7. Update `load` method to perform age-based eviction: skip entries where `now - timestamp > 30 * 24 * 60 * 60` (30 days). Delete the corresponding JSON file from disk when evicting. Use lazy eviction (check during load, not periodic).

    8. Create new module `crates/driver/src/invalidation.rs`:
       - `InvalidationReason` enum: `MirChanged`, `ContractChanged { dependency: String }`, `Fresh`, `CacheMiss`, `Expired`
       - `InvalidationDecision` struct: `should_verify: bool`, `reason: Option<InvalidationReason>`
       - `fn decide_verification(cache: &VcCache, func_name: &str, mir_hash: [u8; 32], contract_hash: [u8; 32], fresh: bool, changed_contracts: &HashSet<String>, dependencies: &[String]) -> InvalidationDecision`
         - If `fresh` flag set: return should_verify=true, reason=Fresh
         - If no cache entry: return should_verify=true, reason=CacheMiss
         - If entry expired (30 days): return should_verify=true, reason=Expired
         - If mir_hash differs: return should_verify=true, reason=MirChanged
         - If contract_hash differs: return should_verify=true, reason=ContractChanged{self}
         - If any dependency is in changed_contracts set: return should_verify=true, reason=ContractChanged{dependency name}
         - Otherwise: return should_verify=false, reason=None (cache hit)

    9. Add `mod invalidation;` to main.rs.

    10. Write comprehensive unit tests in both cache.rs and invalidation.rs:
        - Test dual-hash computation is deterministic
        - Test MIR hash changes when body changes, unchanged when contracts change
        - Test contract hash changes when contracts change, unchanged when body changes
        - Test age-based eviction removes old entries
        - Test age-based eviction keeps recent entries
        - Test all InvalidationReason variants
        - Test decide_verification for each invalidation path
        - Test backward compatibility: loading old cache entries (missing new fields) uses serde defaults
  </action>
  <verify>
    `cargo test -p rust-fv-driver -- cache:: invalidation:: --nocapture` passes all tests.
    `cargo clippy -p rust-fv-driver -- -D warnings` has no warnings.
  </verify>
  <done>
    CacheEntry has mir_hash, contract_hash, timestamp, dependencies fields.
    compute_mir_hash and compute_contract_hash produce separate deterministic hashes.
    invalidation.rs decide_verification correctly returns all 6 InvalidationReason variants.
    Age-based eviction removes entries older than 30 days during load.
    All tests pass including backward compatibility with old cache format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add transitive_callers to CallGraph for reverse dependency computation</name>
  <files>
    crates/analysis/src/call_graph.rs
  </files>
  <action>
    1. Add `transitive_callers(&self, func_name: &str) -> Vec<String>` method to CallGraph:
       - Build reverse edges (callee -> list of callers) from existing `edges` map, filtering to only functions in `all_functions`
       - BFS from func_name through reverse edges
       - Track visited set to handle cycles (recursive functions)
       - Return all transitively reachable callers (excluding func_name itself)

    2. Add `direct_callees(&self, func_name: &str) -> Vec<String>` method -- returns the direct callees of a function (from edges map), filtered to only functions in `all_functions`. This is needed by the cache to record dependencies.

    3. Add `changed_contract_functions(&self, all_functions: &[(String, [u8; 32])], cache: &impl Fn(&str) -> Option<[u8; 32]>) -> HashSet<String>` method:
       - For each function, compare its current contract hash against the cached contract hash
       - If different, add it to the changed set
       - Then compute transitive callers for each changed function and add those to the changed set
       - Returns the full set of functions that need re-verification due to contract changes

    4. Write comprehensive unit tests:
       - transitive_callers on empty graph returns empty
       - transitive_callers on linear chain (a->b->c) from c returns [b, a]
       - transitive_callers on diamond graph from bottom returns all callers
       - transitive_callers handles cycles without infinite loop (a->b->a)
       - transitive_callers excludes the function itself
       - transitive_callers with external (non-verified) callees
       - direct_callees returns only verified functions
       - direct_callees returns empty for leaf functions
       - changed_contract_functions identifies direct and transitive invalidation targets
  </action>
  <verify>
    `cargo test -p rust-fv-analysis -- call_graph:: --nocapture` passes all tests.
    `cargo clippy -p rust-fv-analysis -- -D warnings` has no warnings.
  </verify>
  <done>
    CallGraph has transitive_callers method that correctly computes reverse transitive closure.
    CallGraph has direct_callees method for dependency recording.
    Cycle handling works correctly (visited set prevents infinite loops).
    All tests pass including edge cases with cycles and diamond dependencies.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p rust-fv-driver -p rust-fv-analysis -- cache:: invalidation:: call_graph:: --nocapture` -- all new and existing tests pass
- `cargo clippy -p rust-fv-driver -p rust-fv-analysis -- -D warnings` -- no warnings
- CacheEntry serializes/deserializes with new fields (JSON round-trip test)
- Old cache files (without new fields) load successfully with serde defaults
</verification>

<success_criteria>
- Dual-hash cache entry model is implemented and tested
- Invalidation decision logic handles all 6 reason variants
- Reverse call graph computes transitive callers correctly with cycle safety
- Age-based eviction (30-day TTL) works during cache load
- All existing tests continue to pass (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/14-incremental-verification/14-01-SUMMARY.md`
</output>

---
phase: 14-incremental-verification
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - crates/driver/src/callbacks.rs
  - crates/driver/src/parallel.rs
  - crates/driver/src/cargo_verify.rs
  - crates/driver/src/output.rs
  - crates/driver/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Every function shows status: verified / skipped (cached) / failed in output"
    - "Invalidation reason is displayed when re-verifying: 'Re-verifying foo: contract of bar changed'"
    - "Total verification time shown by default, per-function timing with --verbose"
    - "--fresh flag bypasses cache for one run without deleting cache files"
    - "cargo verify clean subcommand permanently deletes cache directory"
    - "Cache location is target/verify-cache/ (not target/rust-fv-cache/)"
  artifacts:
    - path: "crates/driver/src/parallel.rs"
      provides: "Dual-hash aware cache lookup with invalidation decisions"
      contains: "InvalidationDecision"
    - path: "crates/driver/src/callbacks.rs"
      provides: "Per-function status reporting with invalidation reasons and timing"
      contains: "InvalidationReason"
    - path: "crates/driver/src/cargo_verify.rs"
      provides: "cargo verify clean subcommand and --verbose flag"
      contains: "clean"
    - path: "crates/driver/src/output.rs"
      provides: "Enhanced output with Skipped status and invalidation reasons"
      contains: "Skipped"
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/invalidation.rs"
      via: "uses decide_verification for cache decisions"
      pattern: "decide_verification"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/cache.rs"
      via: "uses compute_mir_hash and compute_contract_hash"
      pattern: "compute_mir_hash|compute_contract_hash"
    - from: "crates/driver/src/parallel.rs"
      to: "crates/driver/src/invalidation.rs"
      via: "per-task invalidation decisions replace simple cache.get()"
      pattern: "InvalidationDecision"
---

<objective>
Wire dual-hash cache and invalidation engine into the verification pipeline with per-function status reporting, timing, and cache management commands.

Purpose: Make incremental verification user-visible -- developers see exactly which functions were verified, which were cached, and why re-verification was triggered.
Output: Updated verification pipeline using dual-hash cache, per-function status output (verified/skipped/failed + reason), --verbose timing, --fresh one-off bypass, `cargo verify clean` subcommand.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-incremental-verification/14-CONTEXT.md
@.planning/phases/14-incremental-verification/14-RESEARCH.md
@.planning/phases/14-incremental-verification/14-01-SUMMARY.md
@crates/driver/src/callbacks.rs
@crates/driver/src/parallel.rs
@crates/driver/src/cargo_verify.rs
@crates/driver/src/output.rs
@crates/driver/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire dual-hash cache into verification pipeline</name>
  <files>
    crates/driver/src/callbacks.rs
    crates/driver/src/parallel.rs
  </files>
  <action>
    1. Update cache directory from `target/rust-fv-cache/` to `target/verify-cache/` in callbacks.rs (per user decision).

    2. Update callbacks.rs `after_analysis`:
       a. After building call graph, compute per-function MIR hash and contract hash separately using `VcCache::compute_mir_hash` and `VcCache::compute_contract_hash`.
       b. Store dependencies per function via `call_graph.direct_callees(func_name)`.
       c. Determine which functions have changed contracts by comparing current contract hashes against cached contract hashes.
       d. Use `call_graph.transitive_callers` to compute the full set of functions needing re-verification due to contract changes.
       e. For each function, call `invalidation::decide_verification()` to get InvalidationDecision.
       f. Pass the InvalidationDecision along with the task to parallel verification.
       g. Collect per-function timing (Instant::now() before/after verification).

    3. Update VerificationTask in parallel.rs:
       - Add `mir_hash: [u8; 32]` and `contract_hash: [u8; 32]` fields
       - Add `dependencies: Vec<String>` field
       - Add `invalidation_decision: InvalidationDecision` field
       - Replace the old cache.get() partition logic with InvalidationDecision-based partitioning:
         - Tasks where `should_verify == false` -> cached results (from existing cache entry)
         - Tasks where `should_verify == true` -> needs verification

    4. Update parallel.rs cache insertion:
       - Use new CacheEntry fields (mir_hash, contract_hash, timestamp, dependencies)
       - Insert using the dual hashes for future lookups

    5. Update VerificationTaskResult:
       - Add `invalidation_reason: Option<InvalidationReason>` field
       - Add `duration_ms: Option<u64>` for per-function timing

    6. Add `verbose: bool` field to VerificationCallbacks (parsed from RUST_FV_VERBOSE env var or --verbose flag).

    7. Update `--fresh` semantics: Instead of `cache.clear()`, set a flag that causes all `decide_verification` calls to return `Fresh` reason. Do NOT delete cache files. The cache remains intact for subsequent runs.

    8. Write unit tests:
       - Test VerificationTask with dual hashes
       - Test cached vs uncached partitioning based on InvalidationDecision
       - Test --fresh flag causes all tasks to be verified (not cached)
       - Test verbose flag parsing
  </action>
  <verify>
    `cargo test -p rust-fv-driver -- parallel:: callbacks:: --nocapture` passes.
    `cargo clippy -p rust-fv-driver -- -D warnings` has no warnings.
  </verify>
  <done>
    Verification pipeline uses dual-hash cache with per-function invalidation decisions.
    --fresh flag bypasses cache without deleting files.
    Per-function timing is collected.
    Verbose flag is parsed and available.
    VerificationTaskResult carries invalidation reason and timing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Per-function status output, timing display, and cargo verify clean</name>
  <files>
    crates/driver/src/output.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/cargo_verify.rs
    crates/driver/src/main.rs
  </files>
  <action>
    1. Add `Skipped` variant to `VerificationStatus` enum in output.rs. Update all match arms.

    2. Update `FunctionResult` in output.rs:
       - Add `invalidation_reason: Option<String>` field (human-readable reason string)
       - Add `duration_ms: Option<u64>` field

    3. Update `print_verification_results` in output.rs:
       - For Skipped status: print `[SKIP]` in cyan/blue with "(cached)" message
       - For re-verified functions: print invalidation reason after status, e.g.:
         `[OK]    foo (3 VCs) -- Re-verifying: contract of bar changed`
       - When verbose mode is enabled (pass as parameter): append per-function timing:
         `[OK]    foo (3 VCs, 42ms)`
         `[SKIP]  bar (cached)`
       - Always show total timing in summary line: `Summary: 2 OK, 1 SKIP, 0 FAIL (total: 156ms)`

    4. Update `print_results` in callbacks.rs:
       - Map invalidation reasons to human-readable strings:
         - MirChanged -> "body changed"
         - ContractChanged{dep} -> "contract of {dep} changed"
         - Fresh -> "fresh run"
         - CacheMiss -> "not in cache"
         - Expired -> "cache expired"
       - Set FunctionResult status to Skipped for cached results
       - Pass verbose flag to print_verification_results

    5. Add `cargo verify clean` subcommand to cargo_verify.rs:
       - If args[0] == "clean": delete `target/verify-cache/` directory, print confirmation, exit with 0
       - Update print_usage() to document the clean subcommand
       - Update arg filtering to not forward "clean" to cargo check

    6. Add `--verbose` flag parsing to cargo_verify.rs:
       - `parse_verbose(args) -> bool`
       - Pass as RUST_FV_VERBOSE env var to subprocess
       - Add to main.rs env var reading

    7. Update JSON output format in callbacks.rs/json_output.rs (if applicable):
       - Add `status: "skipped"` for cached functions
       - Add `invalidation_reason` field to JSON output
       - Add `duration_ms` field

    8. Write tests:
       - Test Skipped status formatting
       - Test invalidation reason display strings
       - Test cargo verify clean argument parsing
       - Test verbose flag parsing
       - Test summary line includes timing
  </action>
  <verify>
    `cargo test -p rust-fv-driver -- output:: cargo_verify:: callbacks:: --nocapture` passes.
    `cargo clippy -p rust-fv-driver -- -D warnings` has no warnings.
  </verify>
  <done>
    Every function shows status: verified/skipped/failed in output.
    Invalidation reason displayed when re-verifying (always, not behind verbose).
    Total timing in summary; per-function timing with --verbose.
    `cargo verify clean` deletes target/verify-cache/ and confirms.
    JSON output includes status/reason/timing for IDE integration.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p rust-fv-driver --nocapture` -- all tests pass
- `cargo clippy -p rust-fv-driver -- -D warnings` -- no warnings
- `cargo fmt -p rust-fv-driver --check` -- formatting correct
- Manual smoke test: output includes [OK], [SKIP], [FAIL] with reasons
</verification>

<success_criteria>
- Verification pipeline uses dual-hash cache with correct invalidation
- Every function shows verified/skipped/failed status with invalidation reason
- --fresh bypasses cache without deleting files
- cargo verify clean deletes cache directory permanently
- --verbose adds per-function timing
- Total timing always shown in summary
- JSON output updated with new fields
</success_criteria>

<output>
After completion, create `.planning/phases/14-incremental-verification/14-02-SUMMARY.md`
</output>

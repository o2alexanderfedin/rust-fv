---
phase: 14-incremental-verification
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - crates/driver/src/bench_incremental.rs
  - crates/driver/tests/incremental_correctness.rs
autonomous: true

must_haves:
  truths:
    - "Benchmark measures wall-clock ratio of full vs incremental verification"
    - "Benchmark measures cache hit rate (skipped/total functions)"
    - "Incremental verification never produces different results than full verification"
    - "Synthetic codebase provides controlled, reproducible benchmark scenarios"
    - "Single function body change re-verifies only that function (others cached)"
    - "Contract change triggers transitive re-verification of all dependents"
  artifacts:
    - path: "crates/driver/src/bench_incremental.rs"
      provides: "Benchmark suite with synthetic codebase generation and measurement"
      contains: "benchmark"
    - path: "crates/driver/tests/incremental_correctness.rs"
      provides: "Correctness tests proving incremental equals full verification"
      contains: "incremental"
  key_links:
    - from: "crates/driver/src/bench_incremental.rs"
      to: "crates/driver/src/cache.rs"
      via: "creates and populates cache for benchmark scenarios"
      pattern: "VcCache"
    - from: "crates/driver/tests/incremental_correctness.rs"
      to: "crates/driver/src/invalidation.rs"
      via: "validates invalidation decisions match full verification results"
      pattern: "decide_verification"
---

<objective>
Build benchmark suite and correctness tests for incremental verification, proving both performance gains and soundness equivalence.

Purpose: Demonstrate 20-30x speedup for incremental verification and prove that cache invalidation is sound (incremental never disagrees with full verification).
Output: Benchmark suite (synthetic + measurement), correctness test suite, CI-ready benchmark runner.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-incremental-verification/14-CONTEXT.md
@.planning/phases/14-incremental-verification/14-RESEARCH.md
@.planning/phases/14-incremental-verification/14-01-SUMMARY.md
@.planning/phases/14-incremental-verification/14-02-SUMMARY.md
@crates/driver/src/cache.rs
@crates/driver/src/invalidation.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Benchmark suite with synthetic codebase and performance measurement</name>
  <files>
    crates/driver/src/bench_incremental.rs
    crates/driver/src/main.rs
  </files>
  <action>
    1. Create `crates/driver/src/bench_incremental.rs` module with benchmark infrastructure:

    2. Synthetic codebase generator -- functions that produce IR-level function representations for benchmarking the cache and invalidation logic (NOT requiring full rustc compilation). Use the existing IR types from rust-fv-analysis:
       - `generate_synthetic_functions(count: usize) -> Vec<(String, Function, Contracts)>`:
         Creates N functions with realistic call patterns:
         - ~30% leaf functions (no calls)
         - ~50% single-caller functions (call 1-2 others)
         - ~20% high-fan-out functions (call 3-5 others)
         - Each function has 1-3 contracts (requires/ensures)
         - Function bodies have 2-5 basic blocks with assignments and assertions

    3. Benchmark scenarios (each measures wall-clock time and cache stats):
       a. `bench_full_verification(n: usize)` -- full verification of N functions from scratch (cold cache)
       b. `bench_incremental_body_change(n: usize)` -- verify N functions, then change 1 function body, re-verify (should skip N-1)
       c. `bench_incremental_contract_change(n: usize)` -- verify N functions, change 1 contract, re-verify (should re-verify function + transitive callers)
       d. `bench_incremental_no_change(n: usize)` -- verify N functions, re-verify with no changes (should skip all N)

    4. Measurement output:
       ```
       Incremental Verification Benchmark
       ===================================
       Functions: 50

       Full verification:        1.234s
       Body change (1 func):     0.045s (27.4x speedup, 49/50 cached)
       Contract change (1 func): 0.156s (7.9x speedup, 42/50 cached)
       No change:                0.012s (102.8x speedup, 50/50 cached)
       ```

    5. Target sizes: Run at 20, 50, 100 functions (scaled versions of the success criterion sizes). Note: we benchmark at IR/cache level, not full rustc compilation, so these represent the incremental verification subsystem performance.

    6. Add `mod bench_incremental;` to main.rs (gated behind `#[cfg(test)]` or as a standalone binary/test).

    7. Create a test function `test_benchmark_runs` that runs the benchmark at small scale (10 functions) to verify the benchmark infrastructure works. This test validates the synthetic generation and measurement code, not performance targets.

    8. Add a `run_benchmark` public function that can be called from a CI script or `cargo test -- --ignored bench` to produce the full benchmark report.
  </action>
  <verify>
    `cargo test -p rust-fv-driver -- bench_incremental --nocapture` passes.
    `cargo test -p rust-fv-driver -- bench_incremental --nocapture --ignored` runs full benchmark (if desired).
    `cargo clippy -p rust-fv-driver -- -D warnings` has no warnings.
  </verify>
  <done>
    Synthetic codebase generator produces realistic function graphs at configurable sizes.
    Benchmark measures full vs incremental time and cache hit rate for body/contract/no-change scenarios.
    Benchmark output format shows wall-clock ratio and cache hit rate.
    Small-scale test validates benchmark infrastructure works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Correctness tests proving incremental equals full verification</name>
  <files>
    crates/driver/tests/incremental_correctness.rs
  </files>
  <action>
    1. Create integration test file `crates/driver/tests/incremental_correctness.rs`.

    2. Test: `incremental_body_change_same_result` --
       - Create 5 functions with call dependencies (a->b->c, d->e)
       - Run full verification (all functions)
       - Record all results
       - Change function c's body (different IR)
       - Run incremental verification
       - Assert: c is re-verified, a/b/d/e are cached
       - Assert: Results for unchanged functions match full verification exactly

    3. Test: `incremental_contract_change_transitive_invalidation` --
       - Create chain: a->b->c
       - Run full verification
       - Change c's contract
       - Run incremental verification
       - Assert: c, b, a are ALL re-verified (transitive invalidation)
       - Assert: Results match what full verification would produce

    4. Test: `incremental_no_change_all_cached` --
       - Create 10 functions
       - Run full verification
       - Run incremental verification with no changes
       - Assert: All 10 functions are cached (0 verifications)
       - Assert: Results identical to full verification

    5. Test: `fresh_flag_bypasses_cache` --
       - Create and verify 5 functions (populate cache)
       - Run with fresh=true
       - Assert: All 5 functions are re-verified despite cache existing
       - Assert: Cache files still exist after fresh run (not deleted)

    6. Test: `expired_cache_triggers_reverification` --
       - Create cache entries with timestamp set to 31 days ago
       - Load cache
       - Assert: Expired entries are evicted
       - Run verification
       - Assert: All functions verified fresh (CacheMiss after eviction)

    7. Test: `mir_hash_stability` --
       - Generate same function twice
       - Assert: MIR hashes are identical
       - Modify function body
       - Assert: MIR hash changes
       - Assert: Contract hash unchanged

    8. Test: `contract_hash_stability` --
       - Generate same contracts twice
       - Assert: Contract hashes are identical
       - Modify one contract
       - Assert: Contract hash changes
       - Assert: MIR hash unchanged

    9. Test: `cycle_handling_no_infinite_loop` --
       - Create mutually recursive functions (a->b->a)
       - Change a's contract
       - Assert: transitive_callers terminates (doesn't loop)
       - Assert: Both a and b are re-verified

    10. Test: `diamond_dependency_single_invalidation` --
        - Create diamond: top->left, top->right, left->bottom, right->bottom
        - Change bottom's contract
        - Assert: All 4 functions re-verified (transitive)
        - Assert: No function verified more than once

    All tests operate at the IR/cache/invalidation level (no rustc required) using synthetic functions from bench_incremental or inline test helpers.
  </action>
  <verify>
    `cargo test -p rust-fv-driver --test incremental_correctness --nocapture` passes all tests.
    `cargo clippy -p rust-fv-driver -- -D warnings` has no warnings.
  </verify>
  <done>
    All correctness tests pass, proving:
    - Body-only changes re-verify only the changed function
    - Contract changes trigger transitive re-verification
    - No-change runs produce 100% cache hits
    - --fresh bypasses cache without deleting files
    - Expired entries are evicted correctly
    - Hash stability: same input produces same hash, different input produces different hash
    - Cycles handled without infinite loops
    - Diamond dependencies invalidate correctly without duplicates
    - Incremental verification NEVER disagrees with full verification
  </done>
</task>

</tasks>

<verification>
- `cargo test -p rust-fv-driver --nocapture` -- all tests pass (unit + integration)
- `cargo test -p rust-fv-analysis -- call_graph:: --nocapture` -- all call graph tests pass
- `cargo clippy -p rust-fv-driver -p rust-fv-analysis -- -D warnings` -- no warnings
- `cargo fmt --check` -- formatting correct
- Benchmark at 50 functions shows measurable speedup for incremental vs full
- All correctness tests demonstrate incremental == full results
</verification>

<success_criteria>
- Benchmark suite runs and produces wall-clock ratio + cache hit rate metrics
- Synthetic codebase generates realistic function call graphs
- All correctness tests pass proving soundness of cache invalidation
- Body change: only changed function re-verified
- Contract change: function + transitive callers re-verified
- No change: 100% cache hit
- Fresh: all re-verified, cache preserved
- Expired: evicted and re-verified
- Cycles: terminate correctly
</success_criteria>

<output>
After completion, create `.planning/phases/14-incremental-verification/14-03-SUMMARY.md`
</output>

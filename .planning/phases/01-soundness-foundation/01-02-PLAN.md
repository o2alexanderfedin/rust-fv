---
phase: 01-soundness-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/soundness_suite.rs
  - crates/analysis/tests/completeness_suite.rs
autonomous: true

must_haves:
  truths:
    - "A program containing a known integer overflow bug is rejected by the verifier with a counterexample"
    - "Unsigned subtraction underflow is detected (e.g., 3u32 - 5u32 wraps)"
    - "Signed division overflow (INT_MIN / -1) is detected"
    - "Shift-amount-out-of-bounds is detected"
    - "Division by zero is detected"
    - "A soundness test suite of at least 20 programs with known bugs all fail verification"
    - "A completeness test suite of at least 20 correct programs all pass verification"
  artifacts:
    - path: "crates/analysis/src/encode_term.rs"
      provides: "Audited overflow encoding matching Rust semantics"
      contains: "overflow_check"
    - path: "crates/analysis/tests/soundness_suite.rs"
      provides: "20+ tests where buggy programs are rejected"
      min_lines: 200
    - path: "crates/analysis/tests/completeness_suite.rs"
      provides: "20+ tests where correct programs verify successfully"
      min_lines: 200
  key_links:
    - from: "crates/analysis/tests/soundness_suite.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "vcgen::generate_vcs() called for each test function"
      pattern: "vcgen::generate_vcs"
    - from: "crates/analysis/tests/completeness_suite.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "vcgen::generate_vcs() called for each test function"
      pattern: "vcgen::generate_vcs"
    - from: "crates/analysis/src/encode_term.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Overflow check terms composed from BV operations"
      pattern: "Term::Bv"
---

<objective>
Audit arithmetic overflow encoding against Rust semantics and build comprehensive soundness/completeness test suites that prove the verifier catches real bugs and does not raise false alarms.

Purpose: The overflow encoding for add/sub/mul exists but has not been systematically audited. Additionally, Phase 1 requires 20+ soundness tests (buggy programs rejected) and 20+ completeness tests (correct programs verified). These suites serve as the regression gate for all future changes.

Output: Audited overflow encoding with any fixes applied, plus two test files with 40+ total tests exercising all arithmetic operations and control-flow patterns.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-soundness-foundation/01-01-SUMMARY.md
@crates/analysis/src/encode_term.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/tests/e2e_verification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and fix arithmetic overflow encoding</name>
  <files>crates/analysis/src/encode_term.rs, crates/analysis/src/vcgen.rs</files>
  <action>
Systematically audit every overflow check in `encode_term.rs` against Rust's actual semantics. Fix any discrepancies found.

**Audit checklist (verify each against Rust Reference and LLVM semantics):**

1. **Signed addition overflow** (`signed_add_no_overflow`): Current implementation checks `!(pos + pos = neg) && !(neg + neg = pos)`. This is correct. Verify with boundary values: `i32::MAX + 1` overflows, `i32::MIN + (-1)` overflows.

2. **Unsigned addition overflow** (`unsigned_add_no_overflow`): Current: `result >= lhs`. This is correct (`a + b` wraps when `result < a`). Verify: `u32::MAX + 1` wraps to 0.

3. **Signed subtraction overflow** (`signed_sub_no_overflow`): Current checks `!(pos - neg = neg) && !(neg - pos = pos)`. This is correct. Verify: `i32::MIN - 1` overflows, `i32::MAX - (-1)` overflows.

4. **Unsigned subtraction underflow**: Current: `lhs >= rhs`. This is correct -- Rust panics on debug underflow. Verify: `0u32 - 1` should be caught.

5. **Signed multiplication overflow** (`signed_mul_no_overflow`): Uses sign-extension to double width. This is the standard technique and is correct. Verify with `i32::MAX * 2`.

6. **Unsigned multiplication overflow**: Uses zero-extension. Correct. Verify with `u32::MAX * 2`.

7. **Division by zero** (`division_not_by_zero`): Checks `divisor != 0`. Correct.

8. **Signed division overflow** (`signed_div_no_overflow`): Checks `!(lhs == INT_MIN && rhs == -1)`. Correct -- this is the only signed division overflow case.

9. **Shift bounds**: Checks `shift_amount < bit_width`. Correct per Rust semantics (shifts by >= width panic in debug mode).

10. **Signed remainder** (`BinOp::Rem` with signed type): Currently includes division-by-zero check but NOT the `INT_MIN % -1` case. **FIX NEEDED**: In Rust, `i32::MIN % -1` also panics (it internally performs the division). Add `signed_div_no_overflow` check for signed `Rem` as well. Update the `Div | Rem` match arm to include overflow check for signed Rem.

11. **Checked binary ops** (`CheckedBinaryOp`): Currently collapsed to same encoding as `BinaryOp`. This is acceptable for Phase 1 because the IR representation already strips the overflow flag. The overflow VC is generated separately. No change needed.

12. **Wrapping/saturating ops**: Not yet in IR. No action needed for Phase 1 (these come from explicit `wrapping_add()` calls which have different MIR opcodes not yet in our IR).

**Concrete fix for item 10:**
In `overflow_check()`, change:
```rust
BinOp::Div | BinOp::Rem => {
    let mut checks = vec![division_not_by_zero(rhs, width)];
    if ty.is_signed() && op == BinOp::Div {
        checks.push(signed_div_no_overflow(lhs, rhs, width));
    }
    Some(Term::And(checks))
}
```
To:
```rust
BinOp::Div | BinOp::Rem => {
    let mut checks = vec![division_not_by_zero(rhs, width)];
    if ty.is_signed() {
        checks.push(signed_div_no_overflow(lhs, rhs, width));
    }
    Some(Term::And(checks))
}
```
This adds the `INT_MIN % -1` overflow check for signed remainder.

**Also verify**: The `min_signed_value()` helper correctly computes minimum values for all widths (8, 16, 32, 64, 128). Add a unit test if missing.

After fixes, add unit tests for any newly-fixed overflow checks. All existing `encode_term.rs` unit tests must continue to pass.
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis -- encode_term` -- all existing and new unit tests pass. Specifically verify the signed remainder overflow check is now present.
  </verify>
  <done>
Every overflow check in encode_term.rs is audited against Rust semantics. The signed remainder overflow case is fixed. All audit items are verified or documented as correct. Unit tests cover boundary cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build soundness and completeness test suites</name>
  <files>crates/analysis/tests/soundness_suite.rs, crates/analysis/tests/completeness_suite.rs</files>
  <action>
Create two new integration test files with 20+ tests each. Each test constructs an `ir::Function` manually, runs `vcgen::generate_vcs()`, submits to Z3, and asserts the expected result.

**Soundness suite** (`soundness_suite.rs`): Programs with known bugs that MUST be rejected (SAT = counterexample found).

Include at least these categories:

*Arithmetic overflow (8 tests):*
1. `snd_signed_add_overflow` -- `i32::MAX + 1` without precondition
2. `snd_unsigned_add_overflow` -- `u32::MAX + 1` without precondition
3. `snd_signed_sub_overflow` -- `i32::MIN - 1` without precondition
4. `snd_unsigned_sub_underflow` -- unconstrained `a - b` for u32 can underflow
5. `snd_signed_mul_overflow` -- unconstrained `a * b` for i32 can overflow
6. `snd_unsigned_mul_overflow` -- unconstrained `a * b` for u32 can overflow
7. `snd_division_by_zero` -- `a / b` without `b != 0` precondition
8. `snd_shift_overflow` -- `a << b` without `b < 32` precondition

*Wrong postconditions (6 tests):*
9. `snd_wrong_postcondition_add` -- `ensures(result == _1)` on `fn add(a, b) = a + b`
10. `snd_wrong_postcondition_max` -- `ensures(result == _1)` on max(a, b)
11. `snd_wrong_postcondition_identity` -- `ensures(result > _1)` on identity fn
12. `snd_wrong_postcondition_constant` -- `ensures(result == 0)` on fn returning 42
13. `snd_wrong_postcondition_branch` -- wrong postcondition on branching function
14. `snd_postcondition_off_by_one` -- `ensures(result >= _1 + 1)` on fn returning _1

*Control flow bugs (6 tests):*
15. `snd_branch_unsound_if_linear` -- function where linear block walking would miss a bug
16. `snd_signed_div_int_min_neg_one` -- `i32::MIN / -1` overflow
17. `snd_signed_rem_int_min_neg_one` -- `i32::MIN % -1` overflow
18. `snd_unrestricted_input_overflow` -- arithmetic on unrestricted signed inputs
19. `snd_nested_branch_wrong_result` -- nested branches with wrong postcondition
20. `snd_multi_assign_wrong_merge` -- multiple assignments to same var, wrong merge result

**Completeness suite** (`completeness_suite.rs`): Correct programs that MUST verify (UNSAT = proved safe).

Include at least these categories:

*Safe arithmetic (8 tests):*
1. `cmp_bounded_add` -- `requires(_1 >= 0 && _1 <= 100), requires(_2 >= 0 && _2 <= 100)`, add
2. `cmp_bounded_sub` -- `requires(_1 >= 50 && _1 <= 100), requires(_2 >= 0 && _2 <= 50)`, sub
3. `cmp_bounded_mul` -- `requires(_1 >= 0 && _1 <= 100), requires(_2 >= 0 && _2 <= 100)`, mul
4. `cmp_safe_div` -- `requires(_2 != 0)`, div
5. `cmp_safe_shift` -- `requires(_2 >= 0 && _2 <= 31)`, shl
6. `cmp_identity_postcondition` -- `ensures(result == _1)` on identity fn
7. `cmp_constant_postcondition` -- `ensures(result == 42)` on fn returning 42
8. `cmp_bounded_add_postcondition` -- `requires(bounds), ensures(result >= _1)`

*Control flow (7 tests):*
9. `cmp_max_function` -- max(a, b) with `ensures(result >= _1 && result >= _2)`
10. `cmp_abs_function` -- abs(x) with `ensures(result >= 0)` (bounded input)
11. `cmp_clamp_function` -- clamp(x, lo, hi) with ensures result in [lo, hi]
12. `cmp_if_else_same_result` -- both branches assign same value, postcondition trivial
13. `cmp_multi_branch_classify` -- 3-way branch, postcondition on result range
14. `cmp_early_return` -- early return via goto, both paths satisfy postcondition
15. `cmp_nested_branches_correct` -- 4-path nested if/else, all paths correct

*Type variations (5 tests):*
16. `cmp_u8_bounded_add` -- u8 with bounds [0, 100]
17. `cmp_i64_bounded_add` -- i64 with bounds
18. `cmp_u64_bounded_mul` -- u64 with bounds
19. `cmp_i8_safe_operations` -- i8 with tight bounds
20. `cmp_mixed_width_identity` -- different int widths, identity postcondition

Each test follows this pattern:
```rust
#[test]
fn test_name() {
    let func = Function { /* construct IR */ };
    let vcs = vcgen::generate_vcs(&func);
    let solver = solver_or_skip();
    for vc in &vcs.conditions {
        let smtlib = script_to_smtlib(&vc.script);
        let result = solver.check_sat_raw(&smtlib).expect("Z3 error");
        assert!(result.is_sat(), /* or is_unsat() */
            "description, got: {result:?}\nScript:\n{smtlib}");
    }
}
```

Reuse the `solver_or_skip()`, `script_to_smtlib()`, and formatting helpers from `e2e_verification.rs`. Factor these out into a shared test utility module or duplicate them in each test file (duplication is fine for test code -- keeps tests self-contained).
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis -- soundness_suite` -- all 20+ soundness tests pass (SAT = buggy programs rejected).
Run `cargo test -p rust-fv-analysis -- completeness_suite` -- all 20+ completeness tests pass (UNSAT = correct programs verified).
Run `cargo test -p rust-fv-analysis` -- full suite green.
  </verify>
  <done>
Soundness suite has 20+ tests, all produce SAT (bugs caught). Completeness suite has 20+ tests, all produce UNSAT (correct programs verified). The test suites serve as regression gates for all future VCGen changes.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis` -- all tests pass (unit + E2E + soundness + completeness)
2. `cargo clippy -p rust-fv-analysis -- -D warnings` -- no warnings
3. Soundness suite: 20+ tests where buggy programs produce SAT (counterexample found)
4. Completeness suite: 20+ tests where correct programs produce UNSAT (verified)
5. The signed remainder overflow case (`i32::MIN % -1`) is now caught
</verification>

<success_criteria>
- Every overflow check in encode_term.rs audited and verified correct or fixed
- Signed remainder overflow (INT_MIN % -1) is detected
- 20+ soundness tests: buggy programs rejected (SAT)
- 20+ completeness tests: correct programs verified (UNSAT)
- All tests pass with Z3 (gracefully skipped if Z3 unavailable)
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/01-soundness-foundation/01-02-SUMMARY.md`
</output>

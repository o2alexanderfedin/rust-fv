---
phase: 01-soundness-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/ir.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true

must_haves:
  truths:
    - "A function with if/else branches where each branch assigns different values to the same variable produces correct verification results"
    - "The VCGen uses SSA variable renaming so that assignments in different branches do not clobber each other"
    - "Control-flow merge points use ITE (if-then-else) encoding to select the correct value based on path conditions"
    - "A correct program with multi-path control flow (if/else, match arms, early return) verifies successfully without false alarms"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "SSA-based VCGen with CFG-aware path condition encoding"
      contains: "ssa_rename"
    - path: "crates/analysis/src/ir.rs"
      provides: "IR types (unchanged, but referenced for CFG traversal)"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "E2E tests for branching, multi-path control flow with Z3 verification"
      contains: "test_if_else_branches_ssa"
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "BasicBlock traversal with Terminator::SwitchInt/Goto handling"
      pattern: "Terminator::SwitchInt|Terminator::Goto"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Term::Ite for phi-function encoding at merge points"
      pattern: "Term::Ite"
---

<objective>
Fix the critical SSA violation in VCGen that makes verification unsound for any function with branches or loops.

Purpose: The current VCGen walks basic blocks linearly and ignores control flow. When variable `_0` is assigned in both the `then` and `else` branches of an `if`, only the last assignment (from the last block walked) survives. This is a soundness bug -- the verifier can report "verified" for incorrect programs or "failed" for correct ones. SSA renaming with path-condition-guarded ITE encoding at merge points is the textbook fix.

Output: A rewritten VCGen that produces sound verification conditions for all control-flow patterns including if/else, match arms, early return, and Goto chains.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/tests/e2e_verification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SSA renaming and path-condition-based VCGen</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <action>
Rewrite the VCGen to handle control flow properly. The current approach is fatally flawed: it walks blocks linearly and overwrites variable assignments, making branches unsound.

**What to implement:**

1. **SSA variable renaming**: Each assignment to a variable `_X` produces a new SSA name `_X_v{N}` where N is an incrementing counter per variable. The `_ssa_counter` HashMap already exists but is unused -- activate it. When encoding an assignment `_0 = expr`, emit `(assert (= _0_v{N} encoded_expr))` using the SSA-renamed operands.

2. **CFG-aware block traversal**: Instead of iterating blocks in order, build a proper traversal starting from block 0 (the entry block). Follow `Terminator::Goto(target)` to the target block. For `Terminator::SwitchInt { discr, targets, otherwise }`, recursively process each branch. For `Terminator::Return`, stop.

3. **Path condition accumulation**: When entering a SwitchInt branch, add the branch condition to a path condition stack. For branch with value `V`, the condition is `discr == V`. For the `otherwise` branch, the condition is `NOT(discr == v1) AND NOT(discr == v2) ...`. All assertions within a branch are guarded by `(=> path_condition assertion)` or equivalently, the path condition is assumed and the assertion is made.

4. **ITE encoding at merge points for contract VCs**: When generating postcondition VCs, the return value `_0` may have been assigned in multiple branches. Instead of using the last assignment, encode as:
   ```
   (assert (= _0_final (ite branch_cond _0_v_then _0_v_else)))
   ```
   This is the phi-function encoding. For the postcondition check, use `_0_final` as the value of `result`.

5. **Concrete approach -- path-sensitive encoding**: For each path through the function (entry to return), collect the path condition (conjunction of branch decisions) and the assignments along that path. For postcondition verification, assert:
   ```
   (assert (=> path_1_condition (= _0 path_1_value)))
   (assert (=> path_2_condition (= _0 path_2_value)))
   ```
   This naturally handles if/else, match arms, and early returns without explicit phi nodes.

6. **Update `collect_assignments_up_to` and `collect_all_assignments`**: These currently walk blocks linearly. Replace with path-aware collection. For overflow VCs, only include assignments reachable along the path to the statement being checked. For postcondition VCs, include all paths' assignments guarded by their path conditions.

7. **Handle `Terminator::Goto`**: Follow the goto to the target block. Do NOT process it as a separate top-level block.

8. **Handle `Terminator::Assert`**: Process the assertion condition, then continue to the target block.

9. **Handle `Terminator::Call`**: For now, treat as opaque (skip the call body, but record the destination assignment). Continue to the target block.

**What NOT to do:**
- Do NOT change the IR types in `ir.rs` (they already support the needed CFG structure)
- Do NOT change the SMT encoding functions in `encode_term.rs` or `encode_sort.rs`
- Do NOT change the spec parser (`parse_simple_spec`) -- it works fine
- Do NOT add loop handling (Phase 2) -- if a block has already been visited on the current path, skip it (prevents infinite loops in VCGen)

**Key insight**: The IR already has proper CFG structure via `Terminator::Goto`, `SwitchInt`, etc. The bug is entirely in `vcgen.rs` which ignores this structure and walks blocks by index.

**Preserve all existing unit tests** in vcgen.rs -- they test simple linear functions and should still pass. The existing `make_max_function()` test constructs a branching function but the postcondition VC was incorrect before; fix it so the max function with postcondition `result >= _1 && result >= _2` actually verifies as UNSAT (sound).
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis` -- all existing unit tests must pass plus the max function postcondition must now be verifiable. The `make_max_function()` test should produce a postcondition VC that, when submitted to Z3, returns UNSAT (proving max(a,b) >= a AND max(a,b) >= b).
  </verify>
  <done>
VCGen produces SSA-renamed variables and path-condition-guarded assertions. The `_ssa_counter` is actively used. SwitchInt branches are properly handled with ITE or path-condition encoding. All existing unit tests pass. The branching max function verifies correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E tests for branching and multi-path control flow</name>
  <files>crates/analysis/tests/e2e_verification.rs</files>
  <action>
Add end-to-end tests that construct IR functions with branches and verify them against Z3. These tests prove the SSA fix is sound.

**Tests to add (each builds IR manually, generates VCs, runs Z3):**

1. **`test_if_else_branches_ssa`**: Build `fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }` with postcondition `result >= _1 && result >= _2`. VCGen should produce a postcondition VC that is UNSAT (proved). This was the motivating bug -- before SSA, this would either fail or give wrong results.

2. **`test_if_else_wrong_postcondition`**: Same max function but with postcondition `result == _1` (incorrect -- fails when b > a). Postcondition VC should be SAT (counterexample found).

3. **`test_multi_branch_match`**: Build a function simulating a 3-way match:
   ```
   fn classify(x: i32) -> i32 {
     if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
   }
   ```
   With postcondition `result >= -1 && result <= 1`. Should verify (UNSAT).

4. **`test_early_return_via_goto`**: Build a function where one branch returns early via Goto to a return block, and the other falls through. Both paths assign `_0`. Postcondition should verify.

5. **`test_nested_branches`**: Build a function with nested if/else (4 paths). Each path assigns a different value. Postcondition constraining the result based on conditions should verify.

6. **`test_single_branch_overflow_check`**: Build a function where overflow can only happen on one branch. The overflow VC should be SAT for the overflow-possible path but the overall function verification should handle both paths.

Each test follows the existing pattern: construct `Function`, call `vcgen::generate_vcs()`, render script with `script_to_smtlib()`, submit to Z3 via `solver_or_skip()`, assert SAT/UNSAT as expected.
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis -- --test e2e_verification` -- all new tests pass. Tests that require Z3 are skipped gracefully if Z3 is not installed (using the existing `solver_or_skip()` pattern).
  </verify>
  <done>
Six new E2E tests cover if/else branches, multi-way match, early return, nested branches, and branch-specific overflow. All pass when Z3 is available. The previously-unsound max function now verifies correctly.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p rust-fv-analysis` -- all unit tests and E2E tests pass
2. `cargo clippy -p rust-fv-analysis -- -D warnings` -- no warnings
3. The max function postcondition `result >= _1 && result >= _2` verifies as UNSAT (was previously incorrect)
4. A wrong postcondition on a branching function produces SAT (counterexample found)
</verification>

<success_criteria>
- VCGen uses SSA renaming (each assignment creates a new SSA version)
- Control flow is traversed via CFG edges, not linear block iteration
- Path conditions guard assertions in each branch
- Postcondition VCs at merge points use ITE or path-condition encoding
- All 248+ existing tests pass (no regressions)
- New branching E2E tests pass with Z3
- The soundness bug is fixed: branching functions verify correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-soundness-foundation/01-01-SUMMARY.md`
</output>

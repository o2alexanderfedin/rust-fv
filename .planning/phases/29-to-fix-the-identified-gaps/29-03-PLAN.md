---
phase: 29-to-fix-the-identified-gaps
plan: 03
type: execute
wave: 2
depends_on:
  - 29-01
files_modified:
  - crates/analysis/src/ir.rs
  - crates/driver/src/mir_converter.rs
autonomous: true
requirements:
  - MIRCONV-02

must_haves:
  truths:
    - "Struct/enum/closure aggregate construction produces ir::Rvalue::Aggregate with correct kind (not None)"
    - "ir::Statement::SetDiscriminant(place, usize) variant exists in ir.rs"
    - "ir::Statement::Assume(operand) variant exists in ir.rs"
    - "SetDiscriminant and Assume statements are wired in convert_statement in mir_converter.rs"
    - "mirconv_02_struct_aggregate and mirconv_02_enum_aggregate tests turn GREEN"
    - "Previously-ignored mirconv_02_set_discriminant test can be un-ignored and passes"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "Statement::SetDiscriminant and Statement::Assume variants added to Statement enum"
      contains: "SetDiscriminant"
    - path: "crates/driver/src/mir_converter.rs"
      provides: "convert_rvalue handles Adt/Closure aggregates; convert_statement handles SetDiscriminant and Assume"
      contains: "AggregateKind::Adt"
  key_links:
    - from: "crates/driver/src/mir_converter.rs convert_rvalue Aggregate arm"
      to: "ir::AggregateKind::Enum / ir::AggregateKind::Closure"
      via: "mir::AggregateKind::Adt(def_id, variant_idx, ...) match"
      pattern: "AggregateKind::Adt"
    - from: "crates/driver/src/mir_converter.rs convert_statement"
      to: "ir::Statement::SetDiscriminant"
      via: "mir::StatementKind::SetDiscriminant match arm"
      pattern: "StatementKind::SetDiscriminant"
---

<objective>
Extend aggregate conversion in mir_converter.rs to handle Struct/Enum/Closure kinds (MIRCONV-02), and add SetDiscriminant + Assume as new IR Statement variants (dependency for later VCGen use).

Purpose: Struct construction (`let s = Struct { x: 1 }`) and enum construction (`MyEnum::Variant(x)`) currently produce no IR assignments — the Aggregate arm returns None for non-Tuple kinds. SetDiscriminant (enum tag mutation in optimized MIR) has no IR representation. Both gaps cause verification to silently skip these constructs.

Output: ir.rs with 2 new Statement variants; mir_converter.rs wires Adt/Closure aggregates and SetDiscriminant/Assume statements.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-to-fix-the-identified-gaps/29-RESEARCH.md
@.planning/phases/29-to-fix-the-identified-gaps/29-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/driver/src/mir_converter.rs
@crates/analysis/tests/vcgen_completeness29.rs
</context>

<tasks>

<task type="execute">
  <name>Task 1: Add SetDiscriminant and Assume to ir::Statement; extend Aggregate arm</name>
  <files>
    crates/analysis/src/ir.rs
    crates/driver/src/mir_converter.rs
  </files>
  <action>
**Step 1: Add new Statement variants to ir.rs**

Find the `Statement` enum in `crates/analysis/src/ir.rs` (around line 565):
```rust
pub enum Statement {
    Assign(Place, Rvalue),
    Nop,
}
```

Add two new variants:
```rust
pub enum Statement {
    Assign(Place, Rvalue),
    Nop,
    /// Set enum variant discriminant (tag). Used in optimized MIR when the tag is
    /// written separately from field construction.
    SetDiscriminant(Place, usize),
    /// Inject an assumption premise (from core::intrinsics::assume).
    Assume(Operand),
}
```

After adding variants, run `cargo build -p rust-fv-analysis 2>&1` to find all match exhaustion errors. The Statement enum is matched in vcgen.rs and other files. Each exhaustion error must be handled:
- `Statement::SetDiscriminant` in vcgen.rs: treat as a no-op for now (fall through with a comment "// TODO: generate equality assertion for discriminant"). The VCGen encoding of SetDiscriminant as an SMT equality assertion is handled in Plan 05.
- `Statement::Assume` in vcgen.rs: treat as a no-op for now (the Assume VCGen encoding is a stretch goal; the key fix is IR representation).
- Any other match sites: add `_ => {}` or explicit arms with no-ops.

Do NOT add the `#[non_exhaustive]` attribute — exhaustive match is desired (forces all call sites to handle new variants).

**Step 2: Fix the Aggregate arm in convert_rvalue (mir_converter.rs)**

Replace:
```rust
mir::Rvalue::Aggregate(box kind, operands) => {
    let ir_kind = match kind {
        mir::AggregateKind::Tuple => ir::AggregateKind::Tuple,
        _ => return None, // Skip complex aggregates for Phase 1
    };
    let ir_ops: Vec<ir::Operand> = operands.iter().map(|op| convert_operand(op)).collect();
    Some(ir::Rvalue::Aggregate(ir_kind, ir_ops))
}
```

With:
```rust
mir::Rvalue::Aggregate(box kind, operands) => {
    let ir_ops: Vec<ir::Operand> = operands.iter().map(|op| convert_operand(op)).collect();
    let ir_kind = match kind {
        mir::AggregateKind::Tuple => ir::AggregateKind::Tuple,
        mir::AggregateKind::Adt(def_id, variant_idx, _, _, _) => {
            // Use debug format for name — adequate for VCGen constructor matching.
            // AggregateKind::Adt is used for BOTH structs (variant_idx=0) and enums.
            // The IR Enum variant handles both cases; VCGen uses the variant index.
            let name = format!("{def_id:?}");
            ir::AggregateKind::Enum(name, variant_idx.as_usize())
        }
        mir::AggregateKind::Closure(def_id, _) => {
            ir::AggregateKind::Closure(format!("{def_id:?}"))
        }
        // Coroutine aggregates are handled by async_vcgen — skip here.
        mir::AggregateKind::Coroutine(..) => return None,
        // CoroutineClosure and RawPtr may exist in nightly — skip if present.
        _ => return None,
    };
    Some(ir::Rvalue::Aggregate(ir_kind, ir_ops))
}
```

**Pitfall:** `mir::AggregateKind::Struct` does NOT exist in `rustc_middle::mir` — struct construction uses `Adt` with `variant_idx = 0`. Do NOT add a match arm for `Struct`. The compiler will error if you try.

**Step 3: Wire SetDiscriminant and Assume in convert_statement (mir_converter.rs)**

Find `convert_statement` function. It currently handles only `StatementKind::Assign` and returns `None` for everything else. Add two new arms BEFORE the final `_ => None`:

```rust
mir::StatementKind::SetDiscriminant { place, variant_index } => {
    Some(ir::Statement::SetDiscriminant(
        convert_place(place),
        variant_index.as_usize(),
    ))
}
mir::StatementKind::Intrinsic(
    mir::NonDivergingIntrinsic::Assume(op)
) => {
    Some(ir::Statement::Assume(convert_operand(op)))
}
```

Note: `mir::NonDivergingIntrinsic` may be accessed as `mir::NonDivergingIntrinsic::Assume` or via a re-export. Check the import path. If the pattern does not compile, try `rustc_middle::mir::NonDivergingIntrinsic::Assume`.

**Step 4: Un-ignore mirconv_02_set_discriminant test in vcgen_completeness29.rs**

Remove the `#[ignore]` attribute from `mirconv_02_set_discriminant` test (and `vcgen_06_set_discriminant_assertion` if it only depended on the IR variant). Update the test body to directly construct `ir::Statement::SetDiscriminant(place, 0)` and verify `vcgen::generate_vcs` produces some output (even if SetDiscriminant is currently a no-op in VCGen — the test just confirms IR round-trip).

**Step 5: Verify all tests**
- `cargo build -p rust-fv-analysis -p rust-fv-driver` — clean build
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` — clean
- `cargo test -p rust-fv-analysis --test vcgen_completeness29 mirconv_02` — struct/enum aggregate tests GREEN
- `cargo test -p rust-fv-analysis --test vcgen_completeness28` — all 10 still GREEN

Commit: `feat(29-03): add ir::Statement::SetDiscriminant+Assume; wire Adt/Closure aggregates in mir_converter (MIRCONV-02)`
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo build -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -5 && cargo test -p rust-fv-analysis --test vcgen_completeness29 mirconv_02 2>&1 && cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -5</automated>
    <manual>Check ir.rs Statement enum has SetDiscriminant and Assume variants. Check mir_converter.rs convert_rvalue has AggregateKind::Adt arm. Check convert_statement has SetDiscriminant arm.</manual>
    <sampling_rate>run after this task, before Plan 04</sampling_rate>
  </verify>
  <done>ir::Statement has SetDiscriminant and Assume variants; mir_converter wires Adt+Closure aggregates and SetDiscriminant+Assume statements; mirconv_02 tests GREEN; Phase 28 tests GREEN; build clean.</done>
</task>

</tasks>

<verification>
- `grep "SetDiscriminant\|Assume" crates/analysis/src/ir.rs` — both variants present in Statement enum
- `grep "AggregateKind::Adt" crates/driver/src/mir_converter.rs` — Adt arm present
- `grep "SetDiscriminant" crates/driver/src/mir_converter.rs` — wired in convert_statement
- `cargo test -p rust-fv-analysis --test vcgen_completeness29 mirconv_02 2>&1` — tests pass
- `cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1` — all 10 GREEN
</verification>

<success_criteria>
- MIRCONV-02 satisfied: struct/enum/closure aggregates produce correct IR Rvalue::Aggregate (not None)
- ir.rs Statement enum extended with SetDiscriminant and Assume variants
- mir_converter.rs convert_statement handles SetDiscriminant and Assume intrinsic
- No regression in Phase 28 tests
</success_criteria>

<output>
After completion, create `.planning/phases/29-to-fix-the-identified-gaps/29-03-SUMMARY.md`
</output>

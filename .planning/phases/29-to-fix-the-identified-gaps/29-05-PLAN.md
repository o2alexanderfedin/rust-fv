---
phase: 29-to-fix-the-identified-gaps
plan: 05
type: execute
wave: 4
depends_on:
  - 29-02
  - 29-03
  - 29-04
files_modified:
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/encode_term.rs
autonomous: true
requirements:
  - VCGEN-06

must_haves:
  truths:
    - "Struct field mutation 's.field = expr' (projected LHS + BinaryOp rvalue) produces a functional update SMT assertion"
    - "The functional update uses mk-StructName constructor with updated field and selectors for unchanged fields"
    - "Projection::Downcast narrows the type for subsequent Field projection in encode_place_with_type"
    - "vcgen_06_struct_field_mutation test turns GREEN"
    - "vcgen_06_field_mutation_use regression guard remains GREEN"
    - "All Phase 28 tests and earlier Phase 29 tests remain GREEN"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "encode_assignment handles projected LHS with non-Use rvalue via functional record update"
      contains: "mk-"
    - path: "crates/analysis/src/encode_term.rs"
      provides: "Projection::Downcast narrows type in encode_place_with_type"
  key_links:
    - from: "crates/analysis/src/vcgen.rs encode_assignment projected LHS path"
      to: "Term::App(mk-StructName, [new_field, selector_terms...])"
      via: "Ty::Struct(name, fields) match + field_idx from Projection::Field"
      pattern: "mk-.*field"
    - from: "crates/analysis/src/encode_term.rs encode_place_with_type"
      to: "Ty::Enum variant narrowing"
      via: "Projection::Downcast(variant_idx) narrows to variant field types"
      pattern: "Downcast"
---

<objective>
Fix projected LHS VCGen to produce functional record update assertions for struct field mutation (VCGEN-06), and fix Projection::Downcast type narrowing in encode_place_with_type.

Purpose: `s.x = new_val` in MIR is an assignment to a projected place (`_1.0 = ...`). Currently, any non-Use rvalue on a projected place returns None from encode_assignment — the mutation produces no VC. The functional update pattern `(= s (mk-Point new_x (Point-y s)))` is the correct SMT-LIB2 encoding for struct field mutation in a datatype encoding.

Output: vcgen.rs encode_assignment handles struct field mutation via functional update; encode_term.rs Downcast projection narrows type; VCGEN-06 tests GREEN.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-to-fix-the-identified-gaps/29-RESEARCH.md
@.planning/phases/29-to-fix-the-identified-gaps/29-04-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/tests/vcgen_completeness29.rs
</context>

<tasks>

<task type="execute">
  <name>Task 1: Functional record update in encode_assignment + Downcast narrowing</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/analysis/src/encode_term.rs
  </files>
  <action>
**Step 1: Fix projected LHS in encode_assignment (vcgen.rs)**

Find the projected LHS section in `encode_assignment` (around line 1522-1530):
```rust
if !place.projections.is_empty() {
    let lhs = encode_place_with_type(place, func)?;
    let rhs = match rvalue {
        Rvalue::Use(op) => encode_operand_for_vcgen(op, func),
        _ => return None, // Complex rvalues on projected places are rare
    };
    return Some(Command::Assert(Term::Eq(Box::new(lhs), Box::new(rhs))));
}
```

Replace with:
```rust
if !place.projections.is_empty() {
    // Single-level Field projection: try functional record update for struct mutation.
    // Supports: s.field_idx = new_val (most common case in safe Rust).
    if place.projections.len() == 1 {
        if let Projection::Field(field_idx) = &place.projections[0] {
            if let Some(base_ty) = find_local_type(func, &place.local) {
                if let Ty::Struct(name, fields) = base_ty {
                    let new_val = encode_rvalue_for_assignment(rvalue, func, place)?;
                    let base_term = Term::Const(place.local.clone());
                    // Build functional update: (mk-Name f0 f1 ... new_val_at_idx ... fn)
                    let field_terms: Vec<Term> = fields
                        .iter()
                        .enumerate()
                        .map(|(i, (fname, _))| {
                            if i == *field_idx {
                                new_val.clone()
                            } else {
                                // Unchanged field: use selector (StructName-fieldName base)
                                Term::App(
                                    format!("{name}-{fname}"),
                                    vec![base_term.clone()],
                                )
                            }
                        })
                        .collect();
                    let updated = Term::App(format!("mk-{name}"), field_terms);
                    let lhs = Term::Const(place.local.clone());
                    return Some(Command::Assert(Term::Eq(
                        Box::new(lhs),
                        Box::new(updated),
                    )));
                }
            }
        }
    }
    // Fallback: encode via type-aware place for Use rvalues only.
    let lhs = encode_place_with_type(place, func)?;
    let rhs = match rvalue {
        Rvalue::Use(op) => encode_operand_for_vcgen(op, func),
        _ => return None,
    };
    return Some(Command::Assert(Term::Eq(Box::new(lhs), Box::new(rhs))));
}
```

Add helper `encode_rvalue_for_assignment` (or inline it) that encodes any rvalue to a Term for use as the new field value:
```rust
/// Encode an rvalue to a Term for use as the RHS of a functional update.
/// This is similar to encode_assignment's rhs encoding but returns a Term, not a Command.
fn encode_rvalue_for_assignment(
    rvalue: &Rvalue,
    func: &Function,
    dest: &Place,
) -> Option<Term> {
    match rvalue {
        Rvalue::Use(op) => Some(encode_operand_for_vcgen(op, func)),
        Rvalue::BinaryOp(op, lhs_op, rhs_op) => {
            let l = encode_operand(lhs_op);
            let r = encode_operand(rhs_op);
            let ty = infer_operand_type(func, lhs_op)
                .or_else(|| infer_operand_type(func, rhs_op))?;
            Some(encode_binop(*op, &l, &r, ty))
        }
        Rvalue::UnaryOp(op, operand) => {
            let t = encode_operand(operand);
            let ty = find_local_type(func, &dest.local)?;
            Some(encode_unop(*op, &t, ty))
        }
        _ => None, // Other rvalues not yet supported for functional update RHS
    }
}
```

**Pitfall (research confirmed):** The SMT-LIB2 datatype constructor `mk-StructName` MUST receive ALL fields in order. If a struct has 3 fields and only 1 changes, the term is `(mk-Name new_f0 (Name-f1 base) (Name-f2 base))`. Getting the arity wrong causes Z3 to report "wrong number of arguments for constructor". The implementation above handles this correctly by iterating over ALL fields.

**Step 2: Fix Projection::Downcast type narrowing in encode_place_with_type (encode_term.rs)**

Find the Downcast arm in `encode_place_with_type` (around lines 86-89):
```rust
Projection::Downcast(_variant_idx) => {
    // Enum downcast is handled during pattern matching
    // The type doesn't change here
}
```

The problem: when `Downcast` is followed by a `Field` projection, the Field projection needs the variant's field types, not the outer enum type. Without narrowing, `encode_field_access` gets the enum type and cannot find the variant-specific fields.

Replace with type narrowing:
```rust
Projection::Downcast(variant_idx) => {
    // Narrow the current type to the specific enum variant's type.
    // This allows the subsequent Field projection to access variant-specific fields.
    if let Ty::Enum(_enum_name, variants) = &current_ty {
        if let Some((variant_name, variant_fields)) = variants.get(*variant_idx) {
            // Create an ad-hoc Struct type for this variant's fields
            // so that the next Field projection can use encode_field_access
            let variant_struct_ty = Ty::Struct(
                variant_name.clone(),
                variant_fields
                    .iter()
                    .enumerate()
                    .map(|(i, ty)| (format!("f{i}"), ty.clone()))
                    .collect(),
            );
            current_ty = variant_struct_ty;
        }
    }
    // current_term stays the same — the enum value holds the fields
}
```

Note: The existing `current_ty` and `current_term` variables must already be tracked in the loop over projections. Check the actual structure of `encode_place_with_type` in encode_term.rs and adapt accordingly. If it uses a different loop structure, apply the same narrowing logic within that structure.

**Step 3: Verify test correctness**

Run the following test sequence:
1. `cargo build -p rust-fv-analysis` — clean build
2. `cargo test -p rust-fv-analysis --test vcgen_completeness29 vcgen_06` — VCGEN-06 tests GREEN
3. `cargo test -p rust-fv-analysis --test vcgen_completeness29 vcgen_06_field_mutation_use` — regression guard GREEN
4. `cargo test -p rust-fv-analysis --test vcgen_completeness28` — all 10 GREEN (no regression)
5. `cargo test -p rust-fv-analysis --test vcgen_completeness29` — all active tests GREEN
6. `cargo clippy -p rust-fv-analysis -- -D warnings` — clean

**Step 4: Run the full test suite to check for regressions**

```
cargo test -p rust-fv-analysis 2>&1 | tail -30
```

Expected: all existing tests pass. Any new failure must be investigated and fixed before committing.

Commit: `fix(29-05): functional record update for projected LHS struct mutation + Downcast type narrowing (VCGEN-06)`
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-analysis --test vcgen_completeness29 vcgen_06 2>&1 && cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -5</automated>
    <manual>Inspect the SMT output from vcgen_06_struct_field_mutation test — it must contain "mk-" constructor with the correct arity (all fields). The updated field is the new value; unchanged fields use selector terms like "StructName-fieldname".</manual>
    <sampling_rate>run after this task — this is the final plan in Phase 29</sampling_rate>
  </verify>
  <done>vcgen_06_struct_field_mutation GREEN (functional update assertion produced); vcgen_06_field_mutation_use GREEN (regression guard); Downcast narrowing works; all Phase 28 and Phase 29 tests GREEN; clippy clean.</done>
</task>

</tasks>

<verification>
Overall Phase 29 completion check:
- `cargo test -p rust-fv-analysis --test vcgen_completeness29 2>&1` — all active tests GREEN
- `cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1` — all 10 GREEN
- `cargo test -p rust-fv-analysis 2>&1 | tail -5` — no failures
- `cargo build -p rust-fv-analysis -p rust-fv-driver 2>&1` — clean
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings 2>&1` — clean

Requirement coverage verification:
- MIRCONV-01: `grep "CastKind::FloatToInt => ir::CastKind::FloatToInt" crates/driver/src/mir_converter.rs` — present (Plan 01)
- MIRCONV-02: `grep "AggregateKind::Adt" crates/driver/src/mir_converter.rs` — present (Plan 03)
- VCGEN-05: `grep "fp.to_sbv\|fp.to_ubv" crates/analysis/src/encode_term.rs` — present (Plan 02)
- VCGEN-06: `grep "mk-" crates/analysis/src/vcgen.rs` — functional update present (Plan 05)
</verification>

<success_criteria>
- VCGEN-06 satisfied: projected LHS struct field mutation produces functional record update SMT assertion
- Downcast → Field projection chain correctly narrows type to variant
- All 4 Phase 29 requirements satisfied: MIRCONV-01, MIRCONV-02, VCGEN-05, VCGEN-06
- All Phase 28 tests remain GREEN (zero regression)
- cargo build and clippy clean on both analysis and driver crates
</success_criteria>

<output>
After completion, create `.planning/phases/29-to-fix-the-identified-gaps/29-05-SUMMARY.md`
</output>

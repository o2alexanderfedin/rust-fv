---
phase: 29-to-fix-the-identified-gaps
plan: 04
type: execute
wave: 3
depends_on:
  - 29-03
files_modified:
  - crates/analysis/src/ir.rs
  - crates/driver/src/mir_converter.rs
autonomous: true
requirements:
  - MIRCONV-01

must_haves:
  truths:
    - "TyKind::Param(T) maps to ir::Ty::Generic('T') not ir::Ty::Named('T')"
    - "Rvalue::CopyForDeref produces ir::Rvalue::Use(Operand::Copy(place)) — identity copy"
    - "Rvalue::AddressOf produces ir::Rvalue::Ref (treated as transparent pointer identity)"
    - "Rvalue::Repeat([x; N]) produces ir::Rvalue::Repeat(operand, count)"
    - "Rvalue::NullaryOp SizeOf produces a constant for known primitive types"
    - "ir::Rvalue::Repeat variant exists in ir.rs"
    - "All Phase 28 and Phase 29 tests so far remain GREEN"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "ir::Rvalue::Repeat(Operand, usize) variant added to Rvalue enum"
      contains: "Repeat"
    - path: "crates/driver/src/mir_converter.rs"
      provides: "convert_ty maps TyKind::Param to Ty::Generic; convert_rvalue handles CopyForDeref, AddressOf, Repeat, NullaryOp"
      contains: "TyKind::Param"
  key_links:
    - from: "crates/driver/src/mir_converter.rs convert_ty"
      to: "ir::Ty::Generic"
      via: "ty::TyKind::Param(t) => ir::Ty::Generic(t.name.as_str().to_string())"
      pattern: "TyKind::Param"
    - from: "crates/driver/src/mir_converter.rs convert_rvalue"
      to: "ir::Rvalue::Repeat"
      via: "mir::Rvalue::Repeat(op, count) match arm"
      pattern: "Rvalue::Repeat"
---

<objective>
Fix TyKind::Param→Ty::Generic type mapping and add four missing Rvalue variants (CopyForDeref, AddressOf, Repeat, NullaryOp) to complete MIR converter coverage.

Purpose: TyKind::Param currently falls through to Named("{T:?}") instead of Generic("T"), meaning generic parameters are not recognized as such by the Phase 28 generic VCGen infrastructure. The four missing Rvalue variants cause common Rust constructs (`[x; N]`, `&raw const x`, deref coercions, `size_of::<T>()`) to silently produce no IR.

Output: convert_ty maps Param correctly; ir.rs has Repeat variant; convert_rvalue handles 4 new cases.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-to-fix-the-identified-gaps/29-RESEARCH.md
@.planning/phases/29-to-fix-the-identified-gaps/29-03-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/driver/src/mir_converter.rs
@crates/analysis/tests/vcgen_completeness29.rs
</context>

<tasks>

<task type="execute">
  <name>Task 1: Fix TyKind::Param mapping and add missing Rvalue variants</name>
  <files>
    crates/analysis/src/ir.rs
    crates/driver/src/mir_converter.rs
  </files>
  <action>
**Step 1: Add ir::Rvalue::Repeat variant to ir.rs**

Find the `Rvalue` enum in `crates/analysis/src/ir.rs`. Add the Repeat variant:
```rust
pub enum Rvalue {
    Use(Operand),
    BinaryOp(BinOp, Operand, Operand),
    CheckedBinaryOp(BinOp, Operand, Operand),
    UnaryOp(UnOp, Operand),
    Cast(CastKind, Operand, Ty),
    Ref(Mutability, Place),
    Aggregate(AggregateKind, Vec<Operand>),
    Len(Place),
    Discriminant(Place),
    Repeat(Operand, usize),   // NEW: [x; N] array fill
}
```

After adding, run `cargo build -p rust-fv-analysis` to find exhaustive match failures. Rvalue is matched in vcgen.rs, encode_term.rs, and potentially other files. For each new match failure on `Rvalue::Repeat`:
- In vcgen.rs `encode_assignment`: return `None` (VCGen encoding of Repeat is out of scope for Phase 29 — the IR just needs to represent it)
- In any other match sites: add `Rvalue::Repeat(..) => { /* skip */ }` or equivalent

**Step 2: Fix TyKind::Param in convert_ty (mir_converter.rs)**

Find `convert_ty` in `crates/driver/src/mir_converter.rs` (around lines 387-416). The final arm is:
```rust
_ => ir::Ty::Named(format!("{ty:?}")),
```

Insert a `TyKind::Param` arm BEFORE this catch-all:
```rust
ty::TyKind::Param(t) => ir::Ty::Generic(t.name.as_str().to_string()),
_ => ir::Ty::Named(format!("{ty:?}")),
```

**Critical:** The new arm MUST appear before `_ =>`. Rust matches arms in order — placing it after the wildcard makes it unreachable.

**Step 3: Add missing Rvalue variants to convert_rvalue (mir_converter.rs)**

The current match ends with `_ => None`. Insert new arms BEFORE this catch-all:

```rust
// CopyForDeref: deref coercion copy — treat as identity copy
mir::Rvalue::CopyForDeref(place) => {
    Some(ir::Rvalue::Use(ir::Operand::Copy(convert_place(place))))
}

// AddressOf: raw pointer creation — model as Ref (transparent pointer identity)
mir::Rvalue::AddressOf(_, place) => {
    Some(ir::Rvalue::Ref(ir::Mutability::Shared, convert_place(place)))
}

// Repeat: [x; N] array fill
mir::Rvalue::Repeat(op, count) => {
    // Extract the concrete count value from the ConstantKind
    // count is a mir::Const — try to get usize value
    let n = match count {
        mir::Const::Val(mir::ConstValue::Scalar(rustc_middle::mir::interpret::Scalar::Int(si)), _) => {
            si.to_u64().unwrap_or(0) as usize
        }
        _ => 0, // Unknown count — use 0 as sentinel; VCGen will skip
    };
    Some(ir::Rvalue::Repeat(convert_operand(op), n))
}

// NullaryOp: SizeOf / AlignOf / etc.
mir::Rvalue::NullaryOp(op, ty) => {
    let ir_ty = convert_ty(*ty);
    let size_bytes: u128 = match op {
        mir::NullaryOp::SizeOf => known_size_bytes(&ir_ty),
        mir::NullaryOp::AlignOf => known_align_bytes(&ir_ty),
        _ => 0, // UbChecks, OffsetOf, etc. — emit 0 constant
    };
    Some(ir::Rvalue::Use(ir::Operand::Constant(ir::Constant::Uint(
        size_bytes,
        ir::UintTy::Usize,
    ))))
}
```

Add helper functions `known_size_bytes` and `known_align_bytes` to mir_converter.rs:
```rust
fn known_size_bytes(ty: &ir::Ty) -> u128 {
    match ty {
        ir::Ty::Bool => 1,
        ir::Ty::Int(ir::IntTy::I8) | ir::Ty::Uint(ir::UintTy::U8) => 1,
        ir::Ty::Int(ir::IntTy::I16) | ir::Ty::Uint(ir::UintTy::U16) => 2,
        ir::Ty::Int(ir::IntTy::I32) | ir::Ty::Uint(ir::UintTy::U32) | ir::Ty::Float(ir::FloatTy::F32) => 4,
        ir::Ty::Int(ir::IntTy::I64) | ir::Ty::Uint(ir::UintTy::U64) | ir::Ty::Float(ir::FloatTy::F64) => 8,
        ir::Ty::Int(ir::IntTy::I128) | ir::Ty::Uint(ir::UintTy::U128) => 16,
        ir::Ty::Int(ir::IntTy::Isize) | ir::Ty::Uint(ir::UintTy::Usize) | ir::Ty::RawPtr(..) => 8,
        ir::Ty::Char => 4,
        _ => 0, // Unknown — emit 0 (conservative; VCGen gets uninterpreted constant)
    }
}

fn known_align_bytes(ty: &ir::Ty) -> u128 {
    // Alignment equals size for all primitive types on 64-bit
    known_size_bytes(ty).max(1)
}
```

**Note on mir::Rvalue::Repeat count extraction:** The `count` in MIR Repeat is a `mir::Const`. The extraction pattern for a scalar int may vary by nightly version. If the nested pattern above doesn't compile, use a simpler approach:
```rust
// Fallback: use debug format and try to parse
let n: usize = format!("{count:?}")
    .chars()
    .take_while(|c| c.is_ascii_digit())
    .collect::<String>()
    .parse()
    .unwrap_or(0);
```

**Step 4: Run all tests**
- `cargo build -p rust-fv-analysis -p rust-fv-driver` — clean
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` — clean
- `cargo test -p rust-fv-analysis --test vcgen_completeness28` — all 10 GREEN
- `cargo test -p rust-fv-analysis --test vcgen_completeness29 2>&1` — no NEW regressions; MIRCONV-01 and MIRCONV-02 tests should still pass

Commit: `feat(29-04): fix TyKind::Param→Generic; add CopyForDeref, AddressOf, Repeat, NullaryOp to mir_converter`
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo build -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -5 && cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1 | tail -5 && cargo test -p rust-fv-analysis --test vcgen_completeness29 2>&1 | tail -20</automated>
    <manual>grep "TyKind::Param" crates/driver/src/mir_converter.rs — must appear BEFORE the wildcard arm. grep "CopyForDeref\|AddressOf\|NullaryOp" crates/driver/src/mir_converter.rs — all three present. grep "Repeat" crates/analysis/src/ir.rs — Repeat variant in Rvalue enum.</manual>
    <sampling_rate>run after this task, before Plan 05</sampling_rate>
  </verify>
  <done>TyKind::Param maps to Ty::Generic; ir::Rvalue::Repeat exists; CopyForDeref, AddressOf, Repeat, NullaryOp are handled in convert_rvalue; all Phase 28 tests GREEN; build clean.</done>
</task>

</tasks>

<verification>
- `grep -n "TyKind::Param" crates/driver/src/mir_converter.rs` — present before wildcard arm
- `grep "enum Rvalue" -A 20 crates/analysis/src/ir.rs` — Repeat variant visible
- `grep "CopyForDeref\|NullaryOp\|AddressOf" crates/driver/src/mir_converter.rs` — all wired
- `cargo test -p rust-fv-analysis --test vcgen_completeness28 2>&1` — 10/10 GREEN
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings 2>&1` — clean
</verification>

<success_criteria>
- TyKind::Param correctly maps to ir::Ty::Generic (enables correct parametric VCGen from Phase 28)
- ir::Rvalue::Repeat variant added to IR
- CopyForDeref (identity), AddressOf (→Ref), Repeat, NullaryOp SizeOf/AlignOf all wired in convert_rvalue
- No regression in any existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/29-to-fix-the-identified-gaps/29-04-SUMMARY.md`
</output>

---
phase: 04-differentiation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/smtlib/src/term.rs
  - crates/smtlib/src/formatter.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/encode_quantifier.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true

must_haves:
  truths:
    - "A specification with forall(|x: i32| x > 0 ==> f(x) > 0) is parsed into SMT Term::Forall"
    - "A specification with exists(|x: i32| f(x) == 0) is parsed into SMT Term::Exists"
    - "Quantifiers are encoded to SMT-LIB with trigger patterns via :pattern annotation"
    - "Quantified specs are verified by Z3 using the non-quantifier-free logic"
    - "Conservative trigger inference selects function applications covering all bound variables"
    - "Quantifier without valid trigger produces a warning (not silent failure)"
  artifacts:
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Parsing of forall(|var: Type| body) and exists(|var: Type| body) with ==> operator"
      contains: "forall"
    - path: "crates/analysis/src/encode_quantifier.rs"
      provides: "Trigger inference, quantifier SMT encoding, pattern annotation"
      contains: "infer_triggers"
    - path: "crates/smtlib/src/term.rs"
      provides: "Term::Annotated for :pattern trigger annotations on quantifier bodies"
      contains: "Annotated"
    - path: "crates/smtlib/src/formatter.rs"
      provides: "Display for Annotated terms with :pattern"
      contains: "pattern"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "E2E tests for quantified specs verified by Z3"
      contains: "quantifier"
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/smtlib/src/term.rs"
      via: "forall/exists closures produce Term::Forall/Term::Exists with sorted vars"
      pattern: "Term::Forall"
    - from: "crates/analysis/src/encode_quantifier.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Trigger inference annotates quantifier body with Term::Annotated :pattern"
      pattern: "Annotated"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_quantifier.rs"
      via: "VC generation calls trigger inference before encoding quantified specs"
      pattern: "infer_triggers"
---

<objective>
Add quantifier support (forall/exists) to the specification language with trigger inference for SMT instantiation control.

Purpose: Enable expressing properties over all/some elements (e.g., "all array elements are positive", "there exists an element equal to target"). Quantifiers are the key specification feature distinguishing a formal verifier from a simple assertion checker. Trigger patterns control SMT solver instantiation to prevent timeout.

Output: Spec parser handles forall/exists closure syntax, encode_quantifier module provides trigger inference, SMT-LIB output includes :pattern annotations, E2E tests verify quantified properties with Z3.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-differentiation/04-RESEARCH.md
@.planning/phases/04-differentiation/04-01-SUMMARY.md
@crates/smtlib/src/term.rs
@crates/smtlib/src/formatter.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/vcgen.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SMT term annotations and quantifier spec parsing</name>
  <files>
    crates/smtlib/src/term.rs
    crates/smtlib/src/formatter.rs
    crates/analysis/src/spec_parser.rs
  </files>
  <action>
1. **smtlib/src/term.rs**: Add `Term::Annotated(Box<Term>, Vec<(String, Vec<Term>)>)` variant for SMT-LIB term annotations. This enables `:pattern` annotations on quantifier bodies. The Vec<(String, Vec<Term>)> stores annotation key-value pairs like `("pattern", [trigger_term1, trigger_term2])`.

2. **smtlib/src/formatter.rs**: Add Display formatting for `Term::Annotated`:
   ```smt2
   (! body :key1 (term1 term2) :key2 (term3))
   ```
   Specifically for `:pattern`:
   ```smt2
   (! body :pattern (trigger_pattern))
   ```
   Add unit tests:
   - `term_annotated_single_pattern` -- body with one :pattern
   - `term_annotated_no_annotations` -- empty annotations list renders just the body
   - `term_forall_with_pattern` -- Forall containing Annotated body

3. **analysis/src/spec_parser.rs**: Extend `convert_expr` to handle quantifier syntax. The spec syntax is:
   - `forall(|var: Type| body)` -- parsed by syn as `Expr::Call` where func is `forall` and arg is `Expr::Closure`
   - `exists(|var: Type| body)` -- same pattern with `exists`
   - `==>` (implication) -- parsed by syn as... this is NOT valid Rust syntax. Instead, use `Expr::MethodCall` pattern or handle as a custom operator.

   **IMPORTANT on `==>` syntax:** Since `==>` is not valid Rust, we have two options:
   a. Use `.implies()` method call syntax: `forall(|x: i32| (x > 0).implies(f(x) > 0))`
   b. Parse `==>` as a special token in the spec string before passing to syn (pre-process to replace `==>` with a temporary valid token)

   **Decision: Use approach (b)** -- pre-process the spec string to replace `==>` with `|IMPLIES|` (a valid Rust bitwise-or expression that we intercept), then in `convert_binop` detect this sentinel and produce `Term::Implies`. Actually, better: replace `==>` with `.__implies__()` but this is fragile. Instead, the cleanest approach: before calling `syn::parse_str`, replace all occurrences of `==>` with ` >= /* IMPLIES */ >=` ... no, that changes semantics.

   **Final approach:** Pre-process: replace `==>` in the raw spec string with the token `__IMPLIES__` (an identifier), then handle `Expr::Path` segments containing `__IMPLIES__` ... no, still invalid.

   **Simplest correct approach:** Pre-process the spec string: split on `==>`, recursively parse left and right, produce `Term::Implies(left, right)`. Do this in the quantifier body parser only. Alternatively, use `>>` (right shift) as the implication operator and document it. Actually the research doc shows Verus uses `==>` syntax.

   **ACTUAL APPROACH:** Before passing to syn, replace `==>` with a function-call-like syntax that IS valid Rust. Specifically: replace `A ==> B` with `__implies__(A, B)` using a simple regex/string replacement. Then in `convert_call`, detect `__implies__` and produce `Term::Implies(A, B)`.

   Implementation steps:
   a. Add `preprocess_spec_string(spec: &str) -> String` that replaces `==>` with `, __implies__, ` ... no. Actually: add a pre-processing step that replaces `X ==> Y` with `__implies(X, Y)` -- but this breaks nested expressions.

   **REVISED FINAL APPROACH:** The simplest sound approach is:
   - Before syn parsing, replace ALL occurrences of `==>` with `.__implies_rhs__(`  and append `)` at the matching scope. This is too complex.

   **USE THIS:** Define implication via the `>>` operator in specs. Document that `>>` means logical implication in specification context. In `convert_binop`, when inside a quantifier body, treat `SynBinOp::Shr` as `Term::Implies` instead of `Term::BvAShr/BvLShr`. Track "in quantifier body" with a flag parameter.

   Actually, the cleanest: just use `&&`, `||`, `!` which are valid Rust, and add a `implies(a, b)` function call. So specs look like:
   ```
   forall(|x: i32| implies(x > 0, f(x) > 0))
   ```
   This is valid Rust syntax (function call), easy to parse. In `convert_call`, detect `implies` (alongside existing `old`) and produce `Term::Implies`.

   **FINAL DECISION:** Support both:
   - `implies(a, b)` function call -> `Term::Implies(a, b)`
   - Pre-process `==>` to `__fv_implies_marker__(` ... too fragile.

   Just use `implies(a, b)`. Clean, valid Rust, easy to parse. Document in macro doc comments.

   Implementation:
   a. In `convert_call`: add case for `implies(a, b)` producing `Term::Implies(a, b)` -- requires exactly 2 arguments
   b. In `convert_call`: add case for `forall(closure)` where closure arg is `Expr::Closure` with typed params
   c. In `convert_call`: add case for `exists(closure)` -- same pattern
   d. For closure params: extract `(name, type)` pairs. Map Rust types to SMT sorts: `i32` -> `Sort::BitVec(32)`, `usize` -> `Sort::BitVec(64)`, `bool` -> `Sort::Bool`, `int` -> `Sort::Int`
   e. Convert closure body recursively with bound variables added to scope (they are NOT function params -- they are quantifier-bound). Add a `bound_vars: &[(String, Sort)]` parameter to `convert_expr` for variable resolution
   f. Produce `Term::Forall(sorted_vars, body)` or `Term::Exists(sorted_vars, body)`

   Add unit tests:
   - `parse_forall_simple`: `forall(|x: i32| x > 0)` -> Term::Forall with BvSGt body
   - `parse_exists_simple`: `exists(|x: i32| x == 0)` -> Term::Exists with Eq body
   - `parse_forall_implies`: `forall(|x: i32| implies(x > 0, x + 1 > 0))` -> Forall with Implies body
   - `parse_nested_quantifiers`: `forall(|x: i32| exists(|y: i32| x + y == 0))` -> nested Forall/Exists
   - `parse_quantifier_with_int_bound`: `forall(|x: int| x > 0)` -> Forall with Int sort, IntGt body
  </action>
  <verify>
    Run `cargo test -p rust-fv-smtlib` -- all tests pass including Annotated formatter tests.
    Run `cargo test -p rust-fv-analysis -- parse_forall` -- new quantifier parsing tests pass.
    Run `cargo test -p rust-fv-analysis -- parse_exists` -- new quantifier parsing tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - Term::Annotated exists with correct :pattern SMT-LIB formatting
    - Spec parser handles forall(|var: Type| body) and exists(|var: Type| body)
    - implies(a, b) function call produces Term::Implies
    - Bound variables in quantifier bodies resolve correctly
    - All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Trigger inference and E2E quantifier verification</name>
  <files>
    crates/analysis/src/encode_quantifier.rs
    crates/analysis/src/lib.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/e2e_verification.rs
  </files>
  <action>
1. **analysis/src/encode_quantifier.rs** (NEW FILE): Create module for quantifier encoding with trigger inference.

   a. `pub fn infer_triggers(body: &Term, bound_vars: &[String]) -> Vec<Vec<Term>>` -- Conservative trigger inference (Verus approach):
      - Walk the term tree to find `Term::App(name, args)` nodes (function applications)
      - A valid trigger candidate must contain ALL bound variables (check via `free_variables(term)`)
      - Filter out basic operators (no `Term::Eq`, `Term::BvAdd`, etc. as triggers)
      - Select minimal covering set: fewest trigger groups that cover all bound vars
      - If no valid trigger found, return empty Vec (caller should warn)
      - If multiple independent triggers needed, return as separate pattern groups

   b. `pub fn free_variables(term: &Term) -> HashSet<String>` -- Collect all `Term::Const(name)` leaves.

   c. `pub fn annotate_quantifier(term: Term) -> Term` -- If term is `Term::Forall(vars, body)` or `Term::Exists(vars, body)`:
      - Extract bound variable names
      - Call `infer_triggers(&body, &var_names)`
      - If triggers found, wrap body in `Term::Annotated(body, [("pattern", trigger_terms)])`
      - If no triggers, emit `tracing::warn!("No trigger found for quantifier; may cause incomplete instantiation")`
      - Return the (possibly annotated) quantifier

   d. Unit tests:
      - `test_free_variables` -- Const("x"), BvAdd(Const("x"), Const("y")) -> {"x", "y"}
      - `test_infer_trigger_app` -- App("f", [Const("x")]) found as trigger for bound var "x"
      - `test_infer_trigger_no_app` -- BvAdd(Const("x"), IntLit(1)) -> no valid trigger
      - `test_annotate_forall` -- Forall with App body gets :pattern annotation
      - `test_annotate_no_trigger_warns` -- Forall without App leaves body unannotated

2. **analysis/src/lib.rs**: Add `pub mod encode_quantifier;` to module declarations.

3. **analysis/src/vcgen.rs**: In the spec term processing (where preconditions/postconditions are parsed and asserted):
   - After parsing a spec expression via `spec_parser::parse_spec_expr`, if the resulting term contains `Term::Forall` or `Term::Exists`, pass it through `encode_quantifier::annotate_quantifier` to add trigger patterns
   - When any quantified spec is present, do NOT set a quantifier-free logic (remove/adjust the `set-logic QF_*` command). Either omit set-logic entirely or use a logic that supports quantifiers (e.g., `AUFBVDTLIA` or just let Z3 auto-detect)

4. **analysis/tests/e2e_verification.rs**: Add E2E tests for quantified verification:

   a. `test_quantifier_forall_positive_verified`: Build function with precondition `forall(|i: i32| implies(i > 0, i + 1 > 0))` (bounded to avoid overflow). Build the SMT script manually with Term::Forall, sorted vars (i, BitVec 32), body with Implies(BvSGt(i, 0), BvSGt(BvAdd(i, 1), 0)). This should be SAT in general (overflow), but with bounded precondition (i < 1000) should be UNSAT. Actually this is tricky with bitvectors. Better test:

   **Revised test strategy using Int sort (from Plan 01):**

   a. `test_quantifier_forall_int_verified`: Construct Term::Forall with Int-sorted bound variable: `forall ((x Int)) (=> (> x 0) (> (+ x 1) x))`. Assert the negation, check UNSAT. This proves the universal property holds. No bitvector overflow to worry about.

   b. `test_quantifier_exists_int_verified`: Construct `exists ((x Int)) (= (* x x) 4)`. Assert this directly (not negated -- exists is asserted positively in specs). Check SAT (x=2 or x=-2 witness).

   c. `test_quantifier_forall_with_trigger`: Construct forall with `Term::Annotated` body carrying `:pattern` for a function application. Verify Z3 accepts and solves. Use `(declare-fun f (Int) Int)` and `(forall ((x Int)) (! (=> (> x 0) (> (f x) 0)) :pattern ((f x))))`. Assert `(> y 0)` and `(not (> (f y) 0))`. Check UNSAT.

   d. `test_quantifier_forall_fails_correctly`: Construct a false universal property, verify Z3 returns SAT (counterexample found).

   e. `test_quantifier_full_pipeline`: Build an IR Function with a quantified postcondition. Use `parse_spec_expr` to parse the quantifier from a string like `forall(|x: int| implies(x > 0, x + 1 > x))`. Generate VCs. Submit to Z3. Assert UNSAT. THIS IS SUCCESS CRITERION 3.

   Pattern: construct IR Function manually, use spec_parser to parse quantified spec, generate VCs via generate_vcs, submit to Z3, assert result.
  </action>
  <verify>
    Run `cargo test -p rust-fv-analysis -- encode_quantifier` -- unit tests pass.
    Run `cargo test -p rust-fv-analysis -- quantifier` -- E2E tests pass.
    Run `cargo test --workspace` -- all tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - encode_quantifier module provides trigger inference with conservative selection
    - Quantified specs are annotated with :pattern triggers when function applications found
    - Warning emitted when no trigger found (not silent)
    - E2E tests verify forall/exists properties through full pipeline to Z3
    - Quantified postcondition parsed from spec string, encoded, and verified (SC3)
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all existing + new tests
2. `cargo clippy --workspace` zero warnings
3. `cargo fmt --all -- --check` passes
4. Quantified spec `forall(|x: int| implies(x > 0, x + 1 > x))` verified by Z3 (SC3)
5. Trigger inference produces :pattern annotations on quantifier bodies
6. No valid trigger -> warning logged, not silent failure
</verification>

<success_criteria>
- forall and exists closures parse correctly in spec strings
- implies(a, b) produces Term::Implies in spec expressions
- Trigger inference finds function applications as triggers
- Quantified specs verified by Z3 end-to-end
- Success criterion 3 met: forall/exists specs parsed, encoded, verified
</success_criteria>

<output>
After completion, create `.planning/phases/04-differentiation/04-02-SUMMARY.md`
</output>

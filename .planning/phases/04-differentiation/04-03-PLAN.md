---
phase: 04-differentiation
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/encode_prophecy.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true

must_haves:
  truths:
    - "A function taking `&mut i32` can be specified with ensures(*x == old(*x) + 1) using prophecy variables"
    - "Prophecy variable created at function entry for each &mut parameter"
    - "Prophecy resolved at function return: actual final value asserted equal to prophecy"
    - "The `^x` (final operator) in specs refers to the prophecy variable for the final value of mutable borrow"
    - "old(*x) refers to the initial dereference value of the mutable borrow at function entry"
  artifacts:
    - path: "crates/analysis/src/encode_prophecy.rs"
      provides: "ProphecyEncoding struct, create_prophecy, resolve_prophecy functions"
      contains: "ProphecyEncoding"
    - path: "crates/analysis/src/ir.rs"
      provides: "ProphecyInfo on Function for tracking mutable borrow prophecies"
      contains: "ProphecyInfo"
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Parsing of ^expr (final operator) and *expr (dereference) in specs"
      contains: "final_op"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Prophecy variable declaration, resolution assertion at return terminators"
      contains: "prophecy"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "E2E tests for mutable borrow prophecy verification"
      contains: "prophecy"
  key_links:
    - from: "crates/analysis/src/encode_prophecy.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VCGen calls create_prophecy for &mut params, resolve_prophecy at returns"
      pattern: "create_prophecy"
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/analysis/src/encode_prophecy.rs"
      via: "^x in specs maps to prophecy_var name from ProphecyEncoding"
      pattern: "prophecy"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Function.prophecies provides ProphecyInfo for each &mut param"
      pattern: "prophecies"
---

<objective>
Add prophecy variable support for mutable borrow reasoning in specifications (Creusot/RustHornBelt-style encoding).

Purpose: Enable specifying and verifying properties about the final value of mutable borrows. Without prophecy variables, the verifier cannot reason about `&mut T` parameters because the final value is unknown at function entry. Prophecy variables introduce a "future value" that is constrained at borrow expiration, enabling specs like `ensures(*x == old(*x) + 1)` for a function that increments through a mutable reference.

Output: ProphecyEncoding module, spec parser handling `^expr` (final) and `*expr` (deref) operators, VCGen prophecy lifecycle (create at entry, resolve at return), E2E tests demonstrating mutable borrow verification.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-differentiation/04-RESEARCH.md
@.planning/phases/04-differentiation/04-01-SUMMARY.md
@.planning/phases/04-differentiation/04-02-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/vcgen.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prophecy encoding infrastructure and spec parser extensions</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/encode_prophecy.rs
    crates/analysis/src/spec_parser.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
1. **analysis/src/ir.rs**: Add prophecy tracking to the IR:
   a. Add `ProphecyInfo` struct:
      ```rust
      #[derive(Debug, Clone)]
      pub struct ProphecyInfo {
          /// The mutable borrow parameter name (e.g., "_1")
          pub param_name: String,
          /// The initial value variable name (e.g., "_1_initial")
          pub initial_var: String,
          /// The prophecy (final value) variable name (e.g., "_1_prophecy")
          pub prophecy_var: String,
          /// The type being pointed to (e.g., Ty::Int(IntTy::I32) for &mut i32)
          pub inner_ty: Ty,
      }
      ```
   b. Add `pub prophecies: Vec<ProphecyInfo>` field to `Function` struct. Default to empty vec. Update all existing Function construction sites to include `prophecies: vec![]`.
   c. Add helper `Function::has_mut_ref_params(&self) -> bool` that checks if any param has `Ty::Ref(_, Mutability::Mutable)`.

2. **analysis/src/encode_prophecy.rs** (NEW FILE): Create the prophecy encoding module.

   a. `pub fn detect_prophecies(func: &Function) -> Vec<ProphecyInfo>` -- Scan function params for `Ty::Ref(inner, Mutability::Mutable)` types. For each mutable reference param, create a ProphecyInfo with:
      - `param_name`: the param's name (e.g., "_1")
      - `initial_var`: `{param_name}_initial` (value at function entry)
      - `prophecy_var`: `{param_name}_prophecy` (predicted final value)
      - `inner_ty`: the dereferenced type (e.g., `i32` from `&mut i32`)

   b. `pub fn prophecy_declarations(prophecies: &[ProphecyInfo]) -> Vec<Command>` -- Generate SMT DeclareConst commands:
      - For each prophecy: declare `{param_name}_initial` with inner type's sort
      - For each prophecy: declare `{param_name}_prophecy` with inner type's sort
      - For each prophecy: assert initial value equals current param dereference: `(assert (= {param_name}_initial {param_name}))` -- this captures the pre-state

   c. `pub fn prophecy_resolutions(prophecies: &[ProphecyInfo], final_values: &HashMap<String, Term>) -> Vec<Command>` -- Generate resolution assertions at function return:
      - For each prophecy: `(assert (= {param_name}_final {param_name}_prophecy))` where `{param_name}_final` is the actual final value of the mutable reference at the return point
      - If final_values map has the param name, use that term; otherwise use the current value of the param's dereference place

   d. Unit tests:
      - `test_detect_prophecies_mut_ref` -- Function with `&mut i32` param -> one ProphecyInfo
      - `test_detect_prophecies_no_mut` -- Function with `&i32` param -> empty
      - `test_detect_prophecies_multiple` -- Function with two `&mut` params -> two ProphecyInfos
      - `test_prophecy_declarations` -- Correct DeclareConst commands generated
      - `test_prophecy_resolutions` -- Correct assertion commands generated

3. **analysis/src/spec_parser.rs**: Extend for prophecy-related spec syntax:

   a. Handle `Expr::Unary(SynUnOp::Deref, expr)` -- the `*x` dereference in specs. When `*param_name` appears:
      - In normal context: produces `Term::Const(param_name)` (current value of the dereferenced variable)
      - In `old()` context: produces `Term::Const(format!("{param_name}_initial"))` (initial value)

   b. Handle "final operator" `^x` syntax. Since `^` in Rust is XOR, not a prefix operator, we need an alternative syntax. Options:
      - Use `final_value(x)` function call (like `old(x)`)
      - Use `hat(x)` function call

      **Decision:** Use `final_value(x)` function call syntax. In `convert_call`, add case:
      - `final_value(expr)` -> produces `Term::Const(format!("{param_name}_prophecy"))` where param_name is extracted from expr

      This is clean, valid Rust, and self-documenting.

   c. Add `prophecy_context: Option<&[ProphecyInfo]>` parameter to `convert_expr` (or pass through the Function which now contains prophecies). When resolving `*x` where x is a mutable reference param, use the prophecy naming convention.

   d. Unit tests:
      - `parse_deref_in_spec` -- `*_1 > 0` produces Const("_1") with appropriate encoding
      - `parse_old_deref` -- `old(*_1)` produces Const("_1_initial")
      - `parse_final_value` -- `final_value(_1)` produces Const("_1_prophecy")
      - `parse_ensures_with_old_and_deref` -- `*_1 == old(*_1) + 1` produces equality with initial and current

4. **analysis/src/lib.rs**: Add `pub mod encode_prophecy;` to module declarations.
  </action>
  <verify>
    Run `cargo test -p rust-fv-analysis -- encode_prophecy` -- unit tests pass.
    Run `cargo test -p rust-fv-analysis -- parse_deref` -- spec parser tests pass.
    Run `cargo test -p rust-fv-analysis -- parse_final` -- spec parser tests pass.
    Run `cargo test --workspace` -- all existing tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - ProphecyInfo struct captures mutable borrow prophecy metadata
    - detect_prophecies finds &mut params and creates prophecy variables
    - Prophecy declarations and resolutions generate correct SMT commands
    - Spec parser handles *x (deref), old(*x) (initial), final_value(x) (prophecy)
    - All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: VCGen prophecy integration and E2E mutable borrow tests</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/e2e_verification.rs
  </files>
  <action>
1. **analysis/src/vcgen.rs**: Integrate prophecy lifecycle into VC generation:

   a. At the beginning of `generate_vcs` (or the function-level VC generation), after declaring function params:
      - Call `encode_prophecy::detect_prophecies(func)` to find mutable reference params
      - Store prophecies on the function (or in local state)
      - For each prophecy, emit `DeclareConst` for initial and prophecy variables
      - Assert initial value capture: `(assert (= {param}_initial {param}))` (snapshot pre-state)

   b. When encoding postcondition specs:
      - Pass prophecy info to spec_parser so `old(*x)` resolves to `{x}_initial` and `final_value(x)` resolves to `{x}_prophecy`
      - The postcondition VC should use prophecy variables

   c. At each Return terminator in the CFG path:
      - For each prophecy, determine the final value of the mutable reference at that return point. The final value is the current value of the dereferenced param at the return (i.e., what the function wrote through the mutable reference)
      - Assert prophecy resolution: `(assert (= {param}_final {param}_prophecy))`
      - The `{param}_final` is declared as a fresh constant representing the actual final value, constrained to equal the last assignment through the mutable ref

   d. **Simplified approach for Phase 4:** Since our IR tracks assignments to places, the final value of `*_1` (a mutable ref param) is whatever was last assigned to `_1` (or a deref of `_1`) along the current path. At Return, collect the last assignment to each prophecy param's deref place and use that as the final value. If no assignment exists (param unchanged), the final value equals the initial value.

   e. Logic selection: when prophecies are present, ensure the SMT logic supports mixed bitvector/int operations. Omit `set-logic` or use `ALL` to let Z3 auto-detect.

2. **analysis/tests/e2e_verification.rs**: Add E2E tests for prophecy verification:

   a. `test_prophecy_increment_mut_ref`: Build IR for a function equivalent to:
      ```rust
      #[ensures(*x == old(*x) + 1)]
      fn increment(x: &mut i32) { *x += 1; }
      ```
      IR structure:
      - Param `_1` of type `Ty::Ref(Box::new(Ty::Int(IntTy::I32)), Mutability::Mutable)`
      - Statement: Assign(Place::local("_1"), Rvalue::BinaryOp(BinOp::Add, Operand::Copy(Place::local("_1")), Operand::Constant(Constant::Int(1, IntTy::I32))))
      - Postcondition: `*_1 == old(*_1) + 1`
      - ProphecyInfo for _1
      - Generate VCs, submit to Z3, assert UNSAT (property holds)
      THIS IS SUCCESS CRITERION 4 (simplified version using *x instead of v.len()).

   b. `test_prophecy_no_mutation_verified`: Build function that takes `&mut i32` but doesn't mutate it. Postcondition: `*_1 == old(*_1)`. Verify UNSAT (identity holds when unchanged).

   c. `test_prophecy_wrong_postcondition_fails`: Build increment function but with wrong postcondition `*_1 == old(*_1) + 2`. Verify SAT (counterexample: any input where actual increment is 1, not 2).

   d. `test_prophecy_conditional_mutation`: Build function that conditionally increments based on a flag:
      ```rust
      fn maybe_increment(x: &mut i32, flag: bool) {
          if flag { *x += 1; }
      }
      ```
      With postcondition: `implies(flag, *_1 == old(*_1) + 1)` and `implies(!flag, *_1 == old(*_1))`.
      Verify UNSAT on both branches.

   Pattern for all tests: construct IR Function with Ref(Mutable) param, ProphecyInfo, appropriate assignments, postconditions using old()/deref syntax, generate VCs, submit to Z3.

   NOTE: The test for SC4 uses `*x == old(*x) + 1` instead of `v.len() == old(v.len()) + 1` because Vec method calls are not yet supported. The prophecy mechanism is the same -- the SC4 criterion says "using prophecy variables to reason about the final value of the mutable borrow", which this achieves for `&mut i32`. Vec support requires method call encoding (future work).
  </action>
  <verify>
    Run `cargo test -p rust-fv-analysis -- prophecy` -- E2E tests pass.
    Run `cargo test --workspace` -- all tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
    Run `cargo fmt --all -- --check` -- passes.
  </verify>
  <done>
    - VCGen creates prophecy variables for &mut params at function entry
    - VCGen resolves prophecies at Return terminators
    - Postconditions using old(*x) and *x verify correctly against prophecy encoding
    - E2E test proves *x == old(*x) + 1 for increment function (SC4)
    - Wrong postcondition correctly produces SAT (counterexample)
    - Conditional mutation verified with prophecy (both branches)
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all existing + new tests
2. `cargo clippy --workspace` zero warnings
3. `cargo fmt --all -- --check` passes
4. Increment function with `*x == old(*x) + 1` postcondition verified via prophecy (SC4)
5. No-mutation function verifies `*x == old(*x)` (prophecy identity)
6. Wrong postcondition produces counterexample (soundness check)
</verification>

<success_criteria>
- ProphecyInfo tracks mutable reference params with initial/prophecy variable names
- VCGen prophecy lifecycle: create at entry, resolve at return
- Spec parser handles *x (deref), old(*x) (initial value), final_value(x) (prophecy)
- E2E increment function verified via prophecy variables (SC4)
- Prophecy mechanism is sound: wrong specs produce counterexamples
</success_criteria>

<output>
After completion, create `.planning/phases/04-differentiation/04-03-SUMMARY.md`
</output>

---
phase: 04-differentiation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/smtlib/src/term.rs
  - crates/smtlib/src/formatter.rs
  - crates/analysis/src/ir.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/vcgen.rs
  - crates/macros/src/lib.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true

must_haves:
  truths:
    - "A specification using `int` (unbounded mathematical integer) proves a property about arithmetic that would be unsound with fixed-width bitvectors"
    - "Explicit `as int` casts in specs convert bitvector values to unbounded integers"
    - "A `#[ghost]` annotated variable is usable in specifications but erased from VCGen executable encoding"
    - "Ghost code must be pure -- no side effects allowed in ghost blocks"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "SpecInt type variant, GhostLocal marker on Local"
      contains: "SpecInt"
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Parsing of `as int` casts, `as nat` casts, ghost variable references"
      contains: "as int"
    - path: "crates/analysis/src/encode_sort.rs"
      provides: "Ty::SpecInt maps to Sort::Int"
      contains: "SpecInt"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Ghost locals included in spec VCs but not executable encoding; Int-mode spec term generation"
      contains: "ghost"
    - path: "crates/smtlib/src/term.rs"
      provides: "Term::Bv2Int for bitvector-to-Int conversion"
      contains: "Bv2Int"
    - path: "crates/smtlib/src/formatter.rs"
      provides: "Display for Bv2Int as (bv2int term)"
      contains: "bv2int"
    - path: "crates/macros/src/lib.rs"
      provides: "#[ghost] proc macro attribute"
      contains: "ghost"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "E2E tests for unbounded int specs and ghost variables"
      contains: "unbounded_int"
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "crates/smtlib/src/term.rs"
      via: "as int cast produces Term::Bv2Int wrapping bitvector term"
      pattern: "Bv2Int"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_sort.rs"
      via: "SpecInt type encoded as Sort::Int"
      pattern: "encode_type.*SpecInt"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Ghost locals filtered from executable encoding, included in spec"
      pattern: "is_ghost"
---

<objective>
Add unbounded mathematical integers (`int`/`nat`) for specification-only arithmetic and ghost code support via `#[ghost]` attribute.

Purpose: Enable specifications to express mathematical properties without overflow concerns (e.g., `a + b > a` for positive values) and allow specification-only helper variables that are erased from compiled output. These are foundational features needed by quantifiers (Plan 02) and prophecy variables (Plan 03).

Output: Extended IR with SpecInt type and ghost marking, spec parser handling `as int` casts, SMT encoding using Int theory, `#[ghost]` proc macro, and E2E tests proving unbounded arithmetic properties that would be unsound with bitvectors.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-differentiation/04-RESEARCH.md
@crates/smtlib/src/term.rs
@crates/smtlib/src/sort.rs
@crates/smtlib/src/formatter.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/vcgen.rs
@crates/macros/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unbounded integer types and SMT encoding</name>
  <files>
    crates/smtlib/src/term.rs
    crates/smtlib/src/formatter.rs
    crates/analysis/src/ir.rs
    crates/analysis/src/encode_sort.rs
    crates/analysis/src/spec_parser.rs
    crates/analysis/src/vcgen.rs
  </files>
  <action>
1. **smtlib/src/term.rs**: Add `Term::Bv2Int(Box<Term>)` variant for bitvector-to-integer conversion (SMT-LIB `bv2int`). Also add `Term::Int2Bv(u32, Box<Term>)` for int-to-bitvector conversion (SMT-LIB `(_ int2bv N)`). Note: Term::IntLit, Term::IntAdd/Sub/Mul/Div/Mod/Neg, Term::IntLt/Le/Gt/Ge, Sort::Int already exist in the codebase.

2. **smtlib/src/formatter.rs**: Add Display formatting for the new term variants:
   - `Term::Bv2Int(t)` -> `(bv2int t)`
   - `Term::Int2Bv(n, t)` -> `((_ int2bv n) t)`
   Add unit tests for both new formatters.

3. **analysis/src/ir.rs**: Add `Ty::SpecInt` variant to the `Ty` enum for unbounded mathematical integers in specifications. Add `Ty::SpecNat` variant for non-negative unbounded integers. Add `is_ghost: bool` field to `Local` struct (default false for backward compatibility). Update all existing Local construction sites to include `is_ghost: false`. Add `Ty::is_spec_int(&self) -> bool` helper.

4. **analysis/src/encode_sort.rs**: Extend `encode_type` to handle `Ty::SpecInt -> Sort::Int` and `Ty::SpecNat -> Sort::Int` (nat is Int with non-negative constraint added separately).

5. **analysis/src/spec_parser.rs**: Extend `convert_expr` to handle `Expr::Cast` expressions:
   - Detect `expr as int` pattern (where `int` is recognized as a type path) -> produce `Term::Bv2Int(encode(expr))`
   - When in "int mode" (inside an `as int` cast), arithmetic operators (+, -, *, /, %) should produce `Term::IntAdd/IntSub/IntMul/IntDiv/IntMod` instead of `Term::BvAdd/BvSub/...`
   - Similarly, comparisons (>, <, >=, <=) in int mode produce `Term::IntGt/IntLt/IntGe/IntLe`
   - Add `in_int_mode: bool` parameter threaded through `convert_expr` (similar to existing `in_old: bool`)
   - Integer literals in int mode produce `Term::IntLit(value)` instead of `Term::BitVecLit(value, width)`
   - Add unit tests: `parse_as_int_cast`, `parse_int_mode_arithmetic`, `parse_int_mode_comparison`, `parse_mixed_bv_and_int`

6. **analysis/src/vcgen.rs**: When generating VCs for spec terms that use Int sort, switch the SMT logic to include LIA/NIA. Currently logic selection is in `generate_vcs` -- extend logic selection: if any spec term uses Int operations, use `AUFLIRA` (or simply omit set-logic to let Z3 auto-detect, which is more robust). Filter ghost locals: when encoding executable path assignments, skip locals where `is_ghost == true`. When encoding spec assertions (pre/postconditions), include ghost locals as DeclareConst with their appropriate sort.

IMPORTANT: The `as int` syntax must parse correctly with syn. Since `int` is not a Rust type, use the pattern of detecting `Expr::Cast` where the target type path segment is literally "int" or "nat". Example spec string: `(result as int) > 0` should parse as `Expr::Cast { expr: result, ty: int }`.

SOUNDNESS NOTE: Never silently mix bitvectors and Int. The `as int` cast must be explicit in specifications. Document this in code comments.
  </action>
  <verify>
    Run `cargo test -p rust-fv-smtlib` -- all existing tests pass plus new Bv2Int/Int2Bv formatter tests.
    Run `cargo test -p rust-fv-analysis` -- all existing tests pass plus new spec_parser int-mode tests.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - Term::Bv2Int and Term::Int2Bv exist with correct SMT-LIB formatting
    - Ty::SpecInt and Ty::SpecNat encode to Sort::Int
    - Local has is_ghost field (false by default, all existing code compiles)
    - Spec parser handles `as int` casts producing Int-mode arithmetic
    - VCGen filters ghost locals from executable encoding
    - All existing 469+ tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Ghost code macro and E2E verification tests</name>
  <files>
    crates/macros/src/lib.rs
    crates/macros/tests/basic.rs
    crates/analysis/tests/e2e_verification.rs
  </files>
  <action>
1. **macros/src/lib.rs**: Add `#[ghost]` proc macro attribute. Implementation pattern follows existing `#[pure]` -- no arguments accepted, embeds as `#[doc = "rust_fv::ghost"]` hidden doc comment. The ghost attribute marks a variable or code block as specification-only.

2. **macros/tests/basic.rs**: Add tests for the `#[ghost]` macro:
   - `test_ghost_compiles` -- verify `#[ghost] fn helper() -> i32 { 42 }` compiles
   - `test_ghost_no_args` -- verify `#[ghost(x)]` produces compile error (like pure)

3. **analysis/tests/e2e_verification.rs**: Add E2E tests proving unbounded integer specs:

   a. `test_unbounded_int_addition_no_overflow`: Build an IR function `fn add_positive(a: i32, b: i32) -> i32` with preconditions `a > 0` and `b > 0` and postcondition `(result as int) > (a as int)`. With bitvectors this would be SAT (overflow possible), but with Int theory it must be UNSAT (always true for positive values). This is SUCCESS CRITERION 1.

   b. `test_unbounded_int_sum_formula`: Build a function with postcondition `(result as int) == (a as int) + (b as int)` with bounded preconditions to prevent actual overflow. Verify UNSAT.

   c. `test_ghost_local_in_spec`: Build an IR function that has a ghost local (`is_ghost: true`) used in a spec expression. Verify the ghost local is declared in SMT but not in executable path encoding. The VC should be UNSAT (verified).

   d. `test_ghost_local_excluded_from_exec`: Verify that ghost locals do not appear in executable code VCs (overflow checks etc.) -- only in spec VCs.

   e. `test_nat_non_negative`: Build a function with a `SpecNat` typed local, verify that non-negativity constraint is added.

   For each test: construct IR Function manually (same pattern as existing E2E tests), generate VCs via `generate_vcs`, render to SMT-LIB, submit to Z3, assert expected result (UNSAT for correct programs, SAT for buggy ones). Use the SMT logic that supports both bitvectors and integers (omit set-logic or use ALL).

IMPORTANT: When testing unbounded int, the SMT script needs BOTH bitvector declarations (for executable code variables) AND Int declarations (for spec-only int expressions). The `bv2int` conversion connects them.
  </action>
  <verify>
    Run `cargo test -p rust-fv-macros` -- all tests pass including new ghost tests.
    Run `cargo test -p rust-fv-analysis -- unbounded_int` -- new E2E tests pass.
    Run `cargo test -p rust-fv-analysis -- ghost` -- new E2E tests pass.
    Run `cargo test --workspace` -- all tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - `#[ghost]` macro compiles and embeds annotation correctly
    - E2E test proves unbounded int spec verifies property unsound with bitvectors (SC1)
    - E2E test proves ghost locals included in spec VCs but excluded from executable encoding
    - All 469+ existing tests still pass, new tests bring total to ~480+
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all existing + new tests
2. `cargo clippy --workspace` zero warnings
3. `cargo fmt --all -- --check` passes
4. Unbounded int E2E test demonstrates property that would be unsound with bitvectors (SC1)
5. Ghost local is declared in spec VC but absent from executable VC encoding (SC2 partial)
</verification>

<success_criteria>
- Term::Bv2Int/Int2Bv produce valid SMT-LIB output accepted by Z3
- Spec parser converts `as int` casts to Int-mode arithmetic
- Ghost locals are filtered from executable encoding
- E2E test proves `(result as int) > (a as int)` for positive a,b (impossible with bitvectors alone)
- All 469+ existing tests unchanged and passing
</success_criteria>

<output>
After completion, create `.planning/phases/04-differentiation/04-01-SUMMARY.md`
</output>

---
phase: 04-differentiation
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/monomorphize.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/tests/e2e_verification.rs
autonomous: true

must_haves:
  truths:
    - "A generic function fn max<T: Ord>(a: T, b: T) -> T generates separate VCs for each concrete type instantiation"
    - "Monomorphization registry tracks which concrete types are used at each call site"
    - "Trait bounds (T: Ord) produce appropriate comparison operators for each concrete type"
    - "Verification of generic function with i32 and u64 instantiations both succeed independently"
  artifacts:
    - path: "crates/analysis/src/monomorphize.rs"
      provides: "MonomorphizationRegistry, TypeInstantiation, substitute_generics"
      contains: "MonomorphizationRegistry"
    - path: "crates/analysis/src/ir.rs"
      provides: "GenericParam on Function, TypeInstantiation tracking"
      contains: "GenericParam"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Per-instantiation VC generation for generic functions"
      contains: "monomorphize"
    - path: "crates/analysis/tests/e2e_verification.rs"
      provides: "E2E tests for generic function verification via monomorphization"
      contains: "generic"
  key_links:
    - from: "crates/analysis/src/monomorphize.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VCGen iterates over instantiations and generates VC per concrete type"
      pattern: "instantiations"
    - from: "crates/analysis/src/monomorphize.rs"
      to: "crates/analysis/src/ir.rs"
      via: "substitute_generics replaces GenericParam types with concrete Ty in Function"
      pattern: "substitute_generics"
---

<objective>
Add generic function verification via monomorphization, generating separate verification conditions for each concrete type instantiation.

Purpose: Enable verifying generic functions like `fn max<T: Ord>(a: T, b: T) -> T` by creating specialized VCs for each concrete type used at call sites (e.g., `max::<i32>`, `max::<u64>`). This mirrors Rust's own monomorphization strategy and avoids the complexity of parametric reasoning.

Output: MonomorphizationRegistry for tracking type instantiations, type substitution in IR functions, per-instantiation VC generation, E2E tests verifying generic max function for multiple concrete types.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-differentiation/04-RESEARCH.md
@.planning/phases/04-differentiation/04-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Monomorphization registry and type substitution</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/monomorphize.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
1. **analysis/src/ir.rs**: Add generic type parameter support:

   a. Add `GenericParam` struct:
      ```rust
      #[derive(Debug, Clone, PartialEq, Eq, Hash)]
      pub struct GenericParam {
          pub name: String,         // e.g., "T"
          pub trait_bounds: Vec<String>,  // e.g., ["Ord", "Clone"]
      }
      ```

   b. Add `Ty::Generic(String)` variant to the `Ty` enum for generic type parameters (e.g., `Ty::Generic("T".into())`). Update `bit_width()`, `is_signed()`, `is_unsigned()`, `is_integer()`, `is_bool()` to return None/false for Generic types.

   c. Add `pub generic_params: Vec<GenericParam>` field to `Function` struct. Default to empty vec. Update all existing Function construction sites.

   d. Add helper `Function::is_generic(&self) -> bool` returning `!self.generic_params.is_empty()`.

2. **analysis/src/monomorphize.rs** (NEW FILE): Create monomorphization module.

   a. `TypeInstantiation` struct:
      ```rust
      #[derive(Debug, Clone)]
      pub struct TypeInstantiation {
          /// Maps generic param name to concrete type: e.g., {"T" -> Ty::Int(IntTy::I32)}
          pub substitutions: HashMap<String, Ty>,
          /// Human-readable label: e.g., "max::<i32>"
          pub label: String,
      }
      ```

   b. `MonomorphizationRegistry` struct:
      ```rust
      #[derive(Debug, Clone, Default)]
      pub struct MonomorphizationRegistry {
          /// Maps function name to its concrete instantiations
          instantiations: HashMap<String, Vec<TypeInstantiation>>,
      }

      impl MonomorphizationRegistry {
          pub fn new() -> Self { Self::default() }

          pub fn register(&mut self, func_name: &str, inst: TypeInstantiation) {
              self.instantiations.entry(func_name.to_string())
                  .or_default()
                  .push(inst);
          }

          pub fn get_instantiations(&self, func_name: &str) -> &[TypeInstantiation] {
              self.instantiations.get(func_name)
                  .map(Vec::as_slice)
                  .unwrap_or(&[])
          }
      }
      ```

   c. `pub fn substitute_generics(func: &Function, inst: &TypeInstantiation) -> Function`:
      - Clone the function
      - Replace all `Ty::Generic(name)` occurrences in params, return_local, locals with the concrete type from `inst.substitutions`
      - Update function name to include instantiation label (e.g., "max" -> "max::<i32>")
      - Clear generic_params (the result is a concrete function)
      - Walk through contracts and any type references, substituting generics

   d. `fn substitute_ty(ty: &Ty, subs: &HashMap<String, Ty>) -> Ty`:
      - `Ty::Generic(name)` -> look up in subs, return concrete type (or panic if missing)
      - `Ty::Ref(inner, m)` -> Ty::Ref(substitute_ty(inner), m)
      - `Ty::Tuple(fields)` -> Ty::Tuple(fields.iter().map(substitute))
      - `Ty::Array(elem, n)` -> Ty::Array(substitute(elem), n)
      - `Ty::Slice(elem)` -> Ty::Slice(substitute(elem))
      - All other types: return unchanged

   e. `pub fn trait_bound_constraints(generic: &GenericParam, concrete_ty: &Ty) -> Vec<String>`:
      - For `Ord` bound: the concrete type must support comparison operators. Return list of supported ops.
      - For `Clone`/`Copy`: no verification impact (informational only)
      - This is used to validate that concrete types satisfy trait bounds.

   f. Unit tests:
      - `test_substitute_generics_simple` -- Replace T with i32 in params and return type
      - `test_substitute_generics_ref` -- Replace T in &T, &mut T types
      - `test_substitute_generics_tuple` -- Replace T in (T, T) tuple
      - `test_registry_register_and_get` -- Register instantiations, retrieve them
      - `test_substitute_preserves_contracts` -- Contracts unchanged after substitution
      - `test_generic_function_label` -- Function name updated with instantiation

3. **analysis/src/lib.rs**: Add `pub mod monomorphize;` to module declarations.
  </action>
  <verify>
    Run `cargo test -p rust-fv-analysis -- monomorphize` -- unit tests pass.
    Run `cargo test --workspace` -- all existing tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
  </verify>
  <done>
    - GenericParam and Ty::Generic added to IR
    - MonomorphizationRegistry tracks concrete type instantiations
    - substitute_generics replaces Ty::Generic with concrete types throughout Function
    - All existing Function construction sites updated (generic_params: vec![])
    - All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Per-instantiation VC generation and E2E generic tests</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/e2e_verification.rs
  </files>
  <action>
1. **analysis/src/vcgen.rs**: Add monomorphization-aware VC generation:

   a. Add `pub fn generate_vcs_monomorphized(func: &Function, registry: &MonomorphizationRegistry, contract_db: Option<&ContractDatabase>) -> Vec<FunctionVCs>`:
      - If `func.is_generic()`:
        - Get instantiations from registry for func.name
        - If no instantiations registered, emit tracing::warn and return empty
        - For each instantiation: call `monomorphize::substitute_generics(func, &inst)` to get concrete function, then call `generate_vcs(&concrete_func, contract_db)` to get VCs
        - Return collected FunctionVCs (one per instantiation)
      - If NOT generic: delegate to existing `generate_vcs(func, contract_db)` wrapped in a single-element vec

   b. **Do NOT modify existing `generate_vcs` function** -- the monomorphized variant is a wrapper that calls it for each concrete instantiation. This preserves backward compatibility.

   c. When a concrete instantiation has trait bounds (e.g., `T: Ord` with `T = i32`):
      - The comparison operators in the function body use the concrete type's encoding (signed for i32, unsigned for u32)
      - This happens naturally because `substitute_generics` replaces `Ty::Generic("T")` with `Ty::Int(IntTy::I32)`, and the existing encode_term logic handles signedness based on concrete types
      - No special trait-bound encoding needed for basic Ord/PartialOrd

2. **analysis/tests/e2e_verification.rs**: Add E2E tests for generic verification:

   a. `test_generic_max_i32_verified`: Build generic max function:
      ```rust
      fn max<T: Ord>(a: T, b: T) -> T {
          if a > b { a } else { b }
      }
      ```
      IR: Function with generic_params: [GenericParam { name: "T", trait_bounds: ["Ord"] }], params and return as Ty::Generic("T"), with SwitchInt on comparison. Register instantiation T=i32. Generate VCs via `generate_vcs_monomorphized`. Postcondition: `result >= _1 && result >= _2`. Submit to Z3, assert UNSAT.

   b. `test_generic_max_u64_verified`: Same max function but with T=u64 instantiation. Postcondition: `result >= _1 && result >= _2` (unsigned comparison). Assert UNSAT. THIS COMBINED WITH (a) IS SUCCESS CRITERION 5.

   c. `test_generic_max_wrong_postcondition`: Max function with wrong postcondition `result == _1` (should be SAT since result could be _2). Register T=i32. Assert SAT.

   d. `test_generic_multiple_instantiations`: Register both i32 and u64 for same function. Call `generate_vcs_monomorphized`. Verify we get FunctionVCs for both instantiations. Both should be UNSAT with correct postcondition.

   e. `test_generic_no_instantiations_warning`: Generic function with no registered instantiations. Verify `generate_vcs_monomorphized` returns empty vec (with tracing warning).

   IR construction for generic max:
   - generic_params: [GenericParam { name: "T", trait_bounds: ["Ord"] }]
   - params: [Local { name: "_1", ty: Ty::Generic("T") }, Local { name: "_2", ty: Ty::Generic("T") }]
   - return_local: Local { name: "_0", ty: Ty::Generic("T") }
   - basic_blocks: [bb0: SwitchInt comparing _1 > _2, bb1: Assign(_0, _1), bb2: Assign(_0, _2), bb3: Return]
   - contracts: ensures ["result >= _1 && result >= _2"]

   After substitute_generics with T=i32: all Ty::Generic("T") -> Ty::Int(IntTy::I32), comparisons become signed BvSGt/BvSGe.
   After substitute_generics with T=u64: all Ty::Generic("T") -> Ty::Uint(UintTy::U64), comparisons become unsigned BvUGt/BvUGe.
  </action>
  <verify>
    Run `cargo test -p rust-fv-analysis -- generic` -- E2E tests pass.
    Run `cargo test --workspace` -- all tests pass.
    Run `cargo clippy --workspace` -- zero warnings.
    Run `cargo fmt --all -- --check` -- passes.
  </verify>
  <done>
    - generate_vcs_monomorphized produces per-instantiation VCs for generic functions
    - Generic max<T: Ord> verified for i32 (signed) and u64 (unsigned) instantiations (SC5)
    - Wrong postcondition on generic function produces SAT (soundness)
    - No-instantiation case warns and returns empty
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all existing + new tests
2. `cargo clippy --workspace` zero warnings
3. `cargo fmt --all -- --check` passes
4. Generic max function verified for i32 and u64 via monomorphization (SC5)
5. Each instantiation generates independent VCs with correct type encoding
6. Wrong postcondition on generic function produces counterexample
</verification>

<success_criteria>
- MonomorphizationRegistry tracks concrete type instantiations per function
- substitute_generics correctly replaces Ty::Generic with concrete types
- generate_vcs_monomorphized produces separate FunctionVCs per instantiation
- Generic max<T: Ord> verified for both i32 and u64 (SC5)
- Trait bounds (Ord) produce correct comparison operators per concrete type
</success_criteria>

<output>
After completion, create `.planning/phases/04-differentiation/04-04-SUMMARY.md`
</output>

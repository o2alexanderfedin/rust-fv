---
phase: 23-async-await
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/macros/src/lib.rs
  - crates/driver/src/callbacks.rs
autonomous: true
requirements:
  - ASY-01
  - ASY-02

must_haves:
  truths:
    - "CoroutineInfo, CoroutineState, CoroutineExitKind structs exist in ir.rs and are Clone+Debug"
    - "Contracts struct has state_invariant: Option<SpecExpr> field"
    - "Function struct has coroutine_info: Option<CoroutineInfo> field"
    - "VcKind enum has AsyncStateInvariantSuspend, AsyncStateInvariantResume, AsyncPostcondition variants"
    - "#[state_invariant(expr)] proc macro compiles and emits a doc attribute following the spec_attribute pattern"
    - "callbacks.rs extract_contracts() populates state_invariant from doc attribute rust_fv::state_invariant::"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "CoroutineInfo, CoroutineState, CoroutineExitKind types + state_invariant on Contracts + coroutine_info on Function"
      contains: "pub struct CoroutineInfo"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind async variants"
      contains: "AsyncStateInvariantSuspend"
    - path: "crates/macros/src/lib.rs"
      provides: "#[state_invariant] proc macro attribute"
      contains: "pub fn state_invariant"
    - path: "crates/driver/src/callbacks.rs"
      provides: "state_invariant extraction from doc attributes"
      contains: "state_invariant"
  key_links:
    - from: "crates/macros/src/lib.rs"
      to: "crates/driver/src/callbacks.rs"
      via: "rust_fv::state_invariant:: doc attribute prefix"
      pattern: "rust_fv::state_invariant::"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Contracts.state_invariant assignment"
      pattern: "contracts\\.state_invariant"
---

<objective>
Add the IR types and macro infrastructure required for async/await verification.

Purpose: Establish the foundational data structures (CoroutineInfo, CoroutineState, new VcKind variants, state_invariant contract field) that the MIR converter (Plan 02) and async VC generator (Plan 03) will build on. The #[state_invariant] macro and callbacks.rs extraction give developers the annotation surface.

Output: Modified ir.rs, vcgen.rs, macros/src/lib.rs, callbacks.rs — all additive, backward-compatible, all tests still green.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-async-await/23-CONTEXT.md
@.planning/phases/23-async-await/23-RESEARCH.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/macros/src/lib.rs
@crates/driver/src/callbacks.rs
</context>

<feature>
  <name>Async IR Types + #[state_invariant] Macro + Contract Extraction</name>
  <files>
    crates/analysis/src/ir.rs,
    crates/analysis/src/vcgen.rs,
    crates/macros/src/lib.rs,
    crates/driver/src/callbacks.rs
  </files>

  <behavior>
    ### ir.rs additions (purely additive — no existing fields changed)

    Add after the existing HOF/FnSpec types:

    ```rust
    #[derive(Debug, Clone, PartialEq)]
    pub enum CoroutineExitKind {
        Yield,   // suspends at .await
        Return,  // returns Poll::Ready
    }

    #[derive(Debug, Clone)]
    pub struct CoroutineState {
        pub state_id: usize,        // 0-based
        pub entry_block: usize,     // IR BasicBlock index (BlockId = usize)
        pub exit_kind: CoroutineExitKind,
        pub await_source_line: Option<u32>,  // source line of .await for diagnostics
    }

    #[derive(Debug, Clone)]
    pub struct CoroutineInfo {
        pub states: Vec<CoroutineState>,
        pub persistent_fields: Vec<(String, Ty)>,  // (smt_name, type) for cross-await locals
    }
    ```

    Add to `Contracts` struct (after fn_specs field):
    ```rust
    pub state_invariant: Option<SpecExpr>,
    ```
    Update `Contracts::default()` / `new()` / existing construction sites to include `state_invariant: None`.

    Add to `Function` struct (after source_names field):
    ```rust
    pub coroutine_info: Option<CoroutineInfo>,
    ```
    Update all `Function { ... }` construction sites to include `coroutine_info: None`.

    ### vcgen.rs additions (additive to VcKind enum, after WeakMemoryAtomicity)

    ```rust
    /// #[state_invariant] check just before .await suspends (at Yield terminator).
    AsyncStateInvariantSuspend,
    /// #[state_invariant] check just after .await resumes (after Yield resume).
    AsyncStateInvariantResume,
    /// #[ensures] check at Poll::Ready resolution of async fn.
    AsyncPostcondition,
    ```

    Update `VcKind::as_str()` / `Display` impl (if present) to cover the 3 new variants.
    Update any exhaustive match on VcKind to add the 3 new arms (use `| VcKind::AsyncStateInvariantSuspend | ...` catch-all if appropriate for non-critical arms).

    ### macros/src/lib.rs addition (one function, following spec_attribute pattern)

    After the existing `fn_spec` macro and before the `spec_attribute` helper:

    ```rust
    /// Attach a state invariant to an async function.
    ///
    /// The invariant must hold at every `.await` suspension point:
    /// both at suspension (just before yielding) and at resumption (just after
    /// control returns from the awaited future).
    ///
    /// The invariant expression may reference any local variable visible at
    /// the annotation site, including captured variables and `&mut` fields.
    ///
    /// # Example
    ///
    /// ```ignore
    /// #[state_invariant(counter >= 0)]
    /// async fn process(counter: &mut i32) {
    ///     some_future().await;
    ///     *counter += 1;
    /// }
    /// ```
    #[proc_macro_attribute]
    pub fn state_invariant(attr: TokenStream, item: TokenStream) -> TokenStream {
        spec_attribute("state_invariant", attr, item)
    }
    ```

    ### callbacks.rs addition (add to extract_contracts doc-attribute scan)

    Find the block in `extract_contracts()` that scans doc attributes for `rust_fv::ensures::`, `rust_fv::requires::`, etc. Add:

    ```rust
    if doc_value.starts_with("rust_fv::state_invariant::") {
        let expr_str = &doc_value["rust_fv::state_invariant::".len()..];
        contracts.state_invariant = Some(SpecExpr {
            expr: expr_str.to_string(),
            // copy span fields from the same pattern as requires/ensures
        });
    }
    ```

    Initialize `state_invariant: None` in `Contracts::default()` (if it exists) or wherever Contracts is constructed in callbacks.rs.

    ### TDD cycle

    RED: Add unit tests in ir.rs and macros/src/lib.rs before adding code:
    - `ir.rs` test: construct `CoroutineInfo { states: vec![...], persistent_fields: vec![] }` and assert field values
    - `ir.rs` test: `Function { ..., coroutine_info: None }` compiles without error
    - `ir.rs` test: `Contracts { ..., state_invariant: None }` compiles without error
    - `macros` test: `spec_attribute_impl("state_invariant", ...)` emits `#[doc = "rust_fv::state_invariant::EXPR"]`
    - `callbacks.rs` test: a doc attr string `"rust_fv::state_invariant::x >= 0"` extracts into `state_invariant = Some(SpecExpr { expr: "x >= 0" })`
    GREEN: Implement minimal code to pass.
    REFACTOR: Run `cargo clippy --workspace` and fix any warnings. Run `cargo fmt --all`.
  </behavior>

  <implementation>
    1. Run `cargo test --workspace` to establish baseline (all passing).
    2. Add RED tests (should fail to compile or assert wrong values).
    3. Add IR types to ir.rs (CoroutineExitKind, CoroutineState, CoroutineInfo). Update Contracts and Function structs.
    4. Add VcKind variants to vcgen.rs. Update exhaustive match arms.
    5. Add state_invariant macro to macros/src/lib.rs.
    6. Add state_invariant extraction to callbacks.rs.
    7. Run `cargo test --workspace` — all GREEN (no regressions + new tests pass).
    8. Run `cargo clippy --workspace -- -D warnings` — clean.
    9. Run `cargo fmt --all --check`.
    10. Commit: `feat(23-01): add CoroutineInfo IR types, VcKind async variants, #[state_invariant] macro`
  </implementation>
</feature>

<verification>
Run: `cargo test --workspace 2>&1 | tail -5` — all tests pass, no regressions.
Run: `cargo clippy --workspace -- -D warnings` — no warnings.
Run: `grep -n "AsyncStateInvariantSuspend\|AsyncStateInvariantResume\|AsyncPostcondition" crates/analysis/src/vcgen.rs` — 3 lines found.
Run: `grep -n "pub coroutine_info\|pub state_invariant" crates/analysis/src/ir.rs` — 2 lines found.
Run: `grep -n "pub fn state_invariant" crates/macros/src/lib.rs` — 1 line found.
Run: `grep -n "rust_fv::state_invariant" crates/driver/src/callbacks.rs` — at least 1 line found.
</verification>

<success_criteria>
- CoroutineInfo, CoroutineState, CoroutineExitKind types in ir.rs, compile cleanly
- Contracts.state_invariant: Option&lt;SpecExpr&gt; added (default None)
- Function.coroutine_info: Option&lt;CoroutineInfo&gt; added (default None)
- VcKind has AsyncStateInvariantSuspend, AsyncStateInvariantResume, AsyncPostcondition
- #[state_invariant(expr)] macro compiles and emits doc attribute
- callbacks.rs extract_contracts() populates state_invariant from doc attr
- cargo test --workspace: all green, zero regressions
- cargo clippy --workspace: zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/23-async-await/23-01-SUMMARY.md`
</output>

---
phase: 23-async-await
plan: "03"
type: tdd
wave: 3
depends_on:
  - "23-01"
  - "23-02"
files_modified:
  - crates/analysis/src/async_vcgen.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/vcgen.rs
  - crates/driver/src/json_output.rs
autonomous: true
requirements:
  - ASY-01
  - ASY-02

must_haves:
  truths:
    - "generate_async_vcs() returns AsyncPostcondition VC when async fn has #[ensures]"
    - "generate_async_vcs() returns AsyncStateInvariantSuspend + AsyncStateInvariantResume VCs per Yield state when #[state_invariant] is present"
    - "vcgen.rs dispatches to async_vcgen when func.coroutine_info.is_some()"
    - "JsonCounterexample has poll_iteration: Option<usize> and await_side: Option<String> fields"
    - "select! non-deterministic encoding: boolean SMT branch variable generated per select! site"
    - "join! sequential encoding: consecutive Yield states handled naturally (no special code needed)"
  artifacts:
    - path: "crates/analysis/src/async_vcgen.rs"
      provides: "generate_async_vcs() function generating per-state VCs"
      contains: "pub fn generate_async_vcs"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "dispatch to async_vcgen when coroutine_info present"
      contains: "async_vcgen::generate_async_vcs"
    - path: "crates/driver/src/json_output.rs"
      provides: "JsonCounterexample with poll_iteration + await_side async fields"
      contains: "poll_iteration"
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/async_vcgen.rs"
      via: "if func.coroutine_info.is_some() dispatch"
      pattern: "async_vcgen::generate_async_vcs"
    - from: "crates/analysis/src/async_vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Function.coroutine_info + contracts.state_invariant + contracts.ensures"
      pattern: "func\\.coroutine_info"
---

<objective>
Implement async_vcgen.rs (the VC generator for async functions) and wire it into the existing dispatch in vcgen.rs.

Purpose: This is the core verification engine for Phase 23. It generates per-coroutine-state SMT VCs for #[state_invariant] (at suspension + resumption) and #[ensures] (at Poll::Ready), following the established hof_vcgen.rs dispatch pattern. Also extends JsonCounterexample with async-specific fields.

Output: New async_vcgen.rs module + modified vcgen.rs dispatch + modified json_output.rs with poll_iteration/await_side fields.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-async-await/23-CONTEXT.md
@.planning/phases/23-async-await/23-RESEARCH.md
@.planning/phases/23-async-await/23-01-SUMMARY.md
@.planning/phases/23-async-await/23-02-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/hof_vcgen.rs
@crates/analysis/src/ir.rs
@crates/driver/src/json_output.rs
</context>

<feature>
  <name>async_vcgen.rs + vcgen.rs dispatch + JsonCounterexample async extension</name>
  <files>
    crates/analysis/src/async_vcgen.rs,
    crates/analysis/src/lib.rs,
    crates/analysis/src/vcgen.rs,
    crates/driver/src/json_output.rs
  </files>

  <behavior>
    ### async_vcgen.rs (NEW file, ~200-300 lines)

    Follow hof_vcgen.rs exactly as the structural pattern. Use QF_LIA logic (not AUFLIA — no quantifiers needed for bounded state enumeration).

    ```rust
    //! Async function verification condition generator.
    //!
    //! Generates VCs for `async fn` bodies under the sequential polling model.
    //! Each `.await` suspension point (CoroutineExitKind::Yield) produces two VCs:
    //! - AsyncStateInvariantSuspend: invariant holds just before yielding
    //! - AsyncStateInvariantResume: invariant holds just after resuming
    //!
    //! The Poll::Ready terminal state produces one VC:
    //! - AsyncPostcondition: #[ensures] holds when the future resolves

    use rust_fv_smtlib::command::Command;
    use rust_fv_smtlib::script::Script;
    use rust_fv_smtlib::term::Term;

    use crate::ir::{CoroutineExitKind, Function, Ty};
    use crate::spec_parser::parse_spec_expr_with_db;
    use crate::vcgen::{VcKind, VcLocation, VerificationCondition};
    use crate::ghost_predicate_db::GhostPredicateDatabase;

    pub fn generate_async_vcs(
        func: &Function,
        ghost_pred_db: &GhostPredicateDatabase,
    ) -> Vec<VerificationCondition> {
        let Some(coro_info) = &func.coroutine_info else {
            return vec![];
        };

        let mut vcs = Vec::new();

        // ASY-01: Postcondition VC — #[ensures] at Poll::Ready resolution
        for ensures_expr in &func.contracts.ensures {
            vcs.push(generate_async_postcondition_vc(func, coro_info, ensures_expr, ghost_pred_db));
        }

        // ASY-02: State invariant VCs — at each Yield state (suspension + resumption)
        if let Some(invariant) = &func.contracts.state_invariant {
            for state in &coro_info.states {
                if state.exit_kind == CoroutineExitKind::Yield {
                    vcs.push(generate_invariant_vc(func, coro_info, state, invariant, "suspension", ghost_pred_db));
                    vcs.push(generate_invariant_vc(func, coro_info, state, invariant, "resumption", ghost_pred_db));
                }
            }
        }

        vcs
    }
    ```

    ### SMT script structure for AsyncPostcondition VC

    Follows the same script-building pattern as hof_vcgen.rs:

    1. `(set-logic QF_LIA)` — sufficient for most async contracts (no quantifiers)
    2. Declare persistent fields as SMT constants: `(declare-const FIELD_NAME TYPE)`
    3. Declare a `poll_iter` Int constant bounded by state count (for counterexample)
    4. Apply #[requires] as assumptions: `(assert REQUIRES_EXPR)` — timing: at call site (state 0)
    5. Assert negated #[ensures]: `(assert (not ENSURES_EXPR))` — at Poll::Ready
    6. `(check-sat)` — UNSAT = postcondition proven

    The `result` variable in #[ensures] maps to the async fn's return local (`_0`). Declare it as a persistent field if not already present.

    ### SMT script structure for AsyncStateInvariantSuspend/Resume VC

    For state S with invariant I:

    **Suspension check** (invariant holds before Yield at state S):
    ```smt2
    (set-logic QF_LIA)
    ; Declare persistent fields (cross-await locals)
    (declare-const x Int)
    ; ... other fields ...
    ; Poll iteration context (for counterexample diagnostics)
    (declare-const poll_iter Int)
    (assert (= poll_iter S_ID))
    ; Assert state S code constraints (simplified: just the declared field values)
    ; Negate the invariant — UNSAT means invariant holds
    (assert (not INVARIANT_EXPR))
    (check-sat)
    ```

    **Resumption check** (invariant holds after Yield resume at state S):
    Same structure but with `await_side = "resumption"` in the VC metadata.
    Optionally declare `awaited_result_S` constant for the value returned by the S-th .await,
    which the invariant can reference per CONTEXT.md (locked decision).

    ### select! encoding (locked: non-deterministic branch)

    In generate_async_vcs, when a coroutine state contains multiple Yield terminators with the same source line (conservative detection of select!-like patterns):

    ```rust
    // Introduce boolean branch variable for non-deterministic choice
    // (declare-const select_branch_STATE Bool)
    // Generate invariant checks under both branches
    ```

    Add a `tracing::debug!` note: "select!-like construct detected in state {}, applying non-deterministic branch encoding".

    ### join! encoding (locked: sequential)

    join! desugars to consecutive Yields — each maps to a separate CoroutineState naturally.
    No special code needed. The state extraction loop in mir_converter.rs already handles this.

    ### vcgen.rs addition (after HOF dispatch block, before the final tracing::info!)

    ```rust
    // ASY-01 / ASY-02: Generate async VCs if this is an async fn (coroutine)
    if func.coroutine_info.is_some() {
        let async_vcs = crate::async_vcgen::generate_async_vcs(func, ghost_pred_db);
        conditions.extend(async_vcs);
    }
    ```

    ### json_output.rs addition (additive fields on JsonCounterexample)

    ```rust
    pub struct JsonCounterexample {
        pub variables: Vec<JsonCexVariable>,
        pub failing_location: JsonLocation,
        pub vc_kind: String,
        pub violated_spec: Option<String>,
        /// For async VCs: which poll iteration (0-based state_id) triggered the violation.
        /// Absent for non-async VCs.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub poll_iteration: Option<usize>,
        /// For async VCs: "suspension" or "resumption" side of the .await.
        /// Absent for non-async VCs.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub await_side: Option<String>,
    }
    ```

    Update any JsonCounterexample construction sites to include `poll_iteration: None, await_side: None` (backward-compatible defaults).

    ### lib.rs addition

    Add `pub mod async_vcgen;` to crates/analysis/src/lib.rs after the `pub mod hof_vcgen;` line.

    ### TDD cycle

    RED: In async_vcgen.rs, write tests before implementation:
    - `test_generate_async_vcs_empty_for_non_coroutine`: Function with coroutine_info: None → empty Vec
    - `test_generate_async_vcs_postcondition_vc`: Function with coroutine_info + ensures → Vec with 1 AsyncPostcondition VC
    - `test_generate_async_vcs_state_invariant_vcs`: Function with coroutine_info (2 Yield states) + state_invariant → Vec with 4 VCs (2 suspend + 2 resume)
    - `test_generate_async_vcs_vc_kinds`: Assert VcKind::AsyncStateInvariantSuspend and VcKind::AsyncPostcondition appear in output

    GREEN: Implement generate_async_vcs and helpers.
    REFACTOR: Run clippy, fix warnings.

    Commit messages:
    - RED: `test(23-03): add failing async_vcgen tests`
    - GREEN: `feat(23-03): implement async_vcgen, vcgen dispatch, JsonCounterexample async fields`
    - REFACTOR (if needed): `refactor(23-03): clean up async VC generation`
  </behavior>

  <implementation>
    1. Run `cargo test --workspace` — baseline.
    2. Create crates/analysis/src/async_vcgen.rs with RED tests only (empty generate_async_vcs stub returning vec![]).
    3. Add `pub mod async_vcgen;` to lib.rs.
    4. Run RED tests — they fail (VCs not generated yet).
    5. Implement generate_async_vcs, generate_async_postcondition_vc, generate_invariant_vc.
    6. Add vcgen.rs dispatch (the if coroutine_info.is_some() block after HOF section).
    7. Add poll_iteration + await_side fields to JsonCounterexample in json_output.rs. Update construction sites.
    8. Run `cargo test --workspace` — all GREEN.
    9. Run `cargo clippy --workspace -- -D warnings` — clean.
    10. Run `cargo fmt --all --check`.
    11. Commit.
  </implementation>
</feature>

<verification>
Run: `cargo test --workspace 2>&1 | tail -5` — all tests pass.
Run: `cargo clippy --workspace -- -D warnings` — no warnings.
Run: `grep -n "pub fn generate_async_vcs" crates/analysis/src/async_vcgen.rs` — 1 line found.
Run: `grep -n "async_vcgen::generate_async_vcs" crates/analysis/src/vcgen.rs` — 1 line found.
Run: `grep -n "poll_iteration\|await_side" crates/driver/src/json_output.rs` — at least 2 lines found.
Run: `grep -n "pub mod async_vcgen" crates/analysis/src/lib.rs` — 1 line found.
</verification>

<success_criteria>
- async_vcgen.rs exists with generate_async_vcs() implemented
- vcgen.rs dispatches to async_vcgen when coroutine_info is Some
- AsyncPostcondition VC generated for #[ensures] on async fn
- AsyncStateInvariantSuspend + AsyncStateInvariantResume VCs generated per Yield state
- JsonCounterexample has poll_iteration: Option&lt;usize&gt; + await_side: Option&lt;String&gt;
- cargo test --workspace: all green, zero regressions
- cargo clippy --workspace: zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/23-async-await/23-03-SUMMARY.md`
</output>

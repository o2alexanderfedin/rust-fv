---
phase: 23-async-await
plan: "04"
type: tdd
wave: 4
depends_on:
  - "23-03"
files_modified:
  - crates/analysis/src/async_vcgen.rs
autonomous: true
requirements:
  - ASY-01
  - ASY-02

must_haves:
  truths:
    - "ASY-01: async fn with valid #[requires]/#[ensures] passes verification (UNSAT returned by Z3)"
    - "ASY-01: async fn with violated #[ensures] (post that cannot hold) returns SAT with AsyncPostcondition VcKind"
    - "ASY-02: async fn with valid #[state_invariant] at all .await points passes verification"
    - "ASY-02: async fn with state_invariant that is violated at a specific .await returns SAT with AsyncStateInvariantSuspend or AsyncStateInvariantResume VcKind"
    - "Counterexample for state invariant violation includes poll_iteration field indicating which state failed"
    - "Nested async fn call (callee has #[ensures]) is used as precondition assumption correctly"
  artifacts:
    - path: "crates/analysis/src/async_vcgen.rs"
      provides: "TDD integration test suite for ASY-01 and ASY-02"
      contains: "async_postcondition_verified\|async_postcondition_violated\|state_invariant_verified\|state_invariant_violated"
  key_links:
    - from: "crates/analysis/src/async_vcgen.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "generate_async_vcs called from generate_vcs_with_db"
      pattern: "generate_vcs_with_db.*coroutine"
---

<objective>
Write the TDD integration test suite proving ASY-01 and ASY-02 correctness against a live Z3 solver.

Purpose: These end-to-end tests are the soundness specification for Phase 23. They prove that the full pipeline (IR construction → async VC generation → Z3 solving) produces correct verdicts for both the postcondition (ASY-01) and state invariant (ASY-02) requirements. Following the established TDD pattern from Phase 22 HOF tests and Phase 21 RC11 litmus tests.

Output: Integration tests in async_vcgen.rs (or a test module) that build ir::Function objects with coroutine_info populated, run generate_vcs_with_db, solve via Z3, and assert correct UNSAT/SAT outcomes.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-async-await/23-CONTEXT.md
@.planning/phases/23-async-await/23-RESEARCH.md
@.planning/phases/23-async-await/23-01-SUMMARY.md
@.planning/phases/23-async-await/23-02-SUMMARY.md
@.planning/phases/23-async-await/23-03-SUMMARY.md
@crates/analysis/src/async_vcgen.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/hof_vcgen.rs
</context>

<feature>
  <name>ASY-01 and ASY-02 TDD Integration Test Suite</name>
  <files>crates/analysis/src/async_vcgen.rs</files>

  <behavior>
    Follow the same test pattern as hof_vcgen.rs tests (Phase 22) and rc11.rs tests (Phase 21).

    Each test:
    1. Constructs an ir::Function with coroutine_info populated (2-3 coroutine states)
    2. Calls generate_vcs_with_db() or generate_async_vcs() directly
    3. Solves each VC via Z3Solver::check_sat_raw or the existing test helper
    4. Asserts Unsat (proven) or Sat (counterexample found) per the scenario

    Use the same Z3Solver setup pattern as existing integration tests in the codebase.

    ### Test Cases (6 tests total)

    **ASY-01 Tests (3 tests):**

    1. `test_async_postcondition_verified`
       - async fn increment(x: i32) → i32 with #[ensures(result == x + 1)]
       - Build ir::Function with coroutine_info (1 Yield state + 1 Return state)
       - persistent_fields: [("x", Ty::Int(IntTy::I32))]
       - ensures: SpecExpr { expr: "result == x + 1" }
       - Run generate_vcs_with_db → get AsyncPostcondition VC
       - Assert Z3 returns Unsat (postcondition provable from code constraints)
       - Note: The SMT encoding must include the code path constraint `result = x + 1` as an assumption.

    2. `test_async_postcondition_violated`
       - async fn bad_double(x: i32) → i32 with #[ensures(result == x * 3)]
       - Code actually computes result = x * 2 (wrong postcondition)
       - Assert Z3 returns Sat (postcondition violated)
       - Assert VcKind is AsyncPostcondition

    3. `test_async_requires_precondition`
       - async fn sqrt_approx(x: i32) → i32 with #[requires(x >= 0)] #[ensures(result >= 0)]
       - With precondition as assumption: assert Z3 returns Unsat
       - Without precondition (remove assumption): assert Z3 returns Sat (can construct negative x)

    **ASY-02 Tests (3 tests):**

    4. `test_async_state_invariant_verified`
       - async fn process(counter: i32) with #[state_invariant(counter >= 0)]
       - 2 .await points → 2 Yield states → 4 VCs (Suspend+Resume per state)
       - Build IR with persistent_fields: [("counter", Ty::Int(IntTy::I32))]
       - Add code constraint: counter initialized to 5, only incremented (never decremented)
       - Assert all 4 state invariant VCs return Unsat

    5. `test_async_state_invariant_violated_at_suspension`
       - async fn process(counter: i32) with #[state_invariant(counter > 0)]
       - Code can set counter = 0 before first .await
       - Assert that AsyncStateInvariantSuspend VC for state 0 returns Sat
       - Assert counterexample has VcKind::AsyncStateInvariantSuspend
       - If poll_iteration is surfaced in the VC metadata, assert poll_iteration == 0

    6. `test_async_state_invariant_resumption_references_await_result`
       - async fn fetch(base: i32) with #[state_invariant(awaited_result >= 0)]
       - The invariant references awaited_result (the result of the .await expression)
       - Declare awaited_result_0 as an SMT constant (unconstrained = may be negative)
       - Assert Resumption VC for state 0 returns Sat (awaited_result could be negative)
       - This validates the locked CONTEXT.md decision: invariant CAN reference the awaited result

    ### Helper construction

    Build a minimal ir::Function factory for tests:

    ```rust
    fn make_async_function(
        name: &str,
        params: Vec<(&str, Ty)>,
        persistent_fields: Vec<(String, Ty)>,
        yields: usize,
        ensures: Vec<&str>,
        state_invariant: Option<&str>,
        requires: Vec<&str>,
    ) -> ir::Function {
        // Build CoroutineInfo with `yields` Yield states + 1 Return state
        let mut states: Vec<ir::CoroutineState> = (0..yields)
            .map(|id| ir::CoroutineState {
                state_id: id,
                entry_block: id,
                exit_kind: ir::CoroutineExitKind::Yield,
                await_source_line: Some((10 + id * 5) as u32),
            })
            .collect();
        states.push(ir::CoroutineState {
            state_id: yields,
            entry_block: yields,
            exit_kind: ir::CoroutineExitKind::Return,
            await_source_line: None,
        });

        let coro_info = ir::CoroutineInfo {
            states,
            persistent_fields: persistent_fields.clone(),
        };

        ir::Function {
            name: name.to_string(),
            // ... build minimal Function with contracts, coroutine_info, etc.
            contracts: ir::Contracts {
                requires: requires.iter().map(|e| ir::SpecExpr { expr: e.to_string() }).collect(),
                ensures: ensures.iter().map(|e| ir::SpecExpr { expr: e.to_string() }).collect(),
                state_invariant: state_invariant.map(|e| ir::SpecExpr { expr: e.to_string() }),
                ..Default::default()
            },
            coroutine_info: Some(coro_info),
            // ... other required fields as per current ir::Function definition
        }
    }
    ```

    Adapt SpecExpr construction to match whatever fields ir::SpecExpr has (check from 23-01-SUMMARY.md).

    ### TDD cycle

    RED: Write all 6 tests against the generate_async_vcs or generate_vcs_with_db API. Run → RED (tests fail because async VC generation is incomplete or assertions are wrong).
    GREEN: Fix any gaps in generate_async_vcs.rs (from Plan 03) until all 6 tests pass.
    REFACTOR: Run clippy, fmt. Ensure tests are well-named and documented.

    Commit messages:
    - RED: `test(23-04): add failing ASY-01 and ASY-02 integration tests`
    - GREEN: `feat(23-04): all async/await integration tests pass — ASY-01 and ASY-02 complete`
    - REFACTOR (if needed): `refactor(23-04): clean up async integration test helpers`
  </behavior>

  <implementation>
    1. Read hof_vcgen.rs tests section for exact test helper pattern.
    2. Run `cargo test --workspace` — baseline.
    3. Add RED tests (all 6) — run, confirm they fail.
    4. Fix any gaps in async_vcgen.rs (SMT encoding corrections, missing constraints).
    5. Run tests until GREEN.
    6. Run `cargo test --workspace` — all GREEN, no regressions.
    7. Run `cargo clippy --workspace -- -D warnings` — clean.
    8. Run `cargo fmt --all --check`.
    9. Commit.
  </implementation>
</feature>

<verification>
Run: `cargo test --workspace 2>&1 | grep -E "async|ASY|FAILED|test result"` — async tests present and passing.
Run: `cargo test -p rust_fv_analysis async 2>&1 | tail -10` — 6 async tests pass.
Run: `cargo clippy --workspace -- -D warnings` — no warnings.
Confirm: `test_async_postcondition_verified` → Unsat.
Confirm: `test_async_postcondition_violated` → Sat (AsyncPostcondition kind).
Confirm: `test_async_state_invariant_verified` → all 4 VCs Unsat.
Confirm: `test_async_state_invariant_violated_at_suspension` → AsyncStateInvariantSuspend Sat.
</verification>

<success_criteria>
- 6 integration tests in async_vcgen.rs: all pass (green)
- ASY-01: Valid async postcondition verifies (UNSAT), invalid fails (SAT)
- ASY-02: Valid state invariant at all .await points verifies (UNSAT), violation detected (SAT)
- poll_iteration present in failing async VC counterexample metadata
- cargo test --workspace: all green, zero regressions
- cargo clippy --workspace: zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/23-async-await/23-04-SUMMARY.md`
</output>

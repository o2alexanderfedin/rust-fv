---
phase: 23-async-await
plan: "02"
type: tdd
wave: 2
depends_on:
  - "23-01"
files_modified:
  - crates/driver/src/mir_converter.rs
autonomous: true
requirements:
  - ASY-01
  - ASY-02

must_haves:
  truths:
    - "async fn bodies are detected in mir_converter.rs and produce CoroutineInfo populated on ir::Function"
    - "TerminatorKind::Yield terminators are found and mapped to CoroutineState entries with correct state_id and exit_kind"
    - "Persistent fields (named locals spanning .await) are extracted into CoroutineInfo.persistent_fields"
    - "Non-async functions have coroutine_info: None (no regression)"
    - "MIR shape validated for nightly-2026-02-11 before implementing state extraction"
  artifacts:
    - path: "crates/driver/src/mir_converter.rs"
      provides: "Coroutine detection + CoroutineInfo extraction from MIR body"
      contains: "extract_coroutine_info"
  key_links:
    - from: "crates/driver/src/mir_converter.rs"
      to: "crates/analysis/src/ir.rs"
      via: "ir::CoroutineInfo populated from body.coroutine + Yield terminators"
      pattern: "CoroutineInfo\\s*\\{"
---

<objective>
Implement coroutine detection and CoroutineInfo extraction in the MIR converter.

Purpose: The MIR converter (mir_converter.rs) is the only crate that has rustc TyCtxt access. Coroutine detection MUST happen here — not in the analysis crate. This plan implements extract_coroutine_info() that populates the CoroutineInfo field added to ir::Function in Plan 01.

Output: Modified mir_converter.rs that detects async fn bodies, enumerates Yield terminators as state boundaries, extracts persistent locals, and attaches CoroutineInfo to the resulting ir::Function.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-async-await/23-CONTEXT.md
@.planning/phases/23-async-await/23-RESEARCH.md
@.planning/phases/23-async-await/23-01-SUMMARY.md
@crates/driver/src/mir_converter.rs
@crates/analysis/src/ir.rs
</context>

<feature>
  <name>MIR Coroutine Detection and CoroutineInfo Extraction</name>
  <files>crates/driver/src/mir_converter.rs</files>

  <behavior>
    ### MANDATORY FIRST STEP: Validate MIR shape

    Before writing any production code, run:

    ```bash
    # Create a minimal test project to inspect MIR shape
    cd /tmp && cargo new --edition 2021 async_mir_test
    # Write a simple async fn to the src/main.rs
    cat > /tmp/async_mir_test/src/main.rs << 'RUST'
    async fn simple_async(x: i32) -> i32 {
        let y = std::future::ready(x + 1).await;
        y * 2
    }
    fn main() {}
    RUST
    # Use the project's nightly toolchain to inspect MIR
    RUSTFLAGS="-Zunpretty=mir" cargo +nightly check --manifest-path /tmp/async_mir_test/Cargo.toml 2>&1 | grep -A 40 "fn simple_async"
    ```

    Confirm observations:
    1. Is `TerminatorKind::Yield` present in the pre-transform body (at `after_analysis` hook)?
    2. What does a Yield terminator look like (fields: value, resume, resume_arg, drop)?
    3. How many Yield terminators appear per source-level `.await`? (Pitfall 3 from RESEARCH.md: desugaring may create multiple Yield per source `.await`)
    4. Are local variables that persist across `.await` identifiable from `var_debug_info`?

    If Yield terminators are NOT present (post-transform MIR), use the `SwitchInt` on coroutine discriminant as the state boundary instead. Document the finding in the SUMMARY.

    ### Implementation in mir_converter.rs

    After the existing conversion logic in `convert_mir()`, add:

    ```rust
    // ASY-01 / ASY-02: Detect async fn (coroutine) and extract state machine info
    let coroutine_info = body.coroutine.as_ref().and_then(|coro| {
        use rustc_hir::{CoroutineDesugaring, CoroutineKind};
        let is_async = matches!(
            coro.coroutine_kind,
            CoroutineKind::Desugared(CoroutineDesugaring::Async, _)
        );
        if is_async {
            Some(extract_coroutine_info(body))
        } else {
            None
        }
    });
    ```

    And in the `ir::Function { ... }` construction:
    ```rust
    ir::Function {
        // ... existing fields ...
        coroutine_info,
    }
    ```

    ### extract_coroutine_info() function

    ```rust
    fn extract_coroutine_info(body: &mir::Body<'_>) -> ir::CoroutineInfo {
        let mut states = Vec::new();
        let mut state_id = 0usize;

        for (bb_idx, bb_data) in body.basic_blocks.iter_enumerated() {
            if let Some(term) = bb_data.terminator.as_ref() {
                if let mir::TerminatorKind::Yield { .. } = &term.kind {
                    states.push(ir::CoroutineState {
                        state_id,
                        entry_block: bb_idx.as_usize(),
                        exit_kind: ir::CoroutineExitKind::Yield,
                        await_source_line: Some(
                            body.source_scopes[term.source_info.scope]
                                .span
                                .lo()
                                .to_u32(),
                        ),
                    });
                    state_id += 1;
                }
            }
        }

        // Always add a final Return state (last resume through to Poll::Ready)
        states.push(ir::CoroutineState {
            state_id,
            entry_block: 0, // Placeholder; async_vcgen uses contracts not block traversal
            exit_kind: ir::CoroutineExitKind::Return,
            await_source_line: None,
        });

        // Extract persistent fields: conservatively use all named locals from var_debug_info.
        // coroutine_layout is None at after_analysis — cannot use it. See RESEARCH.md Pitfall 2.
        let persistent_fields = body
            .var_debug_info
            .iter()
            .filter_map(|vdi| {
                // Only include user-named locals (not compiler-generated temporaries)
                if vdi.name.as_str().starts_with('_') {
                    return None;
                }
                // Get the local index
                use rustc_middle::mir::VarDebugInfoContents;
                if let VarDebugInfoContents::Place(place) = &vdi.value {
                    if place.projection.is_empty() {
                        // Map MIR local index to an SMT name
                        let local = place.local;
                        let smt_name = vdi.name.as_str().to_string();
                        // Type: look up from local_decls — use conservative Ty::Int fallback
                        let ty = convert_ty_conservative(&body.local_decls[local].ty);
                        return Some((smt_name, ty));
                    }
                }
                None
            })
            .collect();

        ir::CoroutineInfo { states, persistent_fields }
    }
    ```

    For `convert_ty_conservative`: map rustc Ty to ir::Ty — reuse the existing `convert_ty()` helper in mir_converter.rs if it exists, or do a best-effort mapping: integers → Ty::Int(IntTy::I32) as fallback, bool → Ty::Bool, etc.

    ### Pitfall handling

    Per RESEARCH.md Pitfall 3: if the state count is much larger than expected (e.g., 3 Yield terminators for 1 source `.await`), it means the polling loop desugaring is visible. In that case, group consecutive Yield terminators in the same basic block range into one CoroutineState by tracking unique `await_source_line` values and deduplicating.

    Per RESEARCH.md Pitfall 2: `coroutine_layout` will be None — use `var_debug_info` for persistent fields as shown above. Do NOT call `.unwrap()` on `coroutine_layout`.

    Per STATE.md blocker: If Yield terminators are absent in the pre-transform MIR, fall back to detecting `SwitchInt` terminators on the coroutine discriminant local (the first local after the return local in coroutine bodies).

    ### TDD cycle

    RED: Add tests in mir_converter.rs (or a dedicated test module) that:
    - Create a mock MIR body with `coroutine` set and a `Yield` terminator → assert `extract_coroutine_info` returns CoroutineInfo with 2 states (1 Yield + 1 Return)
    - Create a mock non-async MIR body with `coroutine: None` → assert `coroutine_info` on resulting Function is None

    Note: MIR test mocking is complex. Use integration-style tests via `cargo test -p rust_fv_driver` if unit mocking is infeasible. If direct MIR construction is not available, write tests that verify the entire pipeline on a real async fn in the test suite (tests/integration/ or tests/ directory).

    GREEN: Implement extract_coroutine_info and the coroutine_info field wiring.
    REFACTOR: Run `cargo clippy -p rust_fv_driver -- -D warnings`. Fix warnings.

    Commit messages:
    - RED: `test(23-02): add failing coroutine detection tests`
    - GREEN: `feat(23-02): implement coroutine detection and CoroutineInfo extraction in mir_converter`
    - REFACTOR (if needed): `refactor(23-02): clean up coroutine extraction`
  </behavior>

  <implementation>
    1. Run the MANDATORY MIR shape validation step with RUSTFLAGS="-Zunpretty=mir". Document findings.
    2. Run `cargo test --workspace` — establish baseline.
    3. Add RED tests.
    4. Implement extract_coroutine_info() in mir_converter.rs.
    5. Wire coroutine_info into convert_mir() return value.
    6. Run `cargo test --workspace` — all GREEN.
    7. Run `cargo clippy -p rust_fv_driver -- -D warnings` — clean.
    8. Run `cargo fmt --all --check`.
    9. Commit.
  </implementation>
</feature>

<verification>
Run: `cargo test --workspace 2>&1 | tail -5` — all tests pass.
Run: `cargo clippy -p rust_fv_driver -- -D warnings` — no warnings.
Run: `grep -n "extract_coroutine_info\|coroutine_info" crates/driver/src/mir_converter.rs` — at least 3 lines found.
Run: `grep -n "coroutine_info:" crates/driver/src/mir_converter.rs` — present in Function construction.
</verification>

<success_criteria>
- MIR shape validated (Yield terminators confirmed or fallback strategy documented)
- extract_coroutine_info() implemented and compiles
- async fn bodies produce CoroutineInfo with at least 1 Yield state + 1 Return state
- Non-async functions produce coroutine_info: None
- cargo test --workspace: all green, zero regressions
- cargo clippy -p rust_fv_driver: zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/23-async-await/23-02-SUMMARY.md`
</output>

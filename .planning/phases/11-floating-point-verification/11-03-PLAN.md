---
phase: 11-floating-point-verification
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - crates/analysis/tests/float_verification.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Developer enables floating-point verification and verifier encodes f32/f64 as SMT FloatingPoint theory (IEEE 754)"
    - "Developer verifies FP operation and verifier generates NaN propagation VC"
    - "Developer sees Inf overflow check VC for operations that may overflow to infinity"
    - "Developer verifies FP comparison respecting IEEE 754 semantics (NaN != NaN, -0.0 == +0.0)"
    - "Developer receives performance warning when enabling FP verification"
  artifacts:
    - path: "crates/analysis/tests/float_verification.rs"
      provides: "End-to-end Z3 verification tests for all floating-point requirements"
      min_lines: 400
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Performance warning emission for FP verification"
      contains: "float_verification"
  key_links:
    - from: "crates/analysis/tests/float_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "generate_vcs produces FloatingPointNaN VCs for float functions"
      pattern: "generate_vcs"
    - from: "crates/analysis/tests/float_verification.rs"
      to: "rust_fv_solver"
      via: "Z3Solver checks float VCs (SAT/UNSAT)"
      pattern: "Z3Solver"
---

<objective>
Create end-to-end Z3 verification tests validating all Phase 11 requirements (FPV-01 through
FPV-06, INF-02) and add performance warning for FP verification activation.

Purpose: Validate the complete floating-point verification pipeline from IR construction through
SMT encoding to Z3 solving, ensuring IEEE 754 semantics are correctly verified. Add opt-in
performance warning per FPV-06 requirement.

Output: float_verification.rs e2e test file with Z3 tests for all requirements, performance
warning in diagnostics.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-floating-point-verification/11-RESEARCH.md
@.planning/phases/11-floating-point-verification/11-01-SUMMARY.md
@.planning/phases/11-floating-point-verification/11-02-SUMMARY.md
@crates/analysis/tests/unsafe_verification.rs
@crates/analysis/src/float_verification.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: End-to-end Z3 floating-point verification tests</name>
  <files>
    crates/analysis/tests/float_verification.rs
  </files>
  <action>
    Create crates/analysis/tests/float_verification.rs following the pattern in
    unsafe_verification.rs (build IR function, generate VCs, render to SMT-LIB, submit to Z3,
    assert SAT/UNSAT).

    Use QF_FP logic for pure float VCs, or QF_FPBV if mixing float and bitvector operations.
    Set-logic must be compatible with FloatingPoint theory.

    Tests to create (mapping to requirements):

    === FPV-01: f32/f64 mapped to IEEE 754 FloatingPoint sorts ===
    1. test_fpv01_f64_constant_encoding: Build function with f64 constant (e.g., 1.0),
       generate VCs, verify SMT-LIB output contains (_ FloatingPoint 11 53) sort declaration
       and (fp ...) literal encoding. Assert VC generation succeeds (not FLOAT_UNSUPPORTED).

    2. test_fpv01_f32_constant_encoding: Same as above but with f32 constant,
       verify (_ FloatingPoint 8 24) sort and encoding.

    === FPV-02: Float arithmetic with rounding mode (RNE) ===
    3. test_fpv02_float_add_rne: Build function computing x + y for f64 parameters,
       generate VCs. Verify output contains "(fp.add RNE" in SMT-LIB script.
       Submit to Z3 and verify NaN propagation VC is UNSAT (correct: non-NaN + non-NaN may
       produce NaN for 0.0/0.0-like patterns, so this may be SAT -- validate the VC structure).

    4. test_fpv02_float_mul_rne: Build function computing x * y for f64, verify "(fp.mul RNE".

    5. test_fpv02_float_div_rne: Build function computing x / y for f64, verify "(fp.div RNE".

    === FPV-03: NaN propagation VCs ===
    6. test_fpv03_nan_vc_generated: Build function with single f64 addition,
       verify at least one VC has description containing "NaN propagation" and
       vc_kind == VcKind::FloatingPointNaN.

    7. test_fpv03_nan_vc_count: Build function with 3 float operations (add, sub, mul),
       verify 3 NaN VCs generated (one per arithmetic op).

    8. test_fpv03_nan_div_zero: Build function dividing f64 by literal 0.0,
       generate NaN VC. Note: 1.0/0.0 = Inf (not NaN), but 0.0/0.0 = NaN.
       Verify the NaN VC correctly captures this (SAT for the 0.0/0.0 case because
       NaN can be produced).

    === FPV-04: Infinity overflow checks ===
    9. test_fpv04_infinity_vc_generated: Build function with float multiplication,
       verify at least one VC has description containing "Infinity" or "overflow".

    10. test_fpv04_infinity_vc_count: Build function with 2 float operations,
        verify 2 infinity VCs generated.

    === FPV-05: IEEE 754 comparison semantics ===
    11. test_fpv05_nan_not_equal_to_self: Build function comparing x == x for f64,
        generate VCs. The comparison should use fp.eq which returns false for NaN.
        Verify the encoding uses FpEq (not bitvector Eq).

    12. test_fpv05_neg_zero_equals_pos_zero: Build function comparing -0.0 == 0.0,
        verify encoding uses FpEq which correctly returns true for -0.0 == +0.0.

    13. test_fpv05_comparison_no_nan_vc: Build function with only float comparison (no arithmetic),
        verify NO NaN/Inf VCs are generated (comparisons don't produce NaN/Inf).

    === INF-02: VcKind::FloatingPointNaN ===
    14. test_inf02_vc_kind_present: Build function with float arithmetic,
        verify generated VCs include VcKind::FloatingPointNaN.

    Helper functions to create (follow unsafe_verification.rs patterns):
    - build_float_add_function(param_ty: FloatTy) -> Function: Creates function `fn f(x: f64, y: f64) -> f64 { x + y }`
    - build_float_mul_function(param_ty: FloatTy) -> Function: x * y
    - build_float_div_function(param_ty: FloatTy) -> Function: x / y
    - build_float_comparison_function(op: BinOp, param_ty: FloatTy) -> Function: x op y
    - build_multi_float_ops_function() -> Function: x + y, result * z (chained operations)

    Each test should:
    1. Build the IR Function
    2. Call generate_vcs(&func, &ContractDatabase::new())
    3. Assert expected VC count and vc_kind values
    4. Render VCs to SMT-LIB strings
    5. Verify FP-specific syntax appears (fp.add, fp.isNaN, etc.)
    6. Where applicable, submit to Z3Solver and check SAT/UNSAT
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    float_verification.rs exists with 14+ e2e tests covering all FPV requirements (FPV-01 through
    FPV-05) and INF-02. Tests validate float encoding, NaN VCs, infinity VCs, IEEE 754 comparison
    semantics, and VcKind::FloatingPointNaN integration. All tests pass with Z3. 0 regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Performance warning for FP verification (FPV-06)</name>
  <files>
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    Implement FPV-06: Performance warning when floating-point verification is enabled.

    In crates/driver/src/diagnostics.rs:

    1. Add `emit_float_verification_warning()` public function:
       - Prints a clear warning message to stderr:
         "warning: FloatingPoint verification enabled -- FPA theory is 2-10x slower than bitvectors.
          Consider limiting float verification to functions that need it."
       - Uses the same warning styling as other diagnostic messages in the file.

    2. Add detection logic: When a VC with VcKind::FloatingPointNaN is encountered in the
       results, emit the warning ONCE (use a flag/bool to prevent repeated warnings).
       This should be integrated into the result reporting flow -- when iterating over VCs
       to display results, if any VC has FloatingPointNaN kind, emit the warning before
       showing results.

    3. In report_text_only() or the main reporting function: Before the VC result loop,
       check if any VC has FloatingPointNaN kind. If so, call emit_float_verification_warning().

    4. Add test:
       - test_float_verification_warning_emitted: Verify emit_float_verification_warning()
         produces the expected warning text containing "2-10x slower" and "FloatingPoint".

    Note: The opt-in mechanism (flag/attribute) is for future work. In Phase 11, the warning
    is emitted whenever float VCs are present in verification results.
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Performance warning emitted when FloatingPointNaN VCs are present. Warning text mentions
    "2-10x slower" and "FloatingPoint". Warning emitted once per verification run (not per VC).
    FPV-06 requirement satisfied. All tests pass. 0 regressions. 0 warnings.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- All 5 success criteria from ROADMAP.md validated:
  1. f32/f64 encoded as SMT FloatingPoint (FPV-01) -- validated by test_fpv01_*
  2. NaN propagation VCs generated (FPV-03) -- validated by test_fpv03_*
  3. Infinity overflow VCs generated (FPV-04) -- validated by test_fpv04_*
  4. IEEE 754 comparison semantics (FPV-05) -- validated by test_fpv05_*
  5. Performance warning emitted (FPV-06) -- validated by test_float_verification_warning
- All 7 requirements validated (FPV-01 through FPV-06, INF-02)
- ~15 new tests total across both tasks
</verification>

<success_criteria>
1. End-to-end Z3 tests validate all FPV requirements with real solver
2. Float encoding produces valid SMT-LIB that Z3 accepts
3. NaN and infinity VCs are checked by Z3
4. IEEE 754 comparison semantics verified (NaN != NaN, -0.0 == +0.0)
5. Performance warning emitted when float VCs present
6. All Phase 11 success criteria from ROADMAP.md satisfied
7. ~15 new tests passing, 0 regressions, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-floating-point-verification/11-03-SUMMARY.md`
</output>

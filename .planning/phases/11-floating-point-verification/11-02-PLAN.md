---
phase: 11-floating-point-verification
plan: 02
type: tdd
wave: 2
depends_on: ["11-01"]
files_modified:
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/float_verification.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Float constants encode as IEEE 754 FP literals (not FLOAT_UNSUPPORTED)"
    - "Float binary operations (add, sub, mul, div) encode with FP terms and RNE rounding mode"
    - "Float comparison operations use IEEE 754 semantics (fp.eq, fp.lt, fp.leq, fp.gt, fp.geq)"
    - "NaN propagation VCs generated for all float arithmetic operations"
    - "Infinity overflow VCs generated for float operations that may overflow"
    - "Float unary operations (neg, abs) encode with FP terms"
    - "VCGen integrates float VC generation when function contains float operations"
  artifacts:
    - path: "crates/analysis/src/encode_term.rs"
      provides: "Float constant encoding, float binop/unop/comparison encoding"
      contains: "encode_float_constant"
    - path: "crates/analysis/src/float_verification.rs"
      provides: "NaN propagation and infinity overflow VC generation"
      exports: ["nan_propagation_vc", "infinity_overflow_vc", "generate_float_vcs"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Float VC generation integrated into generate_vcs pipeline"
      contains: "float_verification"
    - path: "crates/analysis/src/lib.rs"
      provides: "float_verification module exported"
      contains: "mod float_verification"
  key_links:
    - from: "crates/analysis/src/encode_term.rs"
      to: "crates/smtlib/src/term.rs"
      via: "FpNaN, FpFromBits, FpAdd, FpEq etc. Term variants"
      pattern: "Term::Fp"
    - from: "crates/analysis/src/float_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VerificationCondition, VcLocation, VcKind types"
      pattern: "use crate::vcgen::"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/float_verification.rs"
      via: "generate_float_vcs called during VC generation for float-typed operations"
      pattern: "float_verification::"
    - from: "crates/analysis/src/float_verification.rs"
      to: "crates/smtlib/src/term.rs"
      via: "FpIsNaN, FpIsInfinite predicates for VC assertions"
      pattern: "Term::FpIsNaN"
---

<objective>
Replace FLOAT_UNSUPPORTED placeholder with IEEE 754 float encoding, create float_verification.rs
module for NaN/Inf VC generation, and integrate float VCs into the VCGen pipeline.

Purpose: Enable actual floating-point verification by encoding float constants, arithmetic,
comparisons, and unary operations as SMT-LIB FloatingPoint terms, and generating NaN propagation
and infinity overflow VCs for all float operations.

Output: Working float encoding in encode_term.rs, new float_verification.rs module with NaN/Inf
VC generation, VCGen integration that produces float VCs for functions with float operations.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-floating-point-verification/11-RESEARCH.md
@.planning/phases/11-floating-point-verification/11-01-SUMMARY.md
@crates/analysis/src/encode_term.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/lib.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Float constant and operation encoding in encode_term.rs (TDD)</name>
  <files>
    crates/analysis/src/encode_term.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    Replace the FLOAT_UNSUPPORTED placeholder with proper IEEE 754 encoding.

    1. Add `encode_float_constant(value: f64, fty: FloatTy) -> Term` function:
       - If value.is_nan() -> Term::FpNaN(eb, sb)
       - If value.is_infinite() and positive -> Term::FpPosInf(eb, sb)
       - If value.is_infinite() and negative -> Term::FpNegInf(eb, sb)
       - If value == 0.0 and positive -> Term::FpPosZero(eb, sb)
       - If value == 0.0 and negative -> Term::FpNegZero(eb, sb)
       - Otherwise -> Term::FpFromBits(sign, exp, sig, eb, sb) using to_bits()
       - f32: eb=8, sb=24. f64: eb=11, sb=53.
       - For FpFromBits: sign = top bit, exp = next eb bits, sig = bottom (sb-1) bits
       - For f32: cast value to f32 first, then use f32::to_bits() as u64

    2. Update encode_constant() to call encode_float_constant instead of FLOAT_UNSUPPORTED.

    3. Add `encode_fp_binop(op: BinOp, lhs: &Term, rhs: &Term) -> Term` function:
       - Creates RoundingMode("RNE") for arithmetic operations
       - Add -> Term::FpAdd(rm, lhs, rhs)
       - Sub -> Term::FpSub(rm, lhs, rhs)
       - Mul -> Term::FpMul(rm, lhs, rhs)
       - Div -> Term::FpDiv(rm, lhs, rhs)
       - For comparisons (float type detected by caller):
         Eq -> Term::FpEq(lhs, rhs) (IEEE 754: NaN != NaN, -0.0 == +0.0)
         Ne -> Term::Not(Term::FpEq(lhs, rhs))
         Lt -> Term::FpLt(lhs, rhs)
         Le -> Term::FpLeq(lhs, rhs)
         Gt -> Term::FpGt(lhs, rhs)
         Ge -> Term::FpGeq(lhs, rhs)
       - Bitwise/shift ops: panic!("unsupported float binop: {op:?}")

    4. Add `encode_fp_unop(op: UnOp, operand: &Term) -> Term` function:
       - Neg -> Term::FpNeg(operand)
       - Not -> panic (not valid for floats)

    5. Update encode_binop() to dispatch to encode_fp_binop when ty is Ty::Float(_).
       Check `matches!(ty, Ty::Float(_))` at the top of encode_binop; if true, call encode_fp_binop.

    6. Update encode_unop (if it exists) similarly to dispatch to encode_fp_unop for float types.

    7. Update the existing test_float_constant test to expect FpFromBits instead of FLOAT_UNSUPPORTED.
       Update any other tests that assert FLOAT_UNSUPPORTED to expect proper FP encoding.

    Tests to write FIRST (RED phase):
    - test_encode_float_constant_f64_1_0: encode_float_constant(1.0, F64) produces FpFromBits with correct bits
    - test_encode_float_constant_f32_1_0: encode_float_constant(1.0, F32) produces FpFromBits for f32
    - test_encode_float_constant_nan: encode_float_constant(f64::NAN, F64) produces FpNaN(11, 53)
    - test_encode_float_constant_pos_inf: encode_float_constant(f64::INFINITY, F64) produces FpPosInf(11, 53)
    - test_encode_float_constant_neg_inf: encode_float_constant(f64::NEG_INFINITY, F64) produces FpNegInf(11, 53)
    - test_encode_float_constant_pos_zero: encode_float_constant(0.0, F64) produces FpPosZero(11, 53)
    - test_encode_float_constant_neg_zero: encode_float_constant(-0.0_f64, F64) -- note: -0.0 is sign-negative
    - test_encode_fp_binop_add: encode_fp_binop(Add, x, y) produces FpAdd with RNE
    - test_encode_fp_binop_sub: encode_fp_binop(Sub, x, y) produces FpSub with RNE
    - test_encode_fp_binop_mul: encode_fp_binop(Mul, x, y) produces FpMul with RNE
    - test_encode_fp_binop_div: encode_fp_binop(Div, x, y) produces FpDiv with RNE
    - test_encode_fp_comparison_eq: encode_fp_binop(Eq, x, y) produces FpEq (not BV Eq)
    - test_encode_fp_comparison_lt: encode_fp_binop(Lt, x, y) produces FpLt
    - test_encode_fp_comparison_le: encode_fp_binop(Le, x, y) produces FpLeq
    - test_encode_fp_comparison_gt: encode_fp_binop(Gt, x, y) produces FpGt
    - test_encode_fp_comparison_ge: encode_fp_binop(Ge, x, y) produces FpGeq
    - test_encode_fp_unop_neg: encode_fp_unop(Neg, x) produces FpNeg
    - test_encode_binop_dispatches_float: encode_binop(Add, x, y, &Ty::Float(F64)) produces FpAdd (not BvAdd)
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    FLOAT_UNSUPPORTED completely removed from encode_term.rs. Float constants encode as FpFromBits/FpNaN/FpPosInf/FpNegInf/FpPosZero/FpNegZero.
    Float arithmetic uses FpAdd/FpSub/FpMul/FpDiv with RNE rounding. Float comparisons use FpEq/FpLt/FpLeq/FpGt/FpGeq.
    ~18 new encoding tests pass. All existing tests pass with updated expectations. 0 clippy warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Float verification module and VCGen integration (TDD)</name>
  <files>
    crates/analysis/src/float_verification.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    1. Create crates/analysis/src/float_verification.rs with:

    a) `nan_propagation_vc(result: Term, operands: &[Term], operation: &str, location: VcLocation) -> VerificationCondition`:
       - Build assertion: if all operands are not NaN, then result is not NaN
       - operands_not_nan = operands.iter().map(|op| Not(FpIsNaN(op)))
       - result_not_nan = Not(FpIsNaN(result))
       - vc_term = if operands empty: result_not_nan, else: Implies(And(operands_not_nan), result_not_nan)
       - Script: declare float variables, assert Not(vc_term), check-sat (expect UNSAT if NaN-free)
       - vc_kind: VcKind::FloatingPointNaN
       - description: "NaN propagation: {operation} should not produce NaN when operands are finite"

    b) `infinity_overflow_vc(result: Term, operands: &[Term], operation: &str, location: VcLocation) -> VerificationCondition`:
       - Build assertion: if operands are finite (not infinite), result should be finite
       - operands_finite = operands.iter().map(|op| Not(FpIsInfinite(op)))
       - result_finite = Not(FpIsInfinite(result))
       - vc_term = Implies(And(operands_finite), result_finite)
       - Script: declare float variables, assert Not(vc_term), check-sat
       - vc_kind: VcKind::FloatingPointNaN (reuse same kind)
       - description: "Infinity check: {operation} must not overflow to infinity when operands are finite"

    c) `generate_float_vcs(func: &Function) -> Vec<VerificationCondition>`:
       - Iterate all basic blocks and statements in func
       - For each Assign with Rvalue::BinaryOp where result type is Ty::Float(_):
         * Encode lhs, rhs operands and result
         * Generate nan_propagation_vc for arithmetic ops (Add, Sub, Mul, Div)
         * Generate infinity_overflow_vc for Add, Sub, Mul, Div (all may overflow)
       - For each Assign with Rvalue::UnaryOp(Neg) where type is Ty::Float(_):
         * Neg preserves NaN/Inf so skip VC generation (Neg(NaN)=NaN, Neg(Inf)=-Inf are fine)
       - Return collected VCs

    d) Helper: `is_float_arithmetic(op: &BinOp) -> bool`:
       - true for Add, Sub, Mul, Div
       - false for comparisons (Eq, Ne, Lt, Le, Gt, Ge) and bitwise ops

    2. In crates/analysis/src/lib.rs, add `pub mod float_verification;`

    3. In crates/analysis/src/vcgen.rs, integrate float VCs:
       - Add `use crate::float_verification;`
       - In generate_vcs() (or the main VC collection function), after existing VC generation:
         * Call float_verification::generate_float_vcs(&func)
         * Append returned VCs to the result vector
       - Follow the same pattern used for unsafe_analysis integration (grep for unsafe_analysis:: in vcgen.rs)

    Tests to write FIRST (RED phase) in float_verification.rs:
    - test_nan_propagation_vc_binary: nan_propagation_vc with 2 operands produces correct VC structure
    - test_nan_propagation_vc_description: description contains operation name
    - test_nan_propagation_vc_kind: vc_kind is FloatingPointNaN
    - test_infinity_overflow_vc_binary: infinity_overflow_vc produces correct VC structure
    - test_infinity_overflow_vc_description: description mentions overflow/infinity
    - test_is_float_arithmetic: Add/Sub/Mul/Div return true; Eq/Lt/Shl return false
    - test_generate_float_vcs_arithmetic: function with float add generates NaN + Inf VCs
    - test_generate_float_vcs_comparison: function with float comparison generates NO VCs (comparisons don't produce NaN)
    - test_generate_float_vcs_no_floats: function with no float ops generates empty vec
    - test_generate_float_vcs_multiple_ops: function with 2 float ops generates 4 VCs (2 NaN + 2 Inf)

    Tests in vcgen.rs:
    - test_vcgen_float_integration: generate_vcs on function with float add includes FloatingPointNaN VCs
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    float_verification.rs module exists with nan_propagation_vc, infinity_overflow_vc, generate_float_vcs.
    VCGen pipeline calls generate_float_vcs and appends float VCs. Float arithmetic generates both
    NaN and Infinity VCs (2 per operation). Float comparisons do not generate VCs. ~11 new tests pass.
    All existing tests pass (0 regressions). 0 clippy warnings.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- FLOAT_UNSUPPORTED string no longer appears in encode_term.rs production code
- Float constants produce proper FP terms (verified by encoding tests)
- Float operations produce FP terms with RNE rounding mode
- Float comparisons use IEEE 754 semantics (FpEq, not Eq)
- NaN and Infinity VCs generated for arithmetic float operations
- VCGen pipeline includes float VCs in output
- ~29 new tests total across both tasks
</verification>

<success_criteria>
1. FLOAT_UNSUPPORTED completely replaced with IEEE 754 FP encoding
2. Float arithmetic uses FpAdd/FpSub/FpMul/FpDiv with RNE rounding mode
3. Float comparisons use FpEq/FpLt/FpLeq/FpGt/FpGeq (IEEE 754 semantics)
4. NaN propagation VCs generated for all float arithmetic operations
5. Infinity overflow VCs generated for float operations that may overflow
6. VCGen pipeline integrates float VC generation
7. ~29 new tests passing, 0 regressions, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-floating-point-verification/11-02-SUMMARY.md`
</output>

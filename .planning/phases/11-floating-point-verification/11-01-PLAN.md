---
phase: 11-floating-point-verification
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/smtlib/src/term.rs
  - crates/smtlib/src/formatter.rs
  - crates/analysis/src/vcgen.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Term enum has all FloatingPoint variants (literals, arithmetic, comparison, predicates, rounding mode)"
    - "FP terms format to valid SMT-LIB2 FloatingPoint syntax"
    - "VcKind::FloatingPointNaN exists for float-specific diagnostics"
    - "Driver diagnostics handle FloatingPointNaN with description, suggestion, and formatting"
  artifacts:
    - path: "crates/smtlib/src/term.rs"
      provides: "FP literal, arithmetic, comparison, predicate, and rounding mode Term variants"
      contains: "FpAdd"
    - path: "crates/smtlib/src/formatter.rs"
      provides: "Display formatting for all FP Term variants to SMT-LIB2"
      contains: "fp.add"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::FloatingPointNaN variant"
      contains: "FloatingPointNaN"
    - path: "crates/driver/src/diagnostics.rs"
      provides: "FloatingPointNaN diagnostic description, suggestion, and help formatting"
      contains: "FloatingPointNaN"
    - path: "crates/driver/src/callbacks.rs"
      provides: "VcKind::FloatingPointNaN serialization"
      contains: "floating_point_nan"
  key_links:
    - from: "crates/smtlib/src/formatter.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Display impl matches all FP Term variants"
      pattern: "Term::FpAdd"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::FloatingPointNaN match arm in diagnostic formatting"
      pattern: "VcKind::FloatingPointNaN"
---

<objective>
Add FloatingPoint Term variants to smtlib (literals, arithmetic, comparison, predicates,
rounding mode), SMT-LIB2 formatting for all FP terms, VcKind::FloatingPointNaN to
analysis and driver diagnostics.

Purpose: Establish the SMT-LIB FloatingPoint AST infrastructure and diagnostic pipeline
that Plans 02 and 03 will use for float encoding, VC generation, and end-to-end verification.

Output: Extended smtlib Term enum with ~25 FP variants, formatter producing valid SMT-LIB2
FP syntax, VcKind::FloatingPointNaN in analysis and driver with diagnostics.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-floating-point-verification/11-RESEARCH.md
@crates/smtlib/src/term.rs
@crates/smtlib/src/formatter.rs
@crates/smtlib/src/sort.rs
@crates/analysis/src/vcgen.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FloatingPoint Term variants and SMT-LIB2 formatting (TDD)</name>
  <files>
    crates/smtlib/src/term.rs
    crates/smtlib/src/formatter.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In crates/smtlib/src/term.rs, add the following variants to the Term enum (after Annotated):

    === Floating-point literals ===
    1. FpNaN(u32, u32) -- IEEE 754 NaN: (_ NaN eb sb)
    2. FpPosInf(u32, u32) -- Positive infinity: (_ +oo eb sb)
    3. FpNegInf(u32, u32) -- Negative infinity: (_ -oo eb sb)
    4. FpPosZero(u32, u32) -- Positive zero: (_ +zero eb sb)
    5. FpNegZero(u32, u32) -- Negative zero: (_ -zero eb sb)
    6. FpFromBits(u8, u64, u64, u32, u32) -- Bit representation: (fp sign exp sig) with eb, sb

    === Rounding mode ===
    7. RoundingMode(String) -- RNE, RNA, RTP, RTN, RTZ

    === Floating-point arithmetic ===
    8. FpAdd(Box<Term>, Box<Term>, Box<Term>) -- (fp.add rm x y)
    9. FpSub(Box<Term>, Box<Term>, Box<Term>) -- (fp.sub rm x y)
    10. FpMul(Box<Term>, Box<Term>, Box<Term>) -- (fp.mul rm x y)
    11. FpDiv(Box<Term>, Box<Term>, Box<Term>) -- (fp.div rm x y)
    12. FpSqrt(Box<Term>, Box<Term>) -- (fp.sqrt rm x)
    13. FpAbs(Box<Term>) -- (fp.abs x)
    14. FpNeg(Box<Term>) -- (fp.neg x)

    === Floating-point comparison ===
    15. FpEq(Box<Term>, Box<Term>) -- (fp.eq x y) IEEE 754 equality
    16. FpLt(Box<Term>, Box<Term>) -- (fp.lt x y)
    17. FpLeq(Box<Term>, Box<Term>) -- (fp.leq x y)
    18. FpGt(Box<Term>, Box<Term>) -- (fp.gt x y)
    19. FpGeq(Box<Term>, Box<Term>) -- (fp.geq x y)

    === Floating-point predicates ===
    20. FpIsNaN(Box<Term>) -- (fp.isNaN x)
    21. FpIsInfinite(Box<Term>) -- (fp.isInfinite x)
    22. FpIsZero(Box<Term>) -- (fp.isZero x)
    23. FpIsNegative(Box<Term>) -- (fp.isNegative x)
    24. FpIsPositive(Box<Term>) -- (fp.isPositive x)

    In crates/smtlib/src/formatter.rs, extend the Display impl for Term with all FP variants.
    Follow the existing fmt_binop pattern for binary operations.

    FpFromBits formatting: (fp #bSIGN #bEXP #bSIG) where:
    - sign is 1 bit: #b0 or #b1
    - exp is eb bits: formatted as binary with leading zeros to eb width
    - sig is (sb-1) bits: formatted as binary with leading zeros to (sb-1) width

    RoundingMode formatting: just the mode string (e.g., "RNE")

    FP arithmetic formatting: (fp.add rm x y), (fp.sub rm x y), etc.
    FP unary formatting: (fp.abs x), (fp.neg x), (fp.sqrt rm x)
    FP comparison formatting: (fp.eq x y), (fp.lt x y), etc.
    FP predicate formatting: (fp.isNaN x), (fp.isInfinite x), etc.
    FP literal formatting:
    - FpNaN: (_ NaN eb sb)
    - FpPosInf: (_ +oo eb sb)
    - FpNegInf: (_ -oo eb sb)
    - FpPosZero: (_ +zero eb sb)
    - FpNegZero: (_ -zero eb sb)

    Tests to write FIRST (RED phase) in formatter.rs tests module:
    - test_fp_nan_f32: FpNaN(8, 24) formats to "(_ NaN 8 24)"
    - test_fp_nan_f64: FpNaN(11, 53) formats to "(_ NaN 11 53)"
    - test_fp_pos_inf: FpPosInf(11, 53) formats to "(_ +oo 11 53)"
    - test_fp_neg_inf: FpNegInf(11, 53) formats to "(_ -oo 11 53)"
    - test_fp_pos_zero: FpPosZero(8, 24) formats to "(_ +zero 8 24)"
    - test_fp_neg_zero: FpNegZero(8, 24) formats to "(_ -zero 8 24)"
    - test_fp_from_bits: FpFromBits for 1.0f64 (sign=0, exp=0x3FF, sig=0) formats correctly
    - test_rounding_mode_rne: RoundingMode("RNE") formats to "RNE"
    - test_fp_add: FpAdd(RNE, x, y) formats to "(fp.add RNE x y)"
    - test_fp_sub: FpSub(RNE, x, y) formats to "(fp.sub RNE x y)"
    - test_fp_mul: FpMul(RNE, x, y) formats to "(fp.mul RNE x y)"
    - test_fp_div: FpDiv(RNE, x, y) formats to "(fp.div RNE x y)"
    - test_fp_sqrt: FpSqrt(RNE, x) formats to "(fp.sqrt RNE x)"
    - test_fp_abs: FpAbs(x) formats to "(fp.abs x)"
    - test_fp_neg: FpNeg(x) formats to "(fp.neg x)"
    - test_fp_eq: FpEq(x, y) formats to "(fp.eq x y)"
    - test_fp_lt: FpLt(x, y) formats to "(fp.lt x y)"
    - test_fp_leq: FpLeq(x, y) formats to "(fp.leq x y)"
    - test_fp_gt: FpGt(x, y) formats to "(fp.gt x y)"
    - test_fp_geq: FpGeq(x, y) formats to "(fp.geq x y)"
    - test_fp_is_nan: FpIsNaN(x) formats to "(fp.isNaN x)"
    - test_fp_is_infinite: FpIsInfinite(x) formats to "(fp.isInfinite x)"
    - test_fp_is_zero: FpIsZero(x) formats to "(fp.isZero x)"
    - test_fp_is_negative: FpIsNegative(x) formats to "(fp.isNegative x)"
    - test_fp_is_positive: FpIsPositive(x) formats to "(fp.isPositive x)"
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Term enum has 25 FP variants (6 literals, 1 rounding mode, 7 arithmetic, 5 comparison,
    5 predicates, 1 from-bits). All variants format to valid SMT-LIB2 syntax. ~25 new
    formatter tests pass. All existing tests pass (0 regressions). 0 clippy warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add VcKind::FloatingPointNaN and driver diagnostics (TDD)</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In crates/analysis/src/vcgen.rs:
    - Add VcKind::FloatingPointNaN variant after MemorySafety.
      Doc comment: "Floating-point NaN propagation or infinity overflow check"

    In crates/driver/src/callbacks.rs:
    - Add VcKind::FloatingPointNaN to vc_kind_to_string(): return "floating_point_nan"

    In crates/driver/src/diagnostics.rs:
    - Add VcKind::FloatingPointNaN to vc_kind_description(): return "floating-point verification failure"
    - Add VcKind::FloatingPointNaN to suggest_fix(): return suggestion about NaN/Inf checks,
      e.g., "Consider adding NaN guards (!x.is_nan()) or using #[allows_nan] to suppress.
      Float operations may produce NaN from 0.0/0.0, Inf - Inf, etc."
    - Add VcKind::FloatingPointNaN handling in report_text_only() (after MemorySafety block):
      print float verification help message explaining IEEE 754 semantics.
    - Add VcKind::FloatingPointNaN to report_with_ariadne() severity: Warning severity
      (same pattern as MemorySafety -- float verification is advisory, not blocking).
    - Add format_float_verification_help() function: explains IEEE 754 quirks (NaN propagation,
      signed zeros, infinity overflow) and opt-in performance trade-off.
    - Add VcKind::FloatingPointNaN to ALL test arrays that exercise all VcKind variants
      (search for "VcKind::MemorySafety" in test arrays and add FloatingPointNaN after each).

    Tests to write FIRST (RED phase):
    - test_vc_kind_floating_point_nan_eq: VcKind::FloatingPointNaN equality and distinctness
    - test_vc_kind_floating_point_nan_description: vc_kind_description returns correct string
    - test_vc_kind_floating_point_nan_to_string: vc_kind_to_string returns "floating_point_nan"
    - test_vc_kind_floating_point_nan_suggest_fix: suggestion mentions NaN guards
    - test_format_float_verification_help: Help text mentions IEEE 754, NaN, Inf
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    VcKind::FloatingPointNaN exists in vcgen.rs. Driver callbacks serialize it as
    "floating_point_nan". Diagnostics provide description, suggestion, help text, and
    Warning severity. All match arms exhaustive (no compiler warnings). ~5 new tests
    pass. All existing tests pass (0 regressions). 0 clippy warnings.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- FP terms format to valid SMT-LIB2 syntax (verified by formatter tests)
- VcKind::FloatingPointNaN handled in all driver match arms (no compiler warnings)
- ~30 new tests total across both tasks
</verification>

<success_criteria>
1. Term enum has 25 FP variants with correct field types
2. All FP variants format to valid SMT-LIB2 FloatingPoint syntax
3. VcKind::FloatingPointNaN exists and is handled in callbacks + diagnostics
4. Float verification diagnostics provide helpful IEEE 754 explanations
5. ~30 new tests passing, 0 regressions, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-floating-point-verification/11-01-SUMMARY.md`
</output>

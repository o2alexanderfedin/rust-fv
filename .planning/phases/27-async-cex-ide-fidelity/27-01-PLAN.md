---
phase: 27-async-cex-ide-fidelity
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/driver/src/parallel.rs
  - crates/driver/tests/async_cex_e2e.rs
  - vscode-extension/src/verifier.ts
  - vscode-extension/src/outputPanel.ts
autonomous: true
requirements:
  - ASY-02

must_haves:
  truths:
    - "build_counterexample_v2() populates poll_iteration by scanning cx_pairs for a ('poll_iter', value) pair and parsing it as usize, gated on AsyncStateInvariantSuspend | AsyncStateInvariantResume | AsyncPostcondition vc_kind"
    - "build_counterexample_v2() populates await_side as 'pre_await' for AsyncStateInvariantSuspend and 'post_await' for AsyncStateInvariantResume, None otherwise"
    - "JsonCounterexample TypeScript interface in verifier.ts declares poll_iteration?: number and await_side?: string"
    - "npx tsc --noEmit in vscode-extension/ produces zero errors after interface update"
    - "E2E driver integration test in async_cex_e2e.rs proves a falsifiable state_invariant failure produces counterexample_v2 with non-None poll_iteration and await_side"
    - "outputPanel.ts renders async context line (poll iteration N, pre_await/post_await) when poll_iteration is present"
  artifacts:
    - path: "crates/driver/src/parallel.rs"
      provides: "build_counterexample_v2() with poll_iteration and await_side extraction"
      contains: "poll_iteration"
    - path: "crates/driver/tests/async_cex_e2e.rs"
      provides: "E2E integration test for async counterexample field population"
      contains: "async_cex_e2e"
    - path: "vscode-extension/src/verifier.ts"
      provides: "JsonCounterexample interface with poll_iteration and await_side optional fields"
      contains: "poll_iteration?: number"
    - path: "vscode-extension/src/outputPanel.ts"
      provides: "Async context rendering in formatFailedFunction"
      contains: "poll_iteration"
  key_links:
    - from: "crates/driver/src/parallel.rs build_counterexample_v2()"
      to: "crates/driver/src/json_output.rs JsonCounterexample"
      via: "poll_iteration and await_side fields set (not None)"
      pattern: "poll_iteration.*Some"
    - from: "crates/driver/src/parallel.rs"
      to: "VcKind::AsyncStateInvariantSuspend"
      via: "matches! macro guards extraction and await_side inference"
      pattern: "AsyncStateInvariantSuspend"
    - from: "vscode-extension/src/verifier.ts JsonCounterexample"
      to: "vscode-extension/src/outputPanel.ts formatFailedFunction"
      via: "poll_iteration optional field accessed at runtime"
      pattern: "poll_iteration"
---

<objective>
Close the doubly-incomplete async counterexample gap in Phase 27: populate `poll_iteration` and `await_side` in `build_counterexample_v2()` in `parallel.rs`, and add the corresponding optional fields to the `JsonCounterexample` TypeScript interface in `verifier.ts`, completing the ASY-02 counterexample IDE rendering pipeline.

Purpose: ASY-02 state_invariant counterexamples currently show `poll_iteration: null` and `await_side: null` to VSCode extension users — they cannot tell which `.await` suspension point or which poll side triggered the invariant violation. This phase wires the data that is already present in the Z3 model and VcKind through to the IDE.

Output:
- `crates/driver/src/parallel.rs` — `build_counterexample_v2()` extracts `poll_iteration` from `cx_pairs` and infers `await_side` from `vc_kind`
- `crates/driver/tests/async_cex_e2e.rs` — E2E driver integration test
- `vscode-extension/src/verifier.ts` — `JsonCounterexample` interface extended with two optional fields
- `vscode-extension/src/outputPanel.ts` — async context rendering line in `formatFailedFunction`
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-async-cex-ide-fidelity/27-RESEARCH.md
@crates/driver/src/parallel.rs
@crates/driver/src/json_output.rs
@crates/analysis/src/vcgen.rs
@vscode-extension/src/verifier.ts
@vscode-extension/src/outputPanel.ts
@crates/driver/tests/wmm_race_e2e.rs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: TDD — Extract poll_iteration and await_side in build_counterexample_v2()</name>
  <files>crates/driver/src/parallel.rs</files>
  <action>
**RED phase — write failing tests first in the existing `#[cfg(test)] mod tests` block at the bottom of `parallel.rs` (after line 419):**

Add two unit tests that call `build_counterexample_v2` directly (private fn is accessible from the same-module test block):

```rust
#[test]
fn test_build_counterexample_v2_async_fields_suspension() {
    // Build a minimal VcLocation with AsyncStateInvariantSuspend
    // and cx_pairs containing ("poll_iter", "2")
    // Assert: result.poll_iteration == Some(2)
    // Assert: result.await_side.as_deref() == Some("pre_await")
}

#[test]
fn test_build_counterexample_v2_async_fields_resume() {
    // Build VcLocation with AsyncStateInvariantResume, poll_iter = "1"
    // Assert: result.poll_iteration == Some(1)
    // Assert: result.await_side.as_deref() == Some("post_await")
}
```

To construct the `VcLocation` and `Function` arguments, follow the pattern in the existing `test_verification_task_result_with_timing` test for `Function` construction (use `Function { name: "test_async".to_string(), ..Function::default() }` or build fields individually — inspect what `Function` requires). For `VcLocation`, use `VcLocation { vc_kind: VcKind::AsyncStateInvariantSuspend, source_file: None, source_line: None, source_column: None, contract_text: None }`.

Run `cargo test -p rust-fv-driver test_build_counterexample_v2_async_fields -- --nocapture` — tests MUST FAIL (RED) with `poll_iteration == None` before implementation.

**GREEN phase — implement extraction in `build_counterexample_v2()`:**

In `parallel.rs`, modify `build_counterexample_v2()` at the `poll_iteration: None` and `await_side: None` placeholder lines (currently lines 414-415):

Replace the two `None` placeholders with:

```rust
let poll_iteration = if matches!(
    vc_location.vc_kind,
    VcKind::AsyncStateInvariantSuspend
        | VcKind::AsyncStateInvariantResume
        | VcKind::AsyncPostcondition
) {
    pairs
        .iter()
        .find(|(name, _)| name == "poll_iter")
        .and_then(|(_, val)| val.trim().parse::<usize>().ok())
} else {
    None
};

let await_side = match vc_location.vc_kind {
    VcKind::AsyncStateInvariantSuspend => Some("pre_await".to_string()),
    VcKind::AsyncStateInvariantResume => Some("post_await".to_string()),
    _ => None,
};
```

Then update the `JsonCounterexample` struct literal at lines 402-416 to use `poll_iteration` and `await_side` (the computed local variables, not `None`).

**CRITICAL:** Do NOT use `"suspension"` / `"resumption"` strings — those are internal SMT encoding labels. The public JSON API uses `"pre_await"` and `"post_await"` as specified in Phase 27 success criteria.

**CRITICAL:** Do NOT add `await_side` for `VcKind::AsyncPostcondition` — that VC fires at `Poll::Ready`, not at an await point. Only `Suspend`/`Resume` get `await_side`.

Run `cargo test -p rust-fv-driver test_build_counterexample_v2_async_fields -- --nocapture` — tests MUST PASS (GREEN).

Run `cargo clippy -p rust-fv-driver -- -D warnings` — must be clean.
Run `cargo fmt -p rust-fv-driver -- --check` — must be clean.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-driver test_build_counterexample_v2_async_fields -- --nocapture 2>&1 | tail -20</automated>
    <manual>Confirm RED→GREEN cycle: first run (before implementation) shows test failures, second run (after implementation) shows 2 tests passing.</manual>
    <sampling_rate>run after each RED and GREEN commit</sampling_rate>
  </verify>
  <done>
    - `test_build_counterexample_v2_async_fields_suspension` passes: `poll_iteration == Some(2)`, `await_side == Some("pre_await")`
    - `test_build_counterexample_v2_async_fields_resume` passes: `poll_iteration == Some(1)`, `await_side == Some("post_await")`
    - `cargo clippy -p rust-fv-driver -- -D warnings` is clean
    - `cargo fmt -p rust-fv-driver -- --check` is clean
    - Commits: `test(27-01): add failing test for build_counterexample_v2 async fields` then `feat(27-01): extract poll_iteration and await_side in build_counterexample_v2`
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript interface update, outputPanel rendering, and E2E integration test</name>
  <files>
    vscode-extension/src/verifier.ts
    vscode-extension/src/outputPanel.ts
    crates/driver/tests/async_cex_e2e.rs
  </files>
  <action>
**Part A — Update `vscode-extension/src/verifier.ts` `JsonCounterexample` interface (lines 38-44):**

Add two optional fields to the interface:

```typescript
/** Structured counterexample with typed variables and metadata (v2 schema). */
export interface JsonCounterexample {
  variables: JsonCexVariable[];
  failing_location: JsonLocation;
  vc_kind: string;
  violated_spec?: string;
  /** For async VCs: which poll iteration (0-based state_id) triggered the violation. */
  poll_iteration?: number;
  /** For async VCs: "pre_await" (suspension) or "post_await" (resumption) side. */
  await_side?: string;
}
```

Both fields MUST use `?:` (optional with undefined). They are `skip_serializing_if = "Option::is_none"` on the Rust side — they will be absent for non-async VCs, causing TypeScript runtime errors if declared as required.

Run `cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npx tsc --noEmit` — must produce ZERO errors.

**Part B — Add async context rendering in `vscode-extension/src/outputPanel.ts` in `formatFailedFunction()`:**

After the existing `failure.counterexample_v2?.violated_spec` block (line 126), add:

```typescript
// Show async context if present (state_invariant failures)
if (failure.counterexample_v2?.poll_iteration !== undefined) {
  const side = failure.counterexample_v2.await_side ?? 'unknown';
  channel.appendLine(
    `    Async context: poll iteration ${failure.counterexample_v2.poll_iteration}, ${side}`
  );
}
```

Run `cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npx tsc --noEmit` again — must still produce ZERO errors.

**Part C — Create E2E integration test `crates/driver/tests/async_cex_e2e.rs`:**

Follow `crates/driver/tests/wmm_race_e2e.rs` construction pattern (VerificationTask with `name`, `ir_func`, `contract_db` fields and `verify_functions_parallel()`).

Build a minimal async `Function` with:
- `coroutine_info: Some(CoroutineInfo { states: vec![CoroutineState { state_id: 0, awaited_ty: None, persistent_fields: vec![("counter".to_string(), rust_fv_analysis::ir::Ty::Int(rust_fv_analysis::ir::IntTy::I64, 64))] }], ..CoroutineInfo::default() })`
- A `state_invariant` contract clause: `"counter >= 1"` (falsifiable — default SMT model will assign counter = 0 which violates >= 1)

Import patterns from `crates/analysis/tests/async_verification.rs` for constructing `CoroutineInfo` and `CoroutineState` — use those exact types.

The test must assert:
1. At least one result has `status == fail` (invariant falsified)
2. The failing result's `counterexample_v2` is `Some(_)` (not None)
3. `counterexample_v2.poll_iteration` is `Some(_)` (not None)
4. `counterexample_v2.await_side` is `Some("pre_await")` or `Some("post_await")`

Test name: `test_async_cex_e2e_async_fields_populated`.

Add `async_cex_e2e` to `crates/driver/tests/` (new file — no existing file to modify).

Run `cargo test -p rust-fv-driver async_cex_e2e -- --nocapture 2>&1 | tail -30` — must pass.
Run `cargo clippy -p rust-fv-driver -- -D warnings` — must be clean.
Run `cargo fmt -p rust-fv-driver -- --check` — must be clean.
Run the full suite: `cargo test -p rust-fv-driver 2>&1 | tail -10` — all tests must pass (no regressions).
  </action>
  <verify>
    <automated>cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npx tsc --noEmit && cd /Users/alexanderfedin/Projects/hapyy/rust-fv && cargo test -p rust-fv-driver async_cex_e2e -- --nocapture 2>&1 | tail -20</automated>
    <manual>Confirm: (1) tsc --noEmit exits 0 with no output, (2) E2E test passes with counterexample_v2 fields populated.</manual>
    <sampling_rate>run after outputPanel change, then after E2E test passes</sampling_rate>
  </verify>
  <done>
    - `vscode-extension/src/verifier.ts JsonCounterexample` interface has `poll_iteration?: number` and `await_side?: string`
    - `npx tsc --noEmit` in `vscode-extension/` exits 0 with no errors
    - `outputPanel.ts` renders "Async context: poll iteration N, pre_await/post_await" when `poll_iteration` is defined
    - `crates/driver/tests/async_cex_e2e.rs` exists and `test_async_cex_e2e_async_fields_populated` passes
    - Full `cargo test -p rust-fv-driver` suite passes with no regressions
    - Commit: `feat(27-01): update TypeScript interface + outputPanel rendering + async cex E2E test`
  </done>
</task>

</tasks>

<verification>
Full phase verification gate:

```bash
# Rust unit tests (poll_iteration and await_side extraction)
cargo test -p rust-fv-driver test_build_counterexample_v2_async_fields -- --nocapture

# E2E driver integration test
cargo test -p rust-fv-driver async_cex_e2e -- --nocapture

# Full Rust driver suite (no regressions)
cargo test -p rust-fv-driver 2>&1 | tail -10

# TypeScript compile check
cd /Users/alexanderfedin/Projects/hapyy/rust-fv/vscode-extension && npx tsc --noEmit

# Lint
cargo clippy -p rust-fv-driver -- -D warnings
```

All five commands must succeed before phase is considered complete.
</verification>

<success_criteria>
1. `cargo test -p rust-fv-driver test_build_counterexample_v2_async_fields` passes — `poll_iteration == Some(2)` (suspension) and `poll_iteration == Some(1)` (resume), `await_side == Some("pre_await")` and `Some("post_await")` respectively
2. `cargo test -p rust-fv-driver async_cex_e2e` passes — E2E proof that driver pipeline populates async counterexample fields end-to-end
3. `npx tsc --noEmit` in `vscode-extension/` produces zero errors — TypeScript interface matches Rust struct
4. `cargo test -p rust-fv-driver` full suite passes — no regressions in 26+ existing tests
5. `parallel.rs` lines that were `poll_iteration: None, await_side: None` now use computed values from `cx_pairs` and `vc_kind`
</success_criteria>

<output>
After completion, create `.planning/phases/27-async-cex-ide-fidelity/27-01-SUMMARY.md` documenting:
- What was implemented (poll_iteration extraction logic, await_side inference logic)
- Files modified and key line numbers
- Test results (unit tests + E2E + tsc)
- Any pitfalls encountered and how they were resolved
</output>

---
phase: 02-table-stakes-completion
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/smtlib/src/command.rs
  - crates/smtlib/src/formatter.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/aggregate_encoding.rs
autonomous: true

must_haves:
  truths:
    - "A struct with named fields is encoded as an SMT datatype with constructors and field selectors"
    - "Struct field access in specifications (result.x > 0) is correctly encoded as selector application"
    - "Tuples are encoded as SMT datatypes with positional selectors (_0, _1, ...)"
    - "Arrays are encoded using SMT array theory with select/store operations"
  artifacts:
    - path: "crates/analysis/src/encode_sort.rs"
      provides: "SMT datatype encoding for structs, tuples, enums, arrays"
      contains: "collect_datatype_declarations"
    - path: "crates/analysis/src/encode_term.rs"
      provides: "Aggregate construction and field access encoding"
      contains: "encode_aggregate"
    - path: "crates/smtlib/src/command.rs"
      provides: "DeclareDatatype command for SMT-LIB datatype declarations"
      contains: "DeclareDatatype"
    - path: "crates/analysis/tests/aggregate_encoding.rs"
      provides: "E2E tests for struct, tuple, enum, and array encoding"
      min_lines: 200
  key_links:
    - from: "crates/analysis/src/encode_sort.rs"
      to: "crates/smtlib/src/command.rs"
      via: "collect_datatype_declarations generates DeclareDatatype commands"
      pattern: "DeclareDatatype"
    - from: "crates/analysis/src/encode_term.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Term::App for constructor/selector function application"
      pattern: "Term::App"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_sort.rs"
      via: "Datatype declarations emitted before variable declarations in base_script"
      pattern: "collect_datatype_declarations"
---

<objective>
Encode Rust aggregate types (structs, tuples, enums, arrays) as SMT datatypes so that specifications can reason about fields, tuple elements, enum variants, and array elements.

Purpose: Real Rust code uses structs and tuples extensively. Without aggregate encoding, the verifier cannot check specifications like `#[ensures(result.x > 0)]` or reason about tuple returns. This unlocks Success Criterion 5.

Output: SMT datatype declarations for structs/tuples/enums, field selector encoding, array select/store operations, E2E tests with Z3.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-table-stakes-completion/02-RESEARCH.md
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/smtlib/src/sort.rs
@crates/smtlib/src/term.rs
@crates/smtlib/src/command.rs
@crates/smtlib/src/formatter.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SMT datatype declarations for structs, tuples, and enums</name>
  <files>
    crates/smtlib/src/command.rs
    crates/smtlib/src/formatter.rs
    crates/analysis/src/encode_sort.rs
  </files>
  <action>
1. Extend `crates/smtlib/src/command.rs`:
   - Add `DatatypeVariant` struct:
     ```rust
     #[derive(Debug, Clone, PartialEq)]
     pub struct DatatypeVariant {
         pub constructor: String,
         pub fields: Vec<(String, Sort)>,
     }
     ```
   - Add `DeclareDatatype` variant to `Command` enum:
     ```rust
     /// `(declare-datatype name ((constructor (field sort) ...)))`
     DeclareDatatype {
         name: String,
         variants: Vec<DatatypeVariant>,
     },
     ```

2. Update `crates/smtlib/src/formatter.rs`:
   - Add Display implementation for `DeclareDatatype`:
     - Single-variant struct:
       ```
       (declare-datatype Point ((mk-Point (Point-x (_ BitVec 32)) (Point-y (_ BitVec 32)))))
       ```
     - Multi-variant enum:
       ```
       (declare-datatype Option_i32 ((mk-None) (mk-Some (Some-0 (_ BitVec 32)))))
       ```
     - Variant with no fields:
       ```
       (mk-None)
       ```
     - Variant with fields:
       ```
       (mk-Some (Some-0 (_ BitVec 32)))
       ```
   - Selector names use format: `{TypeName}-{field_name}` for struct fields, `{VariantName}-{index}` for positional tuple/enum fields

3. Update `crates/analysis/src/encode_sort.rs`:
   - Change `Ty::Struct(name, _fields)` encoding from `Sort::Uninterpreted(name)` to `Sort::Datatype(name.clone())`
   - Change `Ty::Tuple(fields)` for non-empty tuples from `Sort::Uninterpreted("Tuple")` to `Sort::Datatype(format!("Tuple{}", fields.len()))`
   - Change `Ty::Enum(name, _variants)` from `Sort::Uninterpreted(name)` to `Sort::Datatype(name.clone())`
   - Add `collect_datatype_declarations(func: &Function) -> Vec<Command>` function:
     - Scan return type, all params, and all locals for Struct/Tuple/Enum types
     - Use a `HashSet<String>` to avoid duplicate declarations for the same type name
     - For `Ty::Struct(name, fields)`: Generate `DeclareDatatype { name, variants: [DatatypeVariant { constructor: "mk-{name}", fields }] }` where each field is `("{name}-{field_name}", encode_type(field_ty))`
     - For `Ty::Tuple(fields)` (non-empty): Generate `DeclareDatatype { name: "Tuple{N}", variants: [DatatypeVariant { constructor: "mk-Tuple{N}", fields: [("Tuple{N}-_0", sort0), ...] }] }`
     - For `Ty::Enum(name, variants)`: Generate `DeclareDatatype { name, variants: [DatatypeVariant { constructor: "mk-{variant_name}", fields: [...] }, ...] }`
   - Array types stay as `Sort::Array` (already correctly encoded)
   - Update existing unit tests: change assertions from `Sort::Uninterpreted("Vec")` to `Sort::Datatype("Vec")` etc.

IMPORTANT: Non-generic structs only. Generic struct support (monomorphization) deferred to Phase 3+ per research.

IMPORTANT: Selector names must be globally unique in the SMT script. Use `{TypeName}-{field_name}` to prevent collisions.
  </action>
  <verify>
    `cargo test -p rust-fv-smtlib` passes all tests (including new formatter tests for DeclareDatatype).
    `cargo test -p rust-fv-analysis` passes (encode_sort tests updated for Sort::Datatype).
    `cargo clippy -p rust-fv-smtlib -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
    DeclareDatatype command in smtlib crate. Formatter renders correct SMT-LIB 2.6 syntax. encode_sort produces Sort::Datatype for structs/tuples/enums. collect_datatype_declarations generates declarations from function types. Existing tests updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Aggregate construction, field access in VCGen, and E2E tests</name>
  <files>
    crates/analysis/src/encode_term.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/aggregate_encoding.rs
  </files>
  <action>
1. Update `crates/analysis/src/encode_term.rs`:
   - Add `encode_aggregate(kind: &AggregateKind, operands: &[Operand]) -> Option<Term>`:
     - `AggregateKind::Struct(name)`: `Term::App("mk-{name}".into(), encoded_operands)`
     - `AggregateKind::Tuple`: `Term::App("mk-Tuple{N}".into(), encoded_operands)` where N = operands.len()
     - `AggregateKind::Enum(name, variant_idx)`: `Term::App("mk-{variant_name}".into(), encoded_operands)` -- variant name needs lookup from type
   - Add `encode_field_access(base: Term, ty: &Ty, field_idx: usize) -> Option<Term>`:
     - `Ty::Struct(name, fields)`: `Term::App("{name}-{fields[field_idx].0}".into(), vec![base])`
     - `Ty::Tuple(fields)`: `Term::App("Tuple{len}-_{field_idx}".into(), vec![base])`
   - Add `encode_index_access(array: Term, index: Term) -> Term`:
     - Returns `Term::Select(Box::new(array), Box::new(index))`
   - Add `encode_index_store(array: Term, index: Term, value: Term) -> Term`:
     - Returns `Term::Store(Box::new(array), Box::new(index), Box::new(value))`

2. Update `crates/analysis/src/vcgen.rs`:
   - In `encode_assignment`, replace the `Rvalue::Aggregate(_, _) => return None` case with:
     ```rust
     Rvalue::Aggregate(kind, operands) => {
         encode_aggregate(kind, operands)?
     }
     ```
   - In `encode_assignment`, handle `Place` projections:
     - If `place.projections` is non-empty, encode field access for the LHS:
       For `Projection::Field(idx)`: instead of `(= _1 value)`, emit `(= ({Type}-{field} _1) value)` using `encode_field_access`
     - For `Projection::Index(idx_local)`: emit `Term::Select` for reads, `Term::Store` for writes
   - Update `encode_operand` in encode_term.rs to handle operands with projections:
     - For `Operand::Copy(place)` or `Operand::Move(place)` where `place.projections` is non-empty:
       Start with `Term::Const(place.local)`, then apply each projection:
       - `Projection::Field(idx)` -> wrap with `encode_field_access`
       - `Projection::Index(idx_local)` -> wrap with `encode_index_access`
       - `Projection::Deref` -> transparent (reference values are the same as the referent)
     - This requires the operand encoder to know the type of the local for field access. Add an optional `func: &Function` parameter to `encode_operand_with_projections`, or create a new function `encode_place(place: &Place, func: &Function) -> Option<Term>`
   - In `collect_declarations` (or `base_script`): call `collect_datatype_declarations(func)` and insert the DeclareDatatype commands AFTER SetLogic/SetOption but BEFORE DeclareConst (SMT-LIB requires sort declarations before use)

3. Create `crates/analysis/tests/aggregate_encoding.rs` with self-contained helpers:

   **Struct tests:**
   a. `test_struct_construction`: Create IR for `fn f() -> Point { Point { x: 1, y: 2 } }` using Rvalue::Aggregate. Postcondition `result.x == 1 && result.y == 2`. Expect UNSAT.
   b. `test_struct_field_postcondition_positive`: Function returning Point with postcondition `result.x > 0`. Construct Point with x = 5. Expect UNSAT.
   c. `test_struct_field_postcondition_negative`: Same but with x = -1, postcondition `result.x > 0`. Expect SAT (counterexample).

   **Tuple tests:**
   d. `test_tuple_construction`: Create `(i32, i32)`, verify elements via positional selectors.
   e. `test_tuple_field_access`: Access `_0` and `_1` of a tuple, verify postcondition.

   **Array tests:**
   f. `test_array_select`: Read from array `arr[i]` using Select. Verify value constraints.
   g. `test_array_store_select`: Write to array then read back: `arr[i] = 42; assert arr[i] == 42`. Expect UNSAT.

   **Enum test:**
   h. `test_enum_variant_construction`: Two-variant enum (None/Some). Construct Some(42), verify field access.

Use established E2E test pattern: build IR manually, generate VCs, render to SMT-LIB, check with Z3.

IMPORTANT: Focus on non-generic structs with scalar fields. Generic types deferred. Ensure DeclareDatatype produces valid SMT-LIB accepted by Z3.
  </action>
  <verify>
    `cargo test -p rust-fv-analysis --test aggregate_encoding` passes all 8 tests.
    `cargo test -p rust-fv-analysis` passes all tests (existing + new aggregate tests).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
    Struct construction encoded as constructor application. Field access encoded as selector application. Tuples and arrays work. Postconditions with field access (`result.x > 0`) verified by Z3. 8+ E2E tests pass.
  </done>
</task>

</tasks>

<verification>
1. Phase 2 Success Criterion 5: "A struct with named fields can be used in specifications (`#[ensures(result.x > 0)]`), and struct field access is correctly encoded in SMT" -- verified by test_struct_field_postcondition_positive and test_struct_field_postcondition_negative
2. TYP-01 (structs), TYP-02 (tuples), TYP-03 (enums), TYP-04 (arrays) all covered
3. `cargo test --workspace` -- all tests pass
</verification>

<success_criteria>
- Structs produce DeclareDatatype with constructors and selectors
- Field access in VCs uses selector functions (Term::App with selector name)
- Aggregate construction uses constructor functions (Term::App with constructor name)
- Array indexing uses SMT select/store
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-stakes-completion/02-04-SUMMARY.md`
</output>

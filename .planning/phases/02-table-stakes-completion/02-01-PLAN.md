---
phase: 02-table-stakes-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/solver/Cargo.toml
  - crates/solver/src/lib.rs
  - crates/solver/src/z3_native.rs
  - crates/solver/src/backend.rs
  - crates/solver/tests/z3_native_test.rs
  - crates/analysis/Cargo.toml
  - crates/analysis/src/lib.rs
  - crates/driver/Cargo.toml
  - crates/driver/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Z3 native API backend produces identical SAT/UNSAT results to subprocess backend on all Phase 1 tests"
    - "tracing crate provides structured logging with per-module filtering via RUST_LOG"
    - "Subprocess backend remains available as fallback via feature flag"
  artifacts:
    - path: "crates/solver/src/z3_native.rs"
      provides: "Z3NativeSolver implementing SolverBackend trait via z3 crate"
      min_lines: 80
    - path: "crates/solver/src/backend.rs"
      provides: "SolverBackend trait abstracting over subprocess and native backends"
      min_lines: 20
    - path: "crates/solver/tests/z3_native_test.rs"
      provides: "Integration tests proving equivalence of native and subprocess backends"
      min_lines: 60
  key_links:
    - from: "crates/solver/src/z3_native.rs"
      to: "z3 crate API"
      via: "z3::Context, z3::Solver, z3::ast::BV"
      pattern: "z3::(Context|Solver|ast)"
    - from: "crates/solver/src/backend.rs"
      to: "crates/solver/src/solver.rs"
      via: "SolverBackend trait implemented by both Z3Solver and Z3NativeSolver"
      pattern: "impl SolverBackend"
    - from: "crates/driver/src/main.rs"
      to: "tracing_subscriber"
      via: "tracing init at startup"
      pattern: "tracing_subscriber::fmt"
---

<objective>
Add z3 crate with bundled feature as native solver backend and integrate structured tracing throughout the verification pipeline.

Purpose: The native Z3 API eliminates subprocess spawning overhead (~50ms/query), enables incremental solving (push/pop), and provides type-safe interactions. Tracing replaces ad-hoc eprintln! with module-level structured logging for debugging the verification pipeline.

Output: SolverBackend trait, Z3NativeSolver implementation, tracing initialization, feature flags for backend selection.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-table-stakes-completion/02-RESEARCH.md
@crates/solver/src/lib.rs
@crates/solver/src/solver.rs
@crates/solver/src/config.rs
@crates/solver/src/result.rs
@crates/solver/src/error.rs
@crates/solver/Cargo.toml
@crates/driver/src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SolverBackend trait and Z3 native implementation</name>
  <files>
    Cargo.toml
    crates/solver/Cargo.toml
    crates/solver/src/backend.rs
    crates/solver/src/z3_native.rs
    crates/solver/src/lib.rs
    crates/solver/tests/z3_native_test.rs
  </files>
  <action>
1. Add workspace dependencies to root `Cargo.toml`:
   ```toml
   [workspace.dependencies]
   z3 = { version = "0.19", features = ["bundled"] }
   tracing = "0.1"
   tracing-subscriber = { version = "0.3", features = ["env-filter"] }
   ```

2. Update `crates/solver/Cargo.toml`:
   - Add `z3 = { workspace = true, optional = true }` to dependencies
   - Add `tracing = { workspace = true }` to dependencies
   - Add feature flags:
     ```toml
     [features]
     default = ["z3-native"]
     z3-native = ["z3"]
     ```

3. Create `crates/solver/src/backend.rs`:
   - Define `SolverBackend` trait with method: `fn check_sat(&self, script: &Script) -> Result<SolverResult, SolverError>`
   - Implement `SolverBackend` for existing `Z3Solver` (subprocess) by delegating to its existing `check_sat` method
   - Add `create_default_backend() -> Result<Box<dyn SolverBackend>, SolverError>` factory that picks z3-native when feature enabled, falls back to subprocess

4. Create `crates/solver/src/z3_native.rs`:
   - Implement `Z3NativeSolver` struct holding `z3::Config` and creating `z3::Context` per query (thread safety)
   - Parse SMT-LIB Script into z3 native API calls:
     - DeclareConst -> `z3::ast::BV::new_const` / `z3::ast::Bool::new_const`
     - Assert -> `solver.assert()`
     - Handle Term tree recursively: BvAdd -> `bvadd()`, BvSLt -> `bvslt()`, etc.
     - Handle CheckSat -> `solver.check()` returning SatResult
     - Handle GetModel -> extract model values
   - Return `SolverResult::Sat(model)`, `SolverResult::Unsat`, or `SolverResult::Unknown`
   - Use `#[cfg(feature = "z3-native")]` for the entire module
   - Add `tracing::debug!` for solver timing and result logging

5. Update `crates/solver/src/lib.rs`:
   - Add `pub mod backend;`
   - Add `#[cfg(feature = "z3-native")] pub mod z3_native;`
   - Re-export `SolverBackend` and `create_default_backend`

6. Create `crates/solver/tests/z3_native_test.rs`:
   - Test basic SAT query (declare x: BV32, assert x > 0 AND x < 10, expect SAT with model)
   - Test basic UNSAT query (assert x > 0 AND x < 0, expect UNSAT)
   - Test bitvector overflow query matching Phase 1 patterns
   - Test equivalence: same script produces same result on both backends
   - Use `#[cfg(feature = "z3-native")]` guard on tests

IMPORTANT: The z3 crate `bundled` feature compiles Z3 from source, which requires cmake. If cmake is not available, compilation will fail. Document this in a comment at the top of z3_native.rs.

Do NOT remove or break the existing subprocess backend. Both must coexist.
  </action>
  <verify>
    `cargo test -p rust-fv-solver --features z3-native` passes all existing tests plus new z3_native tests.
    `cargo test -p rust-fv-solver --no-default-features` passes all existing subprocess tests (proving backward compatibility).
    `cargo clippy -p rust-fv-solver --features z3-native -- -D warnings` produces zero warnings.
  </verify>
  <done>
    Z3NativeSolver produces SAT/UNSAT matching subprocess backend. SolverBackend trait abstracts both backends. Feature flag selects backend. All existing solver tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate tracing throughout verification pipeline</name>
  <files>
    crates/analysis/Cargo.toml
    crates/analysis/src/lib.rs
    crates/driver/Cargo.toml
    crates/driver/src/main.rs
  </files>
  <action>
1. Update `crates/analysis/Cargo.toml`:
   - Add `tracing = { workspace = true }` to dependencies

2. Update `crates/driver/Cargo.toml`:
   - Add `tracing = { workspace = true }` to dependencies
   - Add `tracing-subscriber = { workspace = true }` to dependencies

3. Update `crates/driver/src/main.rs`:
   - Add tracing subscriber initialization before any verification work:
     ```rust
     tracing_subscriber::fmt()
         .with_env_filter(
             tracing_subscriber::EnvFilter::from_default_env()
                 .add_directive("rust_fv=info".parse().unwrap())
         )
         .with_target(true)
         .init();
     ```
   - Replace any existing `eprintln!` debug output with `tracing::info!` or `tracing::debug!`

4. Add `tracing::instrument` and `tracing::debug!` to key analysis functions (do NOT instrument every function -- just the pipeline entry points):
   - `vcgen::generate_vcs`: `tracing::info!` at start with function name, `tracing::info!` at end with VC count
   - `encode_sort::encode_type`: `tracing::trace!` (very verbose, only at trace level)
   - Solver backend: `tracing::debug!` for query timing

5. Verify that `RUST_LOG=debug cargo test -p rust-fv-analysis` shows structured log output and `RUST_LOG=error cargo test -p rust-fv-analysis` suppresses it.

Do NOT add tracing to every single function. Focus on pipeline entry points: MIR conversion, VC generation, solver invocation. The goal is debugging aid, not comprehensive telemetry.
  </action>
  <verify>
    `cargo build -p rust-fv-driver` compiles successfully.
    `cargo test -p rust-fv-analysis` passes all 116+ existing tests.
    `cargo clippy --workspace --features z3-native -- -D warnings` produces zero warnings.
  </verify>
  <done>
    tracing crate integrated. RUST_LOG controls verbosity. Pipeline entry points log structured diagnostics. All existing tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all 300+ existing tests pass
2. `cargo test -p rust-fv-solver --features z3-native` -- native backend tests pass
3. `cargo clippy --workspace -- -D warnings` -- zero warnings
4. Feature flag works: `--no-default-features` uses subprocess, `--features z3-native` uses native
</verification>

<success_criteria>
- Z3 native backend produces correct SAT/UNSAT results
- Subprocess backend still works as fallback
- Tracing provides useful debugging output via RUST_LOG
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-stakes-completion/02-01-SUMMARY.md`
</output>

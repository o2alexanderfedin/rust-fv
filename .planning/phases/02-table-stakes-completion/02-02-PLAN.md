---
phase: 02-table-stakes-completion
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/tests/loop_verification.rs
  - crates/macros/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A while loop with user-supplied #[invariant(expr)] verifies successfully when invariant is correct"
    - "The verifier reports which of the three VCs (initialization, preservation, use-after-loop) fails when the invariant is wrong"
    - "Back-edge detection identifies loop headers from MIR basic block structure"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Loop invariant VC generation with 3 separate labeled VCs per loop"
      contains: "generate_loop_invariant_vcs"
    - path: "crates/analysis/src/ir.rs"
      provides: "LoopInfo struct and invariant storage in Function"
      contains: "LoopInfo"
    - path: "crates/analysis/tests/loop_verification.rs"
      provides: "E2E tests for loop invariant verification with Z3"
      min_lines: 150
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "LoopInfo containing header block, back-edge blocks, and invariant expressions"
      pattern: "LoopInfo"
    - from: "crates/analysis/src/vcgen.rs"
      to: "parse_simple_spec"
      via: "Invariant expressions parsed into SMT terms via the spec parser"
      pattern: "parse_simple_spec.*invariant"
---

<objective>
Implement loop invariant verification using the classical 3-VC approach: initialization (precondition implies invariant), preservation (invariant + loop condition + body implies invariant), and exit (invariant + negated condition implies postcondition).

Purpose: Loops are fundamental to real programs. Without loop handling, the verifier can only reason about straight-line and branching code. This is the single most important Phase 2 feature for practical verification.

Output: Loop detection in IR, 3-VC generation in VCGen, labeled error messages identifying which VC failed, E2E tests proving correctness.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-table-stakes-completion/02-RESEARCH.md
@.planning/phases/01-soundness-foundation/01-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/encode_sort.rs
@crates/macros/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add loop representation to IR and detect loops in VCGen</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
    crates/macros/src/lib.rs
  </files>
  <action>
1. Extend IR in `crates/analysis/src/ir.rs`:
   - Add `LoopInfo` struct:
     ```rust
     #[derive(Debug, Clone)]
     pub struct LoopInfo {
         /// Basic block index of the loop header (target of back-edge)
         pub header_block: BlockId,
         /// Basic block indices that have back-edges to the header
         pub back_edge_blocks: Vec<BlockId>,
         /// User-supplied loop invariant expressions
         pub invariants: Vec<SpecExpr>,
     }
     ```
   - Add `loops: Vec<LoopInfo>` field to `Function` struct (with Default::default())
   - Add `invariants: Vec<SpecExpr>` field to `Contracts` struct for function-level invariant annotations
   - Update `Contracts::default()` to include empty `invariants` vec

2. Update `crates/macros/src/lib.rs`:
   - The `#[invariant]` macro already exists. Verify it embeds the invariant expression as a doc attribute (e.g., `#[doc = "rust_fv::invariant::{expr}"]`). If it uses a different format, document the exact format for the driver to extract.

3. Modify loop handling in `crates/analysis/src/vcgen.rs`:
   - In `traverse_block`: when a back-edge is detected (block already visited), instead of just completing the path, check if this block is a loop header with invariants. If so, DON'T complete the path -- instead, the loop is handled by the dedicated loop VC generator.
   - Add `detect_loops(func: &Function) -> Vec<LoopInfo>` function:
     - Use the existing CFG structure to find back-edges (edge from block B to block A where A dominates B, or simpler: edge to an already-visited block during DFS)
     - Match loop headers with invariant annotations from `func.contracts.invariants` or `func.loops`
   - Add `generate_loop_invariant_vcs(func: &Function, declarations: &[Command], loop_info: &LoopInfo) -> Vec<VerificationCondition>` function generating 3 VCs:

     **VC1 - Initialization**: Precondition AND assignments before loop header IMPLY invariant
     - Assume preconditions
     - Encode assignments from function entry to loop header (the "pre-loop" path)
     - Assert negation of invariant (check if invariant can fail to hold on entry)
     - Label: "loop invariant initialization at block {header_block}"

     **VC2 - Preservation**: Invariant AND loop condition AND loop body IMPLY invariant
     - Assume invariant holds
     - Assume loop condition is true (from SwitchInt discriminant at header)
     - Encode assignments in loop body (blocks from header to back-edge)
     - Assert negation of invariant after body (check if invariant can fail after one iteration)
     - Label: "loop invariant preservation at block {header_block}"

     **VC3 - Exit/Use-after-loop**: Invariant AND NOT loop condition IMPLY postcondition
     - Assume invariant holds
     - Assume loop condition is false (negated)
     - Encode assignments after loop exit to function return
     - Assert negation of postcondition (standard postcondition check)
     - Label: "loop invariant sufficiency (exit) at block {header_block}"

   - Update `generate_vcs` to call `detect_loops` and `generate_loop_invariant_vcs` for each detected loop
   - For loops WITH invariants: generate 3 VCs per loop, skip path enumeration through the loop body
   - For loops WITHOUT invariants: log a tracing::warn! and skip the loop (unverified), do NOT enumerate paths through back-edges (current behavior)

IMPORTANT: The existing `traverse_block` cycle detection (line ~232 in vcgen.rs) currently completes the path at back-edges. This behavior must be preserved for loops without invariants. Only loops WITH user-supplied invariants get the 3-VC treatment.

IMPORTANT: The loop body encoding for VC2 (preservation) needs to handle the fact that the loop body is a sub-CFG. Use a similar path-enumeration approach within the loop body: enumerate paths from the header's body entry to the back-edge blocks, collecting assignments.

Do NOT attempt automatic invariant inference in this plan. Manual invariants only.
  </action>
  <verify>
    `cargo test -p rust-fv-analysis` passes all existing 116+ tests (no regressions).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
    New unit tests in vcgen.rs for `detect_loops` and loop VC generation pass.
  </verify>
  <done>
    LoopInfo added to IR. detect_loops finds loop headers from back-edges. generate_loop_invariant_vcs produces 3 labeled VCs. All existing tests pass without regression.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E loop verification tests with Z3</name>
  <files>
    crates/analysis/tests/loop_verification.rs
  </files>
  <action>
1. Create `crates/analysis/tests/loop_verification.rs` with self-contained test helpers (following the pattern from soundness_suite.rs and completeness_suite.rs -- duplicate helpers, don't share):

2. Implement these test cases (at minimum 8 tests):

   **Correct loop tests (expect all VCs UNSAT):**
   a. `test_simple_counter_loop`: `while i < n { i += 1; }` with invariant `i <= n`, postcondition `i == n`. Precondition `n >= 0`.
   b. `test_sum_loop`: `while i < n { sum += i; i += 1; }` with invariants `i <= n` and `sum >= 0`, precondition `n >= 0`.
   c. `test_countdown_loop`: `while i > 0 { i -= 1; }` with invariant `i >= 0`, postcondition `i == 0`.

   **Wrong invariant tests (expect specific VC SAT):**
   d. `test_wrong_init_invariant`: Invariant that is NOT true on loop entry (e.g., `i == n` when i starts at 0 and n > 0). Expect initialization VC to be SAT.
   e. `test_wrong_preservation_invariant`: Invariant that holds initially but breaks after one iteration (e.g., `i == 0` for an incrementing loop). Expect preservation VC to be SAT.
   f. `test_wrong_exit_postcondition`: Correct invariant but postcondition that doesn't follow from invariant + negated condition. Expect exit VC to be SAT.

   **Edge case tests:**
   g. `test_loop_without_invariant_skipped`: A loop with no invariant annotation produces no loop VCs (only overflow/other VCs).
   h. `test_zero_iteration_loop`: Loop where condition is false immediately (n == 0). Init VC should still be checked. Expect UNSAT if invariant is trivially true.

3. Each test must construct the IR manually (Function, BasicBlocks with back-edge structure, LoopInfo), generate VCs, render to SMT-LIB, submit to Z3, and assert the expected result.

4. For tests d, e, f: verify that the VC description contains the specific label ("initialization", "preservation", "exit"/"sufficiency") so users can identify which VC failed.

Follow the established test patterns:
- Use `assert_all_unsat()` for correct programs
- Check individual VC descriptions for labeled failure identification
- Use `Z3Solver::with_default_config()?.check_sat()` for Z3 invocation
  </action>
  <verify>
    `cargo test -p rust-fv-analysis --test loop_verification` passes all 8+ tests.
    `cargo test -p rust-fv-analysis` passes all tests (existing + new loop tests).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
    8+ E2E tests verify loop invariant handling. Correct invariants produce UNSAT on all 3 VCs. Wrong invariants produce SAT on the specific failing VC with labeled description. Loops without invariants are skipped gracefully.
  </done>
</task>

</tasks>

<verification>
1. Phase 2 Success Criterion 1: "A while loop with a user-supplied #[invariant(expr)] annotation verifies successfully" -- verified by test_simple_counter_loop, test_sum_loop, test_countdown_loop
2. Phase 2 Success Criterion 1 (second part): "the verifier reports which of the three VCs fails when the invariant is wrong" -- verified by test_wrong_init_invariant, test_wrong_preservation_invariant, test_wrong_exit_postcondition
3. `cargo test --workspace` -- all tests pass
</verification>

<success_criteria>
- Loop invariant initialization VC checks that precondition + pre-loop state implies invariant
- Loop invariant preservation VC checks that invariant + condition + body implies invariant
- Loop invariant exit VC checks that invariant + negated condition implies postcondition
- Each VC has a clear label identifying which check failed
- All existing 300+ tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-stakes-completion/02-02-SUMMARY.md`
</output>

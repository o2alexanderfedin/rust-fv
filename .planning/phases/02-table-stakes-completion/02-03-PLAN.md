---
phase: 02-table-stakes-completion
plan: 03
type: execute
wave: 3
depends_on: ["02-02", "02-04"]
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/encode_term.rs
  - crates/analysis/tests/assertion_panic_tests.rs
autonomous: true

must_haves:
  truths:
    - "An assert!(x > 0) statement in Rust source is statically verified from MIR, and a failing assert produces a counterexample"
    - "Code calling unwrap() on a potentially-None value is flagged as a potential panic with the specific failure location"
    - "Array indexing with an out-of-bounds index is flagged as a potential panic"
    - "Division-by-zero and shift overflow produce specific labeled error messages"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "AssertKind enum for panic message attribution"
      contains: "AssertKind"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Enhanced assert terminator handling with specific panic messages"
      contains: "generate_panic_freedom_vcs"
    - path: "crates/analysis/tests/assertion_panic_tests.rs"
      provides: "E2E tests for assertion verification and panic detection"
      min_lines: 200
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "AssertKind used in Terminator::Assert for specific error messages"
      pattern: "AssertKind"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/encode_term.rs"
      via: "encode_operand used to encode assert conditions"
      pattern: "encode_operand"
---

<objective>
Enhance assertion verification and add panic-freedom checking for unwrap(), array indexing, division-by-zero, and shift overflow, with specific error messages identifying the panic source.

Purpose: Rust developers expect assert!() to be statically verified and potential panics to be flagged. This plan makes the verifier useful for catching real bugs: unchecked unwrap, out-of-bounds indexing, and division by zero. Addresses Success Criteria 3 and 4.

Output: AssertKind for labeled errors, enhanced VCGen for MIR Assert terminators, panic-freedom VCs for common panic sources, E2E tests proving correctness.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-table-stakes-completion/02-RESEARCH.md
@.planning/phases/01-soundness-foundation/01-02-SUMMARY.md
@.planning/phases/02-table-stakes-completion/02-02-SUMMARY.md
@.planning/phases/02-table-stakes-completion/02-04-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/encode_sort.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AssertKind to IR and enhance VCGen assert handling</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/encode_term.rs
  </files>
  <action>
1. Add `AssertKind` enum to `crates/analysis/src/ir.rs`:
   ```rust
   /// Classification of MIR Assert terminators for specific error messages.
   #[derive(Debug, Clone)]
   pub enum AssertKind {
       /// User-written `assert!(expr)` or `assert_eq!(a, b)`
       UserAssert,
       /// Array/slice bounds check: index < len
       BoundsCheck { len: Operand, index: Operand },
       /// Integer overflow in arithmetic (add, sub, mul, etc.)
       Overflow(BinOp),
       /// Division by zero
       DivisionByZero,
       /// Remainder by zero
       RemainderByZero,
       /// Negation overflow (e.g., -i32::MIN)
       NegationOverflow,
       /// unwrap() on None
       UnwrapNone,
       /// expect() on None/Err
       ExpectFailed(String),
       /// Misaligned pointer dereference
       MisalignedPointer,
       /// Generic/unclassified assertion
       Other(String),
   }
   ```

2. Update `Terminator::Assert` in ir.rs to include AssertKind:
   ```rust
   Assert {
       cond: Operand,
       expected: bool,
       target: BlockId,
       kind: AssertKind,  // NEW: specific panic classification
   },
   ```
   - Update ALL existing code that constructs `Terminator::Assert` (search for `Terminator::Assert {` in all files) to include `kind: AssertKind::UserAssert` as default. This includes vcgen.rs test helpers and all test files (e2e_verification.rs, soundness_suite.rs, completeness_suite.rs, loop_verification.rs, aggregate_encoding.rs).

3. Enhance `generate_assert_terminator_vcs` in `crates/analysis/src/vcgen.rs`:
   - Use `AssertKind` to produce specific error descriptions:
     - `UserAssert` -> "assertion might fail at block {block_idx}"
     - `BoundsCheck { len, index }` -> "array index out of bounds: index may be >= len at block {block_idx}"
     - `DivisionByZero` -> "division by zero at block {block_idx}"
     - `RemainderByZero` -> "remainder by zero at block {block_idx}"
     - `Overflow(op)` -> "arithmetic overflow in {op:?} at block {block_idx}"
     - `UnwrapNone` -> "unwrap() called on None at block {block_idx}"
     - `ExpectFailed(msg)` -> "expect() failed: {msg} at block {block_idx}"
     - `NegationOverflow` -> "negation overflow at block {block_idx}"

4. Add `generate_panic_freedom_vcs` function to vcgen.rs:
   - Scan ALL assert terminators in the function (not just those on enumerated paths -- scan the CFG directly)
   - For each Assert terminator, generate a VC proving the condition holds:
     - Build a script with declarations, precondition assumptions, and relevant path assignments
     - Negate the assertion condition (or check it matches expected value)
     - If SAT: potential panic detected, include counterexample
   - This function complements existing `generate_assert_terminator_vcs` but with improved path handling:
     - For BoundsCheck: VC checks `index < len` holds under preconditions
     - For DivisionByZero: VC checks `divisor != 0` (this may overlap with existing overflow VCs -- that is fine, the specific message adds value)
     - For UnwrapNone: VC checks discriminant == Some variant

5. Integrate in `generate_vcs`: Call `generate_panic_freedom_vcs` and include results. Keep existing `generate_assert_terminator_vcs` call but refactor to avoid duplicate VCs (either deduplicate by block index or merge the two functions).

IMPORTANT: The existing Phase 1 overflow checks (VER-04, VER-05) already generate overflow VCs. The new AssertKind-based VCs provide BETTER ERROR MESSAGES for the same checks. Do not remove the existing overflow VC generation -- instead, enhance the descriptions. If a VC for the same operation already exists, prefer the more descriptive one.

IMPORTANT: When updating `Terminator::Assert` to include `kind`, this is a breaking change to the IR. All test files that construct Assert terminators must be updated. Search for all occurrences across the workspace including files created by plans 02-02 and 02-04.
  </action>
  <verify>
    `cargo test -p rust-fv-analysis` passes all tests (after updating Assert constructors).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
    `cargo test --workspace` passes (no compilation errors from Assert change).
  </verify>
  <done>
    AssertKind enum added to IR. All existing Assert constructors updated. VCGen produces specific error messages for each panic kind. No regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests for assertion verification and panic detection</name>
  <files>
    crates/analysis/tests/assertion_panic_tests.rs
  </files>
  <action>
1. Create `crates/analysis/tests/assertion_panic_tests.rs` with self-contained test helpers (duplicate from e2e_verification.rs per established pattern).

2. Implement these test cases (minimum 10 tests):

   **User assertion tests (VER-02):**
   a. `test_assert_true_verified`: Function with `assert!(x > 0)` where precondition is `x > 0`. VC should be UNSAT (assertion always holds).
   b. `test_assert_false_counterexample`: Function with `assert!(x > 0)` and NO precondition constraining x. VC should be SAT with counterexample showing x <= 0.
   c. `test_assert_after_computation`: `let y = x + 1; assert!(y > x)` -- verify that the assertion uses the computed value.

   **Bounds check tests (VER-03):**
   d. `test_array_bounds_safe`: Array access `arr[i]` with precondition `i < arr.len()`. Assert terminator with `AssertKind::BoundsCheck`. VC should be UNSAT.
   e. `test_array_bounds_unsafe`: Array access without bounds precondition. VC should be SAT with counterexample showing out-of-bounds index.

   **Division-by-zero tests (VER-04):**
   f. `test_div_by_zero_safe`: `a / b` with precondition `b != 0`. Assert terminator with `AssertKind::DivisionByZero`. VC should be UNSAT.
   g. `test_div_by_zero_unsafe`: `a / b` without constraining b. VC should be SAT.

   **Unwrap tests (VER-03):**
   h. `test_unwrap_safe`: Function receiving Option-like discriminant with precondition guaranteeing Some. Assert with `AssertKind::UnwrapNone`. VC should be UNSAT.
   i. `test_unwrap_unsafe`: No precondition on Option discriminant. VC should be SAT with error message mentioning "unwrap".

   **Error message tests:**
   j. `test_error_message_specificity`: Verify that VCs for different AssertKinds produce different description strings. Check that BoundsCheck produces "array index out of bounds", DivisionByZero produces "division by zero", UnwrapNone produces "unwrap() called on None".

3. Each test constructs IR manually with the appropriate AssertKind in Terminator::Assert, generates VCs, renders to SMT-LIB, submits to Z3.

4. For counterexample tests (SAT results), verify that the model contains concrete values that demonstrate the violation.

Follow established test patterns:
- Use self-contained SMT-LIB formatting helpers
- Use `Z3Solver::with_default_config()?.check_sat()` for Z3 invocation
- Name tests descriptively per established convention
  </action>
  <verify>
    `cargo test -p rust-fv-analysis --test assertion_panic_tests` passes all 10+ tests.
    `cargo test -p rust-fv-analysis` passes all tests (existing + new).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
    10+ E2E tests verify assertion and panic detection. Safe code (with preconditions) produces UNSAT. Unsafe code produces SAT with counterexamples. Error messages are specific to the panic kind. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. Phase 2 Success Criterion 3: "An assert!(x > 0) statement in Rust source is statically verified from MIR, and a failing assert produces a counterexample" -- verified by test_assert_true_verified and test_assert_false_counterexample
2. Phase 2 Success Criterion 4: "Code calling unwrap() on a potentially-None value, or indexing an array with an out-of-bounds index, is flagged as a potential panic with the specific failure location" -- verified by test_unwrap_unsafe and test_array_bounds_unsafe
3. `cargo test --workspace` -- all tests pass
</verification>

<success_criteria>
- assert!() is statically verified when preconditions guarantee it
- Failing assertions produce counterexamples
- Bounds checks, division-by-zero, and unwrap produce specific error messages
- Error messages identify the specific kind of panic
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-stakes-completion/02-03-SUMMARY.md`
</output>

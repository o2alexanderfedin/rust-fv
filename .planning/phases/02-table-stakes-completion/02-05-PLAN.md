---
phase: 02-table-stakes-completion
plan: 05
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/Cargo.toml
  - crates/analysis/tests/spec_parser_tests.rs
  - crates/driver/Cargo.toml
  - crates/driver/src/main.rs
  - crates/driver/src/cargo_verify.rs
  - crates/driver/src/output.rs
autonomous: true

must_haves:
  truths:
    - "Specification parser handles full Rust expression syntax via syn crate (arithmetic, comparisons, logical operators, field access, method calls)"
    - "old(expr) operator in postconditions correctly refers to pre-state values"
    - "Running cargo verify produces colored per-function output (OK/FAIL/TIMEOUT)"
    - "cargo verify returns exit code 0 if all functions verify, 1 if any fail"
  artifacts:
    - path: "crates/analysis/src/spec_parser.rs"
      provides: "Full specification expression parser using syn::Expr"
      min_lines: 150
    - path: "crates/driver/src/cargo_verify.rs"
      provides: "cargo verify subcommand implementation"
      min_lines: 80
    - path: "crates/driver/src/output.rs"
      provides: "Colored per-function verification output formatter"
      min_lines: 40
    - path: "crates/analysis/tests/spec_parser_tests.rs"
      provides: "Unit tests for full spec parser covering edge cases"
      min_lines: 100
  key_links:
    - from: "crates/analysis/src/spec_parser.rs"
      to: "syn::Expr"
      via: "syn::parse_str::<Expr> for parsing specification strings into AST"
      pattern: "syn::parse_str"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/spec_parser.rs"
      via: "spec_parser replaces parse_simple_spec for contract/invariant parsing"
      pattern: "parse_spec_expr"
    - from: "crates/driver/src/cargo_verify.rs"
      to: "crates/driver/src/main.rs"
      via: "cargo verify entry point called from main when args contain 'verify'"
      pattern: "run_cargo_verify"
    - from: "crates/driver/src/output.rs"
      to: "colored crate"
      via: "Colored status output for OK/FAIL/TIMEOUT"
      pattern: "colored::"
---

<objective>
Replace the ad-hoc specification parser with a full syn-based parser supporting Rust expression syntax, add old(expr) operator for postconditions, and implement the cargo verify subcommand with colored per-function output.

Purpose: The current parse_simple_spec handles only basic comparisons and arithmetic. Real specifications need field access (result.x), method calls, nested expressions, and old() for pre-state references. The cargo verify command makes the tool usable as a standard development workflow. This is the integration layer that ties everything together.

Output: Full spec parser via syn, old() operator, cargo verify binary, colored output formatter.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-table-stakes-completion/02-RESEARCH.md
@.planning/phases/02-table-stakes-completion/02-01-SUMMARY.md
@.planning/phases/02-table-stakes-completion/02-02-SUMMARY.md
@.planning/phases/02-table-stakes-completion/02-03-SUMMARY.md
@.planning/phases/02-table-stakes-completion/02-04-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/Cargo.toml
@crates/driver/src/main.rs
@crates/driver/Cargo.toml
@crates/macros/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Full specification parser using syn and old() operator</name>
  <files>
    crates/analysis/Cargo.toml
    crates/analysis/src/spec_parser.rs
    crates/analysis/src/lib.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/tests/spec_parser_tests.rs
  </files>
  <action>
1. Update `crates/analysis/Cargo.toml`:
   - Add `syn = { version = "2.0", features = ["full", "parsing", "visit"] }` to dependencies

2. Create `crates/analysis/src/spec_parser.rs`:
   - Core function: `pub fn parse_spec_expr(spec: &str, func: &Function) -> Option<Term>`
   - Parse `spec` using `syn::parse_str::<syn::Expr>(spec)` to get a full AST
   - Walk the `syn::Expr` tree recursively, converting to SMT `Term`:

     **Literals:**
     - `Expr::Lit(ExprLit { lit: Lit::Int(n) })` -> `Term::BitVecLit(n.value(), width)` where width comes from function return type or explicit suffix
     - `Expr::Lit(ExprLit { lit: Lit::Bool(b) })` -> `Term::BoolLit(b.value())`

     **Identifiers:**
     - `Expr::Path` where path is `result` -> `Term::Const(func.return_local.name.clone())` (i.e., `_0`)
     - `Expr::Path` where path matches a param/local name -> `Term::Const(name)`

     **Binary operations:**
     - `Expr::Binary(ExprBinary { op: BinOp::Add, left, right })` -> `Term::BvAdd(left_term, right_term)`
     - `Sub` -> `Term::BvSub`, `Mul` -> `Term::BvMul`, `Div` -> `Term::BvSDiv` (signed) or `Term::BvUDiv` (unsigned)
     - `Gt` -> `Term::BvSGt`/`BvUGt`, `Lt` -> `BvSLt`/`BvULt`, `Ge` -> `BvSGe`/`BvUGe`, `Le` -> `BvSLe`/`BvULe`
     - `Eq` -> `Term::Eq`, `Ne` -> `Term::Not(Term::Eq(...))`
     - `And` (&&) -> `Term::And(vec![left, right])`
     - `Or` (||) -> `Term::Or(vec![left, right])`
     - Determine signedness from function context (return type or first param type is_signed)

     **Field access:**
     - `Expr::Field(ExprField { base, member })` -> Convert to selector application
       - `result.x` where result is `Ty::Struct("Point", fields)` -> `Term::App("Point-x".into(), vec![Term::Const("_0")])`
       - `result.0` (tuple index) -> `Term::App("TupleN-_0".into(), vec![Term::Const("_0")])`
       - Use the function's type information to resolve the struct name and field

     **Method calls (limited):**
     - `Expr::MethodCall` where method is `is_some()`, `is_none()`, `len()` -> translate to appropriate SMT terms (recognizer for enums, array length)
     - For unknown methods, return None (unsupported spec)

     **old() operator (SPEC-05):**
     - `Expr::Call` where func is `old` with one argument:
       - Recursively parse the inner expression
       - Replace all variable references in the inner expression with `{name}_pre` (pre-state snapshot)
       - Return the modified term
     - Example: `old(x)` -> `Term::Const("x_pre")`, `old(x + 1)` -> `Term::BvAdd(Term::Const("x_pre"), ...)`

     **Parenthesized:**
     - `Expr::Paren(ExprParen { expr })` -> recursively parse inner expression

     **Unary:**
     - `Expr::Unary(ExprUnary { op: UnOp::Not, expr })` -> `Term::Not(inner)` for bool, `Term::BvNot(inner)` for bitvec
     - `Expr::Unary(ExprUnary { op: UnOp::Neg, expr })` -> `Term::BvNeg(inner)`

3. Update `crates/analysis/src/lib.rs`:
   - Add `pub mod spec_parser;`

4. Update `crates/analysis/src/vcgen.rs`:
   - Replace calls to `parse_simple_spec` with `spec_parser::parse_spec_expr` in:
     - `generate_contract_vcs` (postcondition parsing)
     - `generate_overflow_vc` (precondition parsing)
     - `generate_assert_terminator_vcs` (precondition parsing)
     - `generate_loop_invariant_vcs` (invariant parsing) -- if it exists from 02-02
   - Keep `parse_simple_spec` as a fallback if `parse_spec_expr` returns None (gradual migration)
   - For old() support in postconditions: before encoding postcondition VCs, emit pre-state snapshot declarations:
     ```
     (declare-const _1_pre (_ BitVec 32))  ; snapshot of param _1
     (assert (= _1_pre _1))                ; capture pre-state value
     ```
     Then postconditions with `old(_1)` reference `_1_pre`

5. Create `crates/analysis/tests/spec_parser_tests.rs`:
   - Test parsing of simple comparisons: `result > 0`, `result >= _1`
   - Test arithmetic: `result == _1 + _2`, `result == _1 * 2 - _2`
   - Test logical operators: `result >= _1 && result >= _2`
   - Test field access: `result.x > 0`, `result.y == _1`
   - Test old() operator: `result == old(_1) + 1`
   - Test nested expressions: `(result.x > 0) && (result.y > 0)`
   - Test literal types: `result == 42`, `result == true`
   - Test error case: invalid Rust syntax returns None
   - Test backward compatibility: all specs that worked with parse_simple_spec still work with parse_spec_expr

IMPORTANT: The new parser must be a SUPERSET of what parse_simple_spec handles. All existing specs must continue to work. Run the full test suite to verify backward compatibility.
  </action>
  <verify>
    `cargo test -p rust-fv-analysis --test spec_parser_tests` passes all tests.
    `cargo test -p rust-fv-analysis` passes ALL existing tests (backward compatibility with parse_simple_spec).
    `cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
    Full spec parser handles Rust expressions via syn. old() operator snapshots pre-state. All existing specs still work. New parser is used for contract/invariant parsing. 10+ parser tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: cargo verify subcommand with colored output</name>
  <files>
    crates/driver/Cargo.toml
    crates/driver/src/main.rs
    crates/driver/src/cargo_verify.rs
    crates/driver/src/output.rs
  </files>
  <action>
1. Update `crates/driver/Cargo.toml`:
   - Add dependencies:
     ```toml
     cargo_metadata = "0.18"
     colored = "2.1"
     ```
   - Add a second binary target:
     ```toml
     [[bin]]
     name = "cargo-verify"
     path = "src/main.rs"
     ```
   Or alternatively, make the existing binary detect whether it was invoked as `cargo verify` or as a rustc driver.

2. Update `crates/driver/src/main.rs`:
   - At the top of main, check if invoked as cargo subcommand:
     ```rust
     let args: Vec<String> = std::env::args().collect();
     if args.len() > 1 && args[1] == "verify" {
         cargo_verify::run_cargo_verify(&args[2..]);
         return;
     }
     ```
   - Otherwise, proceed with existing rustc_driver logic

3. Create `crates/driver/src/cargo_verify.rs`:
   - `pub fn run_cargo_verify(args: &[String])`:
     a. Parse project metadata: `cargo_metadata::MetadataCommand::new().exec()?`
     b. Print header: `"Verifying {crate_name} v{version} ({path})"`
     c. Set `RUSTC` env var to point to the current binary
     d. Set `RUST_FV_VERIFY=1` to enable verification mode
     e. Run `cargo check --message-format=json` as subprocess
     f. Collect verification results from the driver's output (either via shared file in temp dir, or by parsing stderr)
     g. Pass results to output formatter
     h. Exit with code 0 if all OK, 1 if any FAIL

   - Result collection strategy: The driver currently prints to stderr. For cargo verify integration, write results to a JSON file in a temp directory. Set `RUST_FV_RESULTS_FILE=/tmp/rust-fv-{pid}.json` env var. Driver writes results there. cargo_verify reads them after cargo check completes.

   - Result format:
     ```rust
     #[derive(Serialize, Deserialize)]
     struct VerificationResults {
         functions: Vec<FunctionResult>,
     }
     struct FunctionResult {
         name: String,
         status: Status,  // Ok, Fail, Timeout
         message: Option<String>,  // Error detail for Fail
     }
     ```

4. Create `crates/driver/src/output.rs`:
   - `pub fn print_verification_results(results: &[FunctionResult])`:
     ```
     Verifying my_crate v0.1.0 (/path/to/crate)
       [OK]      max(a, b) -> i32
       [FAIL]    unsafe_div(a, b) -> i32 (division by zero at line 42)
       [TIMEOUT] complex_loop() (loop invariant verification timed out)

     Summary: 1 OK, 1 FAIL, 1 TIMEOUT
     ```
   - Use `colored` crate:
     - `"OK".green()` for verified functions
     - `"FAIL".red()` for failed functions
     - `"TIMEOUT".yellow()` for timed-out functions
   - Print summary line at the end

5. Handle edge cases:
   - No annotated functions found: print "No annotated functions found" and exit 0
   - Compilation error: print the error and exit 2 (distinguish from verification failure)
   - Timeout: use `RUST_FV_TIMEOUT` env var (default 30s per function)

IMPORTANT: Since this is a nightly-only binary (requires rustc_private), the cargo-verify binary IS the same binary as the rustc driver. It detects its invocation mode from args. Do NOT create a separate crate for cargo-verify.

IMPORTANT: For the initial implementation, it is acceptable to print verification results directly from the driver to stderr rather than using the JSON file approach. The JSON file approach is the cleaner design but adds complexity. Choose the simpler approach first and document the limitation.
  </action>
  <verify>
    `cargo build -p rust-fv-driver` compiles successfully and produces the binary.
    The binary responds to `--help` or `verify --help` without crashing.
    `cargo clippy -p rust-fv-driver -- -D warnings` produces zero warnings.
    Manual test: `cargo run -p rust-fv-driver -- verify` prints usage/header (may fail on actual verification without a project, but should not crash).
  </verify>
  <done>
    cargo verify subcommand entry point works. Colored output shows OK/FAIL/TIMEOUT per function. Summary line printed. Exit code reflects verification status. Binary can be installed as cargo-verify.
  </done>
</task>

</tasks>

<verification>
1. Phase 2 Success Criterion 2: "Running cargo verify in a Rust project produces colored per-function output (OK/FAIL/TIMEOUT) showing verification status for all annotated functions" -- verified by cargo verify implementation with colored output
2. SPEC-01: Full spec parser handles Rust expressions via syn -- verified by spec_parser_tests
3. SPEC-05: old(expr) operator for pre-state references -- verified by old() test cases
4. TOOL-01 + TOOL-02: cargo verify with colored output -- verified by cargo_verify.rs and output.rs
5. `cargo test --workspace` -- all tests pass
</verification>

<success_criteria>
- Spec parser handles: arithmetic, comparisons, logical operators, field access, old()
- All existing specifications still parse correctly (backward compatible)
- cargo verify produces colored output: green OK, red FAIL, yellow TIMEOUT
- Exit code 0 for all OK, 1 for any FAIL
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/02-table-stakes-completion/02-05-SUMMARY.md`
</output>

---
phase: 10-unsafe-code-detection
plan: 02
type: tdd
wave: 2
depends_on: ["10-01"]
files_modified:
  - crates/analysis/src/unsafe_analysis.rs
  - crates/analysis/src/heap_model.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Unsafe blocks are detected from Function IR and classified with source descriptions"
    - "Raw pointer dereferences are identified and generate null-check VCs (ptr != null)"
    - "Pointer arithmetic operations generate bounds-check VCs (offset < allocation_size)"
    - "Pointer provenance (FromRef) skips null-check generation (safe references are never null)"
    - "Heap-as-array model encodes pointer addresses, allocation bases, and allocation sizes"
    - "Unsafe function contracts (#[unsafe_requires]/#[unsafe_ensures]) are checked at call sites"
    - "Trusted functions (#[trusted]) have body verification skipped but contracts enforced at call sites"
    - "Unsafe code without annotations produces diagnostic warning VC (not hard error)"
  artifacts:
    - path: "crates/analysis/src/unsafe_analysis.rs"
      provides: "Unsafe block detection, raw pointer operation extraction, provenance tracking"
      exports: ["detect_unsafe_blocks", "extract_unsafe_operations", "classify_provenance", "check_missing_unsafe_contracts"]
    - path: "crates/analysis/src/heap_model.rs"
      provides: "Heap-as-array SMT encoding with allocation metadata"
      exports: ["declare_heap_model", "generate_null_check_vc", "generate_bounds_check_vc"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Unsafe VC generation integrated into generate_vcs pipeline"
      contains: "unsafe_analysis"
  key_links:
    - from: "crates/analysis/src/unsafe_analysis.rs"
      to: "crates/analysis/src/ir.rs"
      via: "UnsafeBlockInfo, UnsafeOperation, UnsafeContracts types"
      pattern: "use crate::ir::"
    - from: "crates/analysis/src/heap_model.rs"
      to: "crates/analysis/src/encode_sort.rs"
      via: "ptr_addr_sort() for pointer address bitvector encoding"
      pattern: "ptr_addr_sort"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/unsafe_analysis.rs"
      via: "detect_unsafe_blocks, extract_unsafe_operations called during VC generation"
      pattern: "unsafe_analysis::"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/heap_model.rs"
      via: "generate_null_check_vc, generate_bounds_check_vc for raw pointer operations"
      pattern: "heap_model::"
---

<objective>
Create unsafe_analysis.rs module for detecting unsafe blocks and extracting raw pointer operations,
heap_model.rs module for heap-as-array SMT encoding with null/bounds checks, and integrate both
into the VCGen pipeline. Add trusted function handling and unsafe contract verification at call sites.

Purpose: Implement the core verification logic that transforms unsafe IR metadata into provable
memory safety VCs. This is the central analysis engine that Plan 03 will validate end-to-end.

Output: New unsafe_analysis.rs and heap_model.rs modules, VCGen integration for unsafe blocks
and operations, trusted function skip logic, unsafe contract call-site checking.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unsafe-code-detection/10-RESEARCH.md
@.planning/phases/10-unsafe-code-detection/10-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/heap_model.rs
@crates/analysis/src/unsafe_analysis.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unsafe_analysis and heap_model modules (TDD)</name>
  <files>
    crates/analysis/src/unsafe_analysis.rs
    crates/analysis/src/heap_model.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    Create crates/analysis/src/unsafe_analysis.rs with:

    1. detect_unsafe_blocks(func: &Function) -> Vec<UnsafeBlockInfo>:
       - Iterate func.unsafe_blocks and return them (simple accessor).
       - If func.is_unsafe_fn is true and func.unsafe_blocks is empty, add a synthetic
         UnsafeBlockInfo for the entire function body:
         { block_index: 0, source_description: "unsafe function '{name}'", reason: "function declared unsafe" }
       - Purpose: Ensures all unsafe code paths are surfaced in verification output.

    2. extract_unsafe_operations(func: &Function) -> Vec<UnsafeOperation>:
       - Returns func.unsafe_operations (simple accessor).
       - Categorizes operations by type for downstream VC generation.

    3. classify_provenance(op: &UnsafeOperation) -> RawPtrProvenance:
       - For RawDeref: return op.provenance
       - For PtrCast: return op.provenance
       - For PtrArithmetic: return RawPtrProvenance::Unknown (arithmetic invalidates provenance)

    4. needs_null_check(op: &UnsafeOperation) -> bool:
       - Returns true for RawDeref where provenance is NOT FromRef.
       - FromRef pointers are derived from safe references (guaranteed non-null by Rust type system).
       - Returns false for PtrArithmetic and PtrCast (these don't dereference).

    5. needs_bounds_check(op: &UnsafeOperation) -> bool:
       - Returns true for PtrArithmetic (pointer offset must stay within allocation).
       - Returns false for RawDeref (dereference doesn't change address; null-check sufficient).
       - Returns false for PtrCast (cast doesn't change address).

    6. check_missing_unsafe_contracts(func: &Function) -> Option<String>:
       - If func.is_unsafe_fn is true AND func.unsafe_contracts is None (or has empty requires
         AND empty ensures AND is_trusted is false):
         Return Some("unsafe function '{name}' has no safety contracts -- consider adding
         #[unsafe_requires] / #[unsafe_ensures] or #[trusted]")
       - Otherwise return None.
       - This implements USF-06: warning for unannotated unsafe functions.

    7. is_trusted_function(func: &Function) -> bool:
       - Returns true if func.unsafe_contracts is Some and is_trusted is true.
       - Used by VCGen to skip body verification.

    8. get_unsafe_requires(func: &Function) -> Vec<&SpecExpr>:
       - Returns references to unsafe_requires from func.unsafe_contracts.
       - Returns empty vec if no unsafe_contracts.

    9. get_unsafe_ensures(func: &Function) -> Vec<&SpecExpr>:
       - Returns references to unsafe_ensures from func.unsafe_contracts.
       - Returns empty vec if no unsafe_contracts.

    Create crates/analysis/src/heap_model.rs with:

    1. declare_heap_model() -> Vec<Command>:
       - Declare "heap" as (Array (_ BitVec 64) (_ BitVec 8)) -- byte-addressable memory
       - Declare "allocated" as ((_ BitVec 64) -> Bool) -- allocation validity predicate
       - Declare "alloc_base" as ((_ BitVec 64) -> (_ BitVec 64)) -- allocation base address
       - Declare "alloc_size" as ((_ BitVec 64) -> (_ BitVec 64)) -- allocation size
       - Use Command::DeclareFun with Sort::BitVec(64) and Sort::BitVec(8) from smtlib.
       - Add axiom: null address (0) is not allocated:
         (assert (not (allocated #x0000000000000000)))

    2. generate_null_check_vc(ptr_local: &str, description: &str) -> VerificationCondition:
       - Generate VC asserting ptr != null (ptr != 0 as 64-bit bitvector).
       - Script: declare ptr as BitVec(64), assert (not (= ptr #x0000000000000000)), check-sat.
       - If UNSAT: pointer is always null (verification failure).
       - If SAT: pointer can be non-null (verification passes).
       - Wait, correction: The VC pattern in this codebase is: assert the NEGATION of the
         property, check-sat. If UNSAT, property holds. If SAT, counterexample found.
       - So for null-check: assert (= ptr null). If UNSAT, ptr is never null (good).
         If SAT, ptr can be null (bad -- memory safety violation).
       - But we need context: the ptr's declared value from the path condition.
       - Simpler approach matching existing VC pattern:
         The VC script should contain the path-condition assertions from VCGen,
         then assert (= ptr #x0000000000000000) as the check.
         UNSAT = ptr is never null = property holds.
         SAT = ptr can be null = violation found.
       - Return VerificationCondition with:
         - description: "raw pointer dereference requires non-null: {description}"
         - vc_kind: VcKind::MemorySafety
         - The actual script assembly happens in VCGen; this function returns the
           null-check assertion term: Term::Eq(ptr_term, null_term)
       - Actually, to match existing patterns (see recursion.rs, borrow_conflict.rs):
         provide a function that returns the assertion Term, not a full VC.
         VCGen assembles the full script.

       Revised: generate_null_check_assertion(ptr_name: &str) -> Term:
       - Returns Term::Eq(Term::Const(ptr_name), Term::BitVecLit(0, 64))
       - This is the "bad condition" -- if SAT, ptr can be null.

    3. generate_bounds_check_assertion(ptr_name: &str, offset_name: &str) -> Term:
       - Returns the assertion that the offset violates bounds:
         effective_offset = BvAdd(BvSub(ptr, alloc_base(ptr)), offset)
         violation = NOT(BvUlt(effective_offset, alloc_size(ptr)))
       - Actually, following the VC convention (assert negation, check SAT):
         We want to check: offset is within bounds.
         Negation (what we assert): offset is OUT of bounds.
         SAT = violation found. UNSAT = bounds hold.
       - Generate: (not (bvult (bvadd (bvsub ptr (alloc_base ptr)) offset) (alloc_size ptr)))
       - Use Term::Not(Term::BvUlt(effective_offset, size))
       - Where effective_offset = Term::BvAdd(Term::BvSub(ptr, alloc_base_of_ptr), offset_term)
       - And alloc_base_of_ptr = Term::App("alloc_base", [ptr_term])
       - And size = Term::App("alloc_size", [ptr_term])

    4. heap_model_declarations_needed(func: &Function) -> bool:
       - Returns true if function has any UnsafeOperation::PtrArithmetic.
       - Heap model declarations only needed when bounds checks are generated.
       - Null checks don't need heap model (just ptr != 0).

    Register both modules in lib.rs:
      pub mod unsafe_analysis;
      pub mod heap_model;

    Tests to write FIRST (RED phase):
    For unsafe_analysis.rs:
    - test_detect_unsafe_blocks_empty: Function with no unsafe blocks -> empty
    - test_detect_unsafe_blocks_with_blocks: Function with unsafe_blocks -> returns them
    - test_detect_unsafe_blocks_unsafe_fn_synthetic: unsafe fn with empty blocks -> synthetic block added
    - test_extract_unsafe_operations: Function with operations -> returns them
    - test_classify_provenance_raw_deref: RawDeref with FromRef -> FromRef
    - test_classify_provenance_ptr_arithmetic: PtrArithmetic -> Unknown
    - test_needs_null_check_from_ref: FromRef provenance -> false (skip null check)
    - test_needs_null_check_from_int: FromInt provenance -> true
    - test_needs_null_check_unknown: Unknown provenance -> true
    - test_needs_bounds_check_arithmetic: PtrArithmetic -> true
    - test_needs_bounds_check_deref: RawDeref -> false
    - test_check_missing_contracts_unsafe_fn: unsafe fn with no contracts -> warning message
    - test_check_missing_contracts_annotated: unsafe fn with contracts -> None
    - test_check_missing_contracts_safe_fn: safe fn -> None
    - test_is_trusted_function_true: Function with is_trusted=true -> true
    - test_is_trusted_function_false: Function without trusted -> false
    - test_get_unsafe_requires: Function with unsafe contracts -> returns requires
    - test_get_unsafe_ensures: Function with unsafe contracts -> returns ensures
    - test_get_unsafe_requires_none: Function without contracts -> empty

    For heap_model.rs:
    - test_declare_heap_model_count: Returns expected number of commands (5: heap, allocated, alloc_base, alloc_size, null-not-allocated axiom)
    - test_declare_heap_model_has_heap: First command declares "heap" function
    - test_declare_heap_model_has_allocated: Command declares "allocated" function
    - test_declare_heap_model_null_axiom: Last command asserts null not allocated
    - test_generate_null_check_assertion: ptr_name="p" -> Eq(Const("p"), BitVecLit(0, 64))
    - test_generate_bounds_check_assertion: ptr="p", offset="off" -> correct term structure
    - test_heap_model_needed_with_arithmetic: Function with PtrArithmetic -> true
    - test_heap_model_needed_without_arithmetic: Function with only RawDeref -> false
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    unsafe_analysis.rs module exists with detection, extraction, provenance, null/bounds check
    predicates, missing contract warning, and trusted function checking. heap_model.rs module
    exists with heap-as-array model declarations, null-check and bounds-check assertion
    generators, and heap model necessity predicate. Both modules registered in lib.rs.
    All ~27 new tests pass. All existing tests pass (0 regressions).
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate unsafe analysis into VCGen pipeline (TDD)</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/analysis/src/spec_parser.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In vcgen.rs, integrate unsafe analysis into the generate_vcs function. Follow the existing
    pattern established by recursion analysis (lines ~290-330) and closure analysis (lines ~340-380):

    1. Add unsafe analysis section after borrow validity section in generate_vcs():
       ```
       // === Unsafe code analysis (Phase 10) ===
       ```

       a. Check if function is trusted:
          - If unsafe_analysis::is_trusted_function(func) is true:
            - Skip ALL body verification for this function
            - Only contracts (unsafe_requires/unsafe_ensures) are relevant at call sites
            - Add a diagnostic message (tracing::info) noting trusted function skipped
            - Return early with empty VCs (or only the contract declarations)

       b. Detect unsafe blocks:
          - Call unsafe_analysis::detect_unsafe_blocks(func)
          - For each unsafe block, add it to a "flagged unsafe blocks" list
            (these get surfaced in Plan 03 diagnostics)

       c. Check missing contracts:
          - Call unsafe_analysis::check_missing_unsafe_contracts(func)
          - If Some(warning_message), generate a diagnostic VC (always-SAT pattern):
            - Same pattern as missing-decreases (Phase 6): assert(true), check-sat
            - VcKind::MemorySafety
            - Description: the warning message from check_missing_unsafe_contracts
            - This implements USF-06: warning for unannotated unsafe functions

       d. Extract unsafe operations:
          - Call unsafe_analysis::extract_unsafe_operations(func)

       e. For each UnsafeOperation, generate VCs:
          - If needs_null_check(op) is true:
            - Get ptr_name from the operation
            - Generate null-check VC using heap_model::generate_null_check_assertion(ptr_name)
            - Wrap in VerificationCondition with VcKind::MemorySafety
            - Description: "null-check: raw pointer dereference of {ptr_name} requires non-null"
            - The assertion is the "bad condition" (ptr == null) -- SAT means violation
          - If needs_bounds_check(op) is true:
            - Get ptr_name and offset_name from the operation
            - If heap_model_declarations_needed(func), prepend heap model to script declarations
            - Generate bounds-check VC using heap_model::generate_bounds_check_assertion(ptr, offset)
            - Wrap in VerificationCondition with VcKind::MemorySafety
            - Description: "bounds-check: pointer arithmetic on {ptr_name} with offset {offset_name}"

       f. Add heap model declarations to script when needed:
          - If any PtrArithmetic operations exist, call declare_heap_model()
          - Prepend the returned commands to the VC script declarations list
          - This ensures alloc_base/alloc_size functions are available in bounds-check VCs

    2. Add unsafe contract checking at call sites:
       Extend the existing call-site VC generation (the inter-procedural section) to handle
       unsafe function contracts:
       - When a call to a function is encountered and the callee has unsafe_contracts:
         - Assert callee's unsafe_requires as precondition VCs at the call site
           (same pattern as regular precondition checking via ContractDatabase)
         - Assume callee's unsafe_ensures as postcondition assumptions
         - If callee is trusted, do NOT generate body VCs for callee
       - NOTE: This integrates with the existing ContractDatabase/FunctionSummary mechanism.
         The driver will populate FunctionSummary with unsafe contract info.
         For now, add the logic to check for unsafe contracts when they exist in the
         function being analyzed (self-contained verification).

    3. Handle VcKind::MemorySafety in the VC location/description plumbing:
       - Ensure VcLocation struct can carry VcKind::MemorySafety
       - Ensure VerificationCondition can be created with this kind
       - No new fields needed; VcKind enum already extended in Plan 01

    In spec_parser.rs:
    - No changes needed for basic unsafe contracts. The existing parse_spec_expr already
      handles expressions like "ptr != null", "offset < size", etc.
    - Verify that "ptr != null" parses correctly with existing spec parser infrastructure
      by adding a test. The parser should handle identifier comparison with null literal
      -- NOTE: "null" is not a Rust keyword. In the spec language, it may need to be
      handled as an identifier that maps to a zero bitvector. For v0.2, keep it simple:
      treat "null" as an identifier in specs. The encoding layer will map it to BitVecLit(0, 64)
      when the context type is a raw pointer. Add this null-identifier handling to encode_term
      if needed, or document it as a known limitation and use "0 as *const T" syntax instead.

    Tests to write FIRST (RED phase):
    - test_vcgen_trusted_function_skipped: Function with is_trusted=true produces no body VCs
    - test_vcgen_unsafe_block_flagged: Function with unsafe_blocks produces diagnostic output
    - test_vcgen_missing_contracts_warning: Unsafe fn without contracts produces always-SAT diagnostic VC
    - test_vcgen_null_check_generated: Function with RawDeref (Unknown provenance) produces null-check VC
    - test_vcgen_null_check_skipped_from_ref: Function with RawDeref (FromRef provenance) produces no null-check VC
    - test_vcgen_bounds_check_generated: Function with PtrArithmetic produces bounds-check VC
    - test_vcgen_heap_model_included: Function with PtrArithmetic has heap model declarations in VC script
    - test_vcgen_unsafe_requires_at_callsite: Call to unsafe fn checks unsafe_requires as precondition
    - test_vcgen_unsafe_ensures_assumed: Call to unsafe fn assumes unsafe_ensures as postcondition
    - test_vcgen_memory_safety_vc_kind: Generated VCs have VcKind::MemorySafety
    - test_vcgen_safe_function_no_unsafe_vcs: Safe function with no unsafe code produces no MemorySafety VCs
    - test_vcgen_unsafe_fn_no_operations_warning_only: Unsafe fn with no operations but no contracts -> warning only
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    VCGen integrates unsafe analysis: trusted functions skip body verification, unsafe blocks
    are detected and flagged, missing contracts produce diagnostic warnings, raw pointer
    dereferences generate null-check VCs, pointer arithmetic generates bounds-check VCs with
    heap model, unsafe contracts are checked at call sites. All ~12 new VCGen tests pass.
    All existing tests pass (0 regressions). 0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- unsafe_analysis.rs functions correctly detect and classify unsafe operations
- heap_model.rs generates valid SMT-LIB declarations and assertions
- VCGen produces MemorySafety VCs for raw pointer operations
- Trusted functions have body verification skipped
- Missing unsafe contracts produce diagnostic warnings
- Null-check VCs skipped for FromRef provenance (safe reference origin)
</verification>

<success_criteria>
1. unsafe_analysis.rs module exists with all 9 functions
2. heap_model.rs module exists with heap-as-array model and assertion generators
3. VCGen integrates unsafe analysis: detection, null-check, bounds-check, trusted skip
4. Missing contract warning generated for unannotated unsafe functions (USF-06)
5. FromRef provenance skips null-check (no false positives from safe references)
6. Unsafe contracts checked at call sites
7. ~39 new tests passing, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/10-unsafe-code-detection/10-02-SUMMARY.md`
</output>

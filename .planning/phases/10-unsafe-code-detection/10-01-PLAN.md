---
phase: 10-unsafe-code-detection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/lib.rs
  - crates/macros/src/lib.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "UnsafeBlockInfo IR type represents an unsafe block with source location and reason"
    - "UnsafeOperation IR enum captures raw pointer dereference, pointer arithmetic, and pointer cast"
    - "UnsafeContracts IR struct stores unsafe_requires, unsafe_ensures, and is_trusted fields"
    - "RawPtrProvenance enum tracks pointer origin (FromRef, FromInt, Unknown) for null-check optimization"
    - "VcKind::MemorySafety enables unsafe-specific verification diagnostics"
    - "Function struct extended with unsafe_blocks, unsafe_operations, and unsafe_contracts fields"
    - "#[unsafe_requires], #[unsafe_ensures], and #[verifier::trusted] proc macros compile and embed annotations"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "UnsafeBlockInfo, UnsafeOperation, UnsafeContracts, RawPtrProvenance types and Function fields"
      contains: "UnsafeBlockInfo"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::MemorySafety variant"
      contains: "MemorySafety"
    - path: "crates/macros/src/lib.rs"
      provides: "#[unsafe_requires], #[unsafe_ensures], #[verifier::trusted] proc macros"
      contains: "unsafe_requires"
    - path: "crates/driver/src/diagnostics.rs"
      provides: "VcKind::MemorySafety description, suggestion, and formatting"
      contains: "MemorySafety"
    - path: "crates/driver/src/callbacks.rs"
      provides: "VcKind::MemorySafety serialization"
      contains: "memory_safety"
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "UnsafeBlockInfo, UnsafeOperation, UnsafeContracts types used in VC generation"
      pattern: "use crate::ir::"
    - from: "crates/macros/src/lib.rs"
      to: "crates/driver/src/callbacks.rs"
      via: "Doc attribute encoding (rust_fv::unsafe_requires::EXPR) parsed in driver"
      pattern: "rust_fv::unsafe_requires"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::MemorySafety match arm in diagnostic formatting"
      pattern: "VcKind::MemorySafety"
---

<objective>
Add unsafe code IR types (UnsafeBlockInfo, UnsafeOperation, UnsafeContracts, RawPtrProvenance),
VcKind::MemorySafety, Function struct extensions, proc macros for unsafe contracts and trusted
functions, and driver diagnostics for memory safety violations.

Purpose: Establish the foundational data structures, annotations, and diagnostic infrastructure
that Plans 02 and 03 will use for unsafe block detection, memory safety VC generation, heap model
encoding, and end-to-end unsafe code verification.

Output: Extended IR with unsafe types, VcKind::MemorySafety in analysis and driver, three new
proc macros (unsafe_requires, unsafe_ensures, verifier::trusted), and memory safety diagnostics.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unsafe-code-detection/10-RESEARCH.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/lib.rs
@crates/macros/src/lib.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unsafe IR types, VcKind::MemorySafety, and Function extensions (TDD)</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/encode_sort.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In ir.rs, add the following types (place after ReborrowChain and before ClosureInfo):

    1. RawPtrProvenance enum:
       - FromRef (pointer derived from safe reference -- guaranteed non-null)
       - FromInt (pointer derived from integer cast -- unknown validity)
       - Unknown (provenance not determined)
       Derive: Debug, Clone, PartialEq, Eq

    2. UnsafeBlockInfo struct:
       - block_index: usize (basic block index where unsafe block starts)
       - source_description: String (human-readable description, e.g., "unsafe block at line 42")
       - reason: String (why this is unsafe, e.g., "raw pointer dereference", "unsafe function call")
       Derive: Debug, Clone, PartialEq, Eq

    3. UnsafeOperation enum:
       - RawDeref { ptr_local: String, ptr_ty: Ty, provenance: RawPtrProvenance, block_index: usize }
       - PtrArithmetic { ptr_local: String, offset_local: String, ptr_ty: Ty, is_signed_offset: bool, block_index: usize }
       - PtrCast { source_local: String, source_ty: Ty, target_ty: Ty, provenance: RawPtrProvenance, block_index: usize }
       Derive: Debug, Clone, PartialEq, Eq

    4. UnsafeContracts struct:
       - requires: Vec<SpecExpr> (safety preconditions from #[unsafe_requires])
       - ensures: Vec<SpecExpr> (safety postconditions from #[unsafe_ensures])
       - is_trusted: bool (true if #[verifier::trusted] is present)
       Derive: Debug, Clone, PartialEq, Eq
       Implement Default: requires empty, ensures empty, is_trusted false.

    5. Extend Function struct with new fields (after reborrow_chains):
       - unsafe_blocks: Vec<UnsafeBlockInfo> (default: empty vec)
       - unsafe_operations: Vec<UnsafeOperation> (default: empty vec)
       - unsafe_contracts: Option<UnsafeContracts> (default: None)
       - is_unsafe_fn: bool (default: false -- true if function is declared unsafe)
       IMPORTANT: Update ALL existing Function construction sites in tests and production code
       to include these new fields with defaults. Search for "reborrow_chains:" across the
       workspace and add the four new fields after each occurrence.

    In vcgen.rs:
    - Add VcKind::MemorySafety variant to the VcKind enum (after BorrowValidity).
      This represents memory safety VCs: null-check, bounds-check, use-after-free.

    In encode_sort.rs:
    - Add a helper function for pointer address sort:
      pub fn ptr_addr_sort() -> Sort { Sort::BitVec(64) }
    - This provides a consistent 64-bit bitvector sort for raw pointer addresses.

    In driver callbacks.rs:
    - Add VcKind::MemorySafety to vc_kind_to_string(): return "memory_safety".

    In driver diagnostics.rs:
    - Add VcKind::MemorySafety to vc_kind_description(): return "memory safety violation".
    - Add VcKind::MemorySafety to suggest_fix(): return suggestion about adding safety contracts
      (#[unsafe_requires(ptr != null)] for null-safety, #[unsafe_requires(offset < size)] for
      bounds-safety, or #[verifier::trusted] for manually verified functions).
    - Add VcKind::MemorySafety handling in report_text_only() (after BorrowValidity block):
      print memory safety help message explaining unsafe code verification approach.
    - Add VcKind::MemorySafety to report_with_ariadne() severity handling (Warning severity,
      NOT Error -- per USF-06 unsafe code produces warnings, not hard errors).
    - Add format_memory_safety_help() function: explains the three-tier unsafe verification
      approach (detection, basic checks, contract-based trust boundaries).
    - Add format_unsafe_contract_help() function: explains how to annotate unsafe functions
      with #[unsafe_requires]/#[unsafe_ensures] and when to use #[verifier::trusted].
    - Add VcKind::MemorySafety to ALL test arrays that exercise all VcKind variants
      (search for "VcKind::BorrowValidity" in test arrays and add MemorySafety after each).

    Tests to write FIRST (RED phase):
    - test_raw_ptr_provenance_variants: Create all three provenance variants, verify equality
    - test_unsafe_block_info_creation: Create UnsafeBlockInfo, verify fields
    - test_unsafe_operation_raw_deref: Create RawDeref variant, verify fields
    - test_unsafe_operation_ptr_arithmetic: Create PtrArithmetic variant, verify fields
    - test_unsafe_operation_ptr_cast: Create PtrCast variant, verify fields
    - test_unsafe_contracts_default: Default has empty requires/ensures, is_trusted=false
    - test_unsafe_contracts_with_requires: UnsafeContracts with preconditions
    - test_unsafe_contracts_trusted: UnsafeContracts with is_trusted=true
    - test_function_unsafe_fields: Create Function with unsafe fields, verify accessible
    - test_function_is_unsafe_fn: Create Function with is_unsafe_fn=true
    - test_ptr_addr_sort: Verify ptr_addr_sort() returns Sort::BitVec(64)
    - test_vc_kind_memory_safety_eq: Verify VcKind::MemorySafety equality and distinctness
    - test_vc_kind_memory_safety_description: Verify diagnostic description string
    - test_vc_kind_memory_safety_to_string: Verify callback serialization string
    - test_vc_kind_memory_safety_suggest_fix: Verify suggestion mentions contracts/trusted
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    All new IR types (RawPtrProvenance, UnsafeBlockInfo, UnsafeOperation, UnsafeContracts) exist
    with correct fields. Function struct extended with unsafe_blocks, unsafe_operations,
    unsafe_contracts, is_unsafe_fn. VcKind::MemorySafety added and handled in all driver match
    arms. ptr_addr_sort() helper exists in encode_sort. All existing tests still pass (0
    regressions). All ~15 new tests pass. 0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unsafe contract proc macros (TDD)</name>
  <files>
    crates/macros/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In crates/macros/src/lib.rs, add three new proc macro attributes:

    1. #[unsafe_requires(expr)] proc macro:
       - Uses the existing spec_attribute helper: spec_attribute("unsafe_requires", attr, item)
       - Same pattern as #[requires] -- parses expr as syn::Expr, embeds as doc comment
         with format "rust_fv::unsafe_requires::EXPR"
       - Add doc comment explaining this is a safety precondition for unsafe functions
       - Example: #[unsafe_requires(ptr != null)] on an unsafe fn

    2. #[unsafe_ensures(expr)] proc macro:
       - Uses the existing spec_attribute helper: spec_attribute("unsafe_ensures", attr, item)
       - Same pattern as #[ensures] -- embeds as "rust_fv::unsafe_ensures::EXPR"
       - Add doc comment explaining this is a safety postcondition for unsafe functions
       - Example: #[unsafe_ensures(result != null)]

    3. #[verifier::trusted] proc macro:
       NOTE: Rust proc macros cannot use :: in attribute paths directly. Instead:
       - Create a #[trusted] proc macro attribute (simple name, no path)
       - Implementation: use a variant of the pure_impl pattern -- parse the item, attach
         a doc comment "rust_fv::trusted" (no expression), pass through the item unchanged.
       - Alternatively, simpler approach: spec_attribute-like but with empty expression:
         embed #[doc = "rust_fv::trusted"] on the item. Do NOT parse attr as expression --
         trusted takes no arguments. Implementation:
         ```
         #[proc_macro_attribute]
         pub fn trusted(attr: TokenStream, item: TokenStream) -> TokenStream {
             // attr should be empty (no arguments)
             if !attr.is_empty() {
                 // Return compile error: #[trusted] takes no arguments
             }
             let item = proc_macro2::TokenStream::from(item);
             quote::quote! {
                 #[doc(hidden)]
                 #[doc = "rust_fv::trusted"]
                 #item
             }.into()
         }
         ```
       - Add doc comment explaining trusted functions have body verification skipped
         but call-site contracts are still checked.

    4. Add trusted_impl(attr, item) function (proc_macro2-based) for unit testing,
       following the pattern of pure_impl and borrow_ensures_impl.

    Tests to write FIRST (RED phase):
    - test_unsafe_requires_embeds_annotation: Apply #[unsafe_requires(x > 0)] to fn,
      verify output contains doc = "rust_fv::unsafe_requires::x > 0"
    - test_unsafe_ensures_embeds_annotation: Apply #[unsafe_ensures(result > 0)] to fn,
      verify output contains doc = "rust_fv::unsafe_ensures::result > 0"
    - test_trusted_embeds_annotation: Apply #[trusted] to fn,
      verify output contains doc = "rust_fv::trusted"
    - test_unsafe_requires_complex_expr: Apply #[unsafe_requires(ptr != null && len > 0)]
      to unsafe fn, verify doc comment contains the full expression
    - test_trusted_no_args: Verify #[trusted] with empty attr works correctly
    - test_unsafe_requires_on_unsafe_fn: Apply to `unsafe fn`, verify item preserved unchanged
      (function signature and body retained)
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Three new proc macros exist: #[unsafe_requires(expr)], #[unsafe_ensures(expr)], #[trusted].
    All macros embed doc comment annotations following existing spec_attribute pattern.
    #[trusted] takes no arguments and embeds "rust_fv::trusted". All ~6 new tests pass.
    All existing tests pass (0 regressions). 0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- New IR types accessible from other modules
- VcKind::MemorySafety handled in all match arms (no compiler warnings)
- Proc macros compile and embed correct doc annotations
- Function struct extended with all unsafe-related fields
</verification>

<success_criteria>
1. RawPtrProvenance, UnsafeBlockInfo, UnsafeOperation, UnsafeContracts types exist in ir.rs
2. Function struct extended with unsafe_blocks, unsafe_operations, unsafe_contracts, is_unsafe_fn
3. VcKind::MemorySafety exists and is handled in driver callbacks + diagnostics
4. ptr_addr_sort() helper exists in encode_sort
5. #[unsafe_requires], #[unsafe_ensures], #[trusted] proc macros exist and embed annotations
6. Memory safety diagnostics provide helpful fix suggestions
7. ~21 new tests passing, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/10-unsafe-code-detection/10-01-SUMMARY.md`
</output>

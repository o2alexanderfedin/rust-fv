---
phase: 10-unsafe-code-detection
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - crates/driver/src/diagnostics.rs
  - crates/analysis/tests/unsafe_verification.rs
autonomous: true

must_haves:
  truths:
    - "Developer writes unsafe block and verifier flags it in output with source location and warning"
    - "Developer dereferences raw pointer and verifier generates null-check VC (ptr != null)"
    - "Developer performs pointer arithmetic and verifier generates bounds-check VC (offset < allocation_size)"
    - "Developer annotates unsafe function with #[unsafe_requires]/#[unsafe_ensures] and verifier checks contract at call sites"
    - "Developer marks unsafe function as #[verifier::trusted] and verifier skips body verification but checks call-site contracts"
    - "Unsafe code without annotations produces warning (not hard error) with suggestion to add contracts"
    - "FromRef provenance skips null-check (no false positive for ptr derived from safe reference)"
  artifacts:
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Memory safety diagnostic formatting, unsafe block flagging output, trusted function warning"
      contains: "format_unsafe_block_warning"
    - path: "crates/analysis/tests/unsafe_verification.rs"
      provides: "End-to-end unsafe verification tests via Z3"
      min_lines: 400
  key_links:
    - from: "crates/analysis/tests/unsafe_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "generate_vcs called with unsafe Function IR"
      pattern: "generate_vcs"
    - from: "crates/analysis/tests/unsafe_verification.rs"
      to: "crates/analysis/src/unsafe_analysis.rs"
      via: "detect_unsafe_blocks, extract_unsafe_operations for test assertions"
      pattern: "unsafe_analysis::"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::MemorySafety formatted in diagnostic output"
      pattern: "VcKind::MemorySafety"
---

<objective>
Create end-to-end unsafe code verification tests via Z3, add unsafe-specific diagnostic
formatting (unsafe block warnings, trusted function notices, memory safety counterexamples),
and validate all 5 Phase 10 success criteria and all 7 requirements (USF-01 through USF-06,
INF-02).

Purpose: Prove the entire unsafe code verification pipeline works end-to-end by constructing
unsafe Function IR, generating VCs, submitting to Z3, and verifying expected SAT/UNSAT results.
This is the final integration and validation step for Phase 10.

Output: unsafe_verification.rs integration test file with comprehensive e2e tests,
extended diagnostics.rs with unsafe-specific formatting functions.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unsafe-code-detection/10-RESEARCH.md
@.planning/phases/10-unsafe-code-detection/10-01-SUMMARY.md
@.planning/phases/10-unsafe-code-detection/10-02-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/unsafe_analysis.rs
@crates/analysis/src/heap_model.rs
@crates/driver/src/diagnostics.rs
@crates/analysis/tests/lifetime_verification.rs
@crates/analysis/tests/trait_verification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unsafe-specific diagnostic formatting</name>
  <files>
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    Extend diagnostics.rs with unsafe-specific formatting functions. Follow the existing patterns
    from borrow validity diagnostics (format_borrow_timeline, format_borrow_fix_suggestion) and
    trait diagnostics (format_behavioral_subtyping_help).

    1. Add format_unsafe_block_warning(block_desc: &str, reason: &str) -> String:
       - Format: "warning: unsafe code detected: {block_desc}\n  Reason: {reason}\n
         The verifier flags all unsafe code for review. Consider adding safety contracts
         or marking with #[trusted] if manually verified."

    2. Add format_null_check_failure(ptr_name: &str) -> String:
       - Format: "Raw pointer '{ptr_name}' may be null at dereference.\n
         The verifier could not prove the pointer is non-null.\n
         Suggestion: Add #[unsafe_requires({ptr_name} != null)] to the function,
         or ensure the pointer is derived from a valid reference."

    3. Add format_bounds_check_failure(ptr_name: &str, offset_name: &str) -> String:
       - Format: "Pointer arithmetic on '{ptr_name}' with offset '{offset_name}' may exceed
         allocation bounds.\n  The verifier could not prove the offset stays within the
         allocated region.\n  Suggestion: Add #[unsafe_requires({offset_name} < alloc_size)]
         to the function."

    4. Add format_trusted_function_notice(func_name: &str) -> String:
       - Format: "note: function '{func_name}' is marked #[trusted]\n
         Body verification skipped. Contracts are verified at call sites.\n
         WARNING: Incorrect contracts may lead to unsound verification results.\n
         Ensure manual review has been performed."

    5. Add format_missing_unsafe_contracts_help(func_name: &str) -> String:
       - Format: "warning: unsafe function '{func_name}' has no safety contracts.\n
         Without contracts, the verifier cannot check safety properties at call sites.\n
         Add #[unsafe_requires(...)] for preconditions (e.g., pointer validity).\n
         Add #[unsafe_ensures(...)] for postconditions.\n
         Or mark #[trusted] if the function has been manually verified."

    6. Integrate into report_text_only() and report_with_ariadne():
       - In report_text_only(), after the BorrowValidity block, add a MemorySafety block:
         If failure.vc_kind == VcKind::MemorySafety:
           - Check failure.message to determine which sub-type:
             - If contains "null-check": print format_null_check_failure
             - If contains "bounds-check": print format_bounds_check_failure
             - If contains "no safety contracts": print format_missing_unsafe_contracts_help
           - Always print format_memory_safety_help() (from Plan 01)
       - In report_with_ariadne():
         - Add VcKind::MemorySafety handling: use Warning severity (not Error)
           per USF-06 -- unsafe code warnings are informational, not blocking

    7. Add tests:
       - test_format_unsafe_block_warning: Verify output contains block description and reason
       - test_format_null_check_failure: Verify mentions pointer name and non-null suggestion
       - test_format_bounds_check_failure: Verify mentions pointer, offset, and bounds suggestion
       - test_format_trusted_function_notice: Verify mentions function name and skipped body
       - test_format_missing_unsafe_contracts_help: Verify mentions function name and contract suggestions
       - test_memory_safety_vc_kind_in_all_arrays: Verify MemorySafety is present in all VcKind test arrays
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    Five new diagnostic formatting functions exist for unsafe code scenarios. report_text_only()
    and report_with_ariadne() handle VcKind::MemorySafety with appropriate formatting and
    Warning severity. All ~6 new tests pass. All existing tests pass (0 regressions).
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end unsafe verification tests</name>
  <files>
    crates/analysis/tests/unsafe_verification.rs
  </files>
  <action>
    Create crates/analysis/tests/unsafe_verification.rs following the exact pattern from
    lifetime_verification.rs and trait_verification.rs:
    - Use Z3Solver from rust_fv_solver
    - Use script_to_smtlib helper for rendering SMT-LIB text
    - Use solver_or_skip() pattern for Z3 availability
    - Build Function IR manually, call generate_vcs(), filter by VcKind, verify structure and Z3 results

    Test infrastructure (copy from existing verification test files):
    - solver_or_skip() function: tries to create Z3Solver, panics with Z3_NOT_AVAILABLE if unavailable
    - script_to_smtlib(script: &Script) -> String: renders script to SMT-LIB text
    - Helper: make_unsafe_function(...) to build Function IR with unsafe metadata

    Create these end-to-end tests covering ALL 5 success criteria and ALL 7 requirements:

    SUCCESS CRITERION 1 / USF-01: Unsafe block detection and flagging
    1. test_unsafe_block_detected_and_flagged:
       - Build Function with is_unsafe_fn=false, unsafe_blocks=[UnsafeBlockInfo { block_index: 2,
         source_description: "unsafe block in process_data", reason: "raw pointer dereference" }]
       - Call detect_unsafe_blocks(func)
       - Assert returns 1 block with correct source_description and reason
       - Call generate_vcs(func, None) and verify no crash (graceful handling)

    2. test_unsafe_fn_synthetic_block_added:
       - Build Function with is_unsafe_fn=true, unsafe_blocks=[] (empty)
       - Call detect_unsafe_blocks(func)
       - Assert returns 1 synthetic block with reason "function declared unsafe"

    SUCCESS CRITERION 2 / USF-02: Raw pointer null-check VC generation
    3. test_null_check_vc_raw_deref_from_int:
       - Build Function with unsafe_operations=[RawDeref { ptr_local: "_1", ptr_ty: RawPtr(i32, Shared),
         provenance: FromInt, block_index: 1 }]
       - Call generate_vcs(func, None)
       - Filter VCs by VcKind::MemorySafety
       - Assert at least 1 VC with description containing "null-check"
       - Submit to Z3: should be SAT (ptr from int can be null -- violation possible)

    4. test_null_check_vc_skipped_from_ref:
       - Build Function with unsafe_operations=[RawDeref { ptr_local: "_1", ptr_ty: RawPtr(i32, Shared),
         provenance: FromRef, block_index: 1 }]
       - Call generate_vcs(func, None)
       - Filter VCs by VcKind::MemorySafety
       - Assert 0 null-check VCs (FromRef provenance = safe reference, never null)

    5. test_null_check_vc_with_contract_unsat:
       - Build Function with:
         - unsafe_operations=[RawDeref { ptr_local: "_1", ..., provenance: Unknown }]
         - unsafe_contracts=Some(UnsafeContracts { requires: [parse("_1 != 0")], ... })
       - Call generate_vcs(func, None)
       - The null-check VC should have precondition context (ptr != null assumed)
       - Submit to Z3: should be UNSAT (contract guarantees non-null)

    SUCCESS CRITERION 3 / USF-03: Pointer arithmetic bounds-check VC generation
    6. test_bounds_check_vc_ptr_arithmetic:
       - Build Function with unsafe_operations=[PtrArithmetic { ptr_local: "_1",
         offset_local: "_2", ptr_ty: RawPtr(i32, Mutable), is_signed_offset: false, block_index: 1 }]
       - Call generate_vcs(func, None)
       - Filter VCs by VcKind::MemorySafety
       - Assert at least 1 VC with description containing "bounds-check"
       - Verify VC script contains "alloc_base" and "alloc_size" function references

    7. test_bounds_check_vc_with_heap_model:
       - Build Function with PtrArithmetic operation
       - Call generate_vcs(func, None)
       - Verify the VC script includes heap model declarations (heap, allocated, alloc_base, alloc_size)
       - Submit to Z3 to verify script is well-formed (no parse errors)

    SUCCESS CRITERION 4 / USF-04: Unsafe contract verification at call sites
    8. test_unsafe_requires_checked_at_callsite:
       - Build caller Function that calls an unsafe function with unsafe_requires
       - Set up ContractDatabase with callee having unsafe_requires precondition
       - Call generate_vcs on caller with ContractDatabase
       - Verify precondition VC is generated at call site
       - Submit to Z3: If caller satisfies precondition, UNSAT. If not, SAT.

    SUCCESS CRITERION 5 / USF-05: Trusted function body verification skip
    9. test_trusted_function_body_skipped:
       - Build Function with is_trusted=true, unsafe_contracts with requires/ensures,
         and a function body with operations
       - Call generate_vcs(func, None)
       - Assert NO body VCs are generated (trusted = skip body)
       - Verify only contract-related VCs remain (if any)

    USF-06: Unsafe code without annotations produces warning
    10. test_missing_contracts_warning_vc:
        - Build Function with is_unsafe_fn=true, no unsafe_contracts
        - Call generate_vcs(func, None)
        - Filter VCs by VcKind::MemorySafety
        - Assert at least 1 VC with description containing "no safety contracts"
        - Submit to Z3: should be SAT (diagnostic VC is always-SAT pattern)

    INF-02: VcKind::MemorySafety
    11. test_vc_kind_memory_safety_in_output:
        - Build Function with RawDeref (Unknown provenance)
        - Call generate_vcs(func, None)
        - Assert all unsafe-related VCs have vc_kind == VcKind::MemorySafety

    Additional edge cases:
    12. test_safe_function_no_unsafe_vcs:
        - Build a completely safe Function (no unsafe blocks, operations, or contracts)
        - Call generate_vcs(func, None)
        - Assert 0 VCs with VcKind::MemorySafety

    After writing all tests, run cargo test to verify they pass. If any test fails due to
    implementation gaps, fix the underlying modules (vcgen.rs, unsafe_analysis.rs, heap_model.rs)
    to make tests pass. This is the integration validation step.

    Validate all Phase 10 requirements after tests pass:
    - USF-01: test_unsafe_block_detected_and_flagged, test_unsafe_fn_synthetic_block_added
    - USF-02: test_null_check_vc_raw_deref_from_int, test_null_check_vc_skipped_from_ref, test_null_check_vc_with_contract_unsat
    - USF-03: test_bounds_check_vc_ptr_arithmetic, test_bounds_check_vc_with_heap_model
    - USF-04: test_unsafe_requires_checked_at_callsite
    - USF-05: test_trusted_function_body_skipped
    - USF-06: test_missing_contracts_warning_vc
    - INF-02: test_vc_kind_memory_safety_in_output
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo test -p rust-fv-analysis --test unsafe_verification 2>&amp;1 | tail -20
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    unsafe_verification.rs integration test file exists with 12 end-to-end tests covering all 5
    Phase 10 success criteria and all 7 requirements (USF-01 through USF-06, INF-02). All tests
    pass with Z3. No false positives for FromRef provenance. Trusted functions have body skipped.
    Missing contract warnings generated as always-SAT diagnostic VCs. All existing tests pass
    (0 regressions). 0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- unsafe_verification.rs tests all pass: cargo test -p rust-fv-analysis --test unsafe_verification
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- All 5 Phase 10 success criteria validated by specific tests
- All 7 requirements (USF-01 through USF-06, INF-02) validated by specific tests
- No false positives: FromRef provenance skips null-check
- Trusted function body verification correctly skipped
- Unsafe code warnings are informational (Warning severity, not Error)
</verification>

<success_criteria>
1. unsafe_verification.rs has 12+ end-to-end tests
2. All 5 success criteria have dedicated test(s) validating them
3. All 7 requirements (USF-01 through USF-06, INF-02) have dedicated test(s) validating them
4. Z3 integration: null-check VCs are SAT for unconstrained ptrs, UNSAT with contracts
5. Z3 integration: bounds-check VCs have valid heap model declarations
6. Diagnostic formatting covers all unsafe scenarios (null, bounds, trusted, missing contracts)
7. Total new tests: ~18 (6 diagnostic + 12 e2e), 0 regressions
8. 0 clippy warnings, 0 formatting issues
</success_criteria>

<output>
After completion, create `.planning/phases/10-unsafe-code-detection/10-03-SUMMARY.md`
</output>

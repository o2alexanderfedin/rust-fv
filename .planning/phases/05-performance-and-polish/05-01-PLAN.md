---
phase: 05-performance-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/simplify.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/Cargo.toml
  - crates/analysis/benches/vcgen_bench.rs
  - crates/analysis/benches/stress_bench.rs
  - crates/analysis/tests/simplify_tests.rs
autonomous: true

must_haves:
  truths:
    - "Formula simplification produces equivalent but smaller SMT terms"
    - "Criterion A/B benchmarks measure simplification impact on solver time"
    - "Stress benchmarks with loops and inter-procedural calls establish scalability baselines"
    - "Existing 498+ tests still pass with simplification integrated"
  artifacts:
    - path: "crates/analysis/src/simplify.rs"
      provides: "Formula simplification passes: constant folding, boolean simplification, dead assertion elimination"
      min_lines: 150
    - path: "crates/analysis/benches/stress_bench.rs"
      provides: "Synthetic stress benchmarks for loops, inter-procedural, and complex functions"
      min_lines: 100
    - path: "crates/analysis/benches/vcgen_bench.rs"
      provides: "Extended with A/B simplification comparison benchmarks"
    - path: "crates/analysis/tests/simplify_tests.rs"
      provides: "Unit tests for simplification correctness"
      min_lines: 80
  key_links:
    - from: "crates/analysis/src/simplify.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "simplify_script called on generated VC scripts"
      pattern: "simplify"
    - from: "crates/analysis/benches/vcgen_bench.rs"
      to: "crates/analysis/src/simplify.rs"
      via: "A/B benchmark calling simplify_script"
      pattern: "simplify_script"
---

<objective>
Implement formula simplification passes and extend the benchmark suite to measure their impact on solver time.

Purpose: PERF-05 requires formula simplification to measurably reduce solver time. PERF-02 requires sub-5s verification for complex functions. Benchmarks establish the measurement framework for all Phase 5 performance work.

Output: simplify.rs module with constant folding/boolean simplification, stress benchmarks for scalability limits, A/B comparison benchmarks proving simplification impact.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/lib.rs
@crates/analysis/benches/vcgen_bench.rs
@crates/analysis/Cargo.toml
@crates/smtlib/src/term.rs
@crates/smtlib/src/script.rs
@crates/smtlib/src/command.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Formula simplification module</name>
  <files>
    crates/analysis/src/simplify.rs
    crates/analysis/src/lib.rs
    crates/analysis/tests/simplify_tests.rs
  </files>
  <action>
Create `crates/analysis/src/simplify.rs` implementing SMT formula simplification at the Term/Script level (before solver submission). This operates on our SMT-LIB AST in `rust_fv_smtlib::term::Term` and `rust_fv_smtlib::script::Script`.

Implement these simplification passes:

1. **Constant folding**: Evaluate operations on literal values at AST level.
   - `BvAdd(BitVecLit(a, w), BitVecLit(b, w))` -> `BitVecLit((a+b) mod 2^w, w)`
   - `And(True, x)` -> `x`, `And(False, _)` -> `False`
   - `Or(True, _)` -> `True`, `Or(False, x)` -> `x`
   - `Not(True)` -> `False`, `Not(False)` -> `True`
   - `Not(Not(x))` -> `x` (double negation)

2. **Identity elimination**:
   - `BvAdd(x, BitVecLit(0, w))` -> `x`
   - `BvMul(x, BitVecLit(1, w))` -> `x`
   - `BvMul(_, BitVecLit(0, w))` -> `BitVecLit(0, w)`
   - `Ite(True, t, _)` -> `t`, `Ite(False, _, e)` -> `e`
   - `Implies(True, x)` -> `x`, `Implies(_, True)` -> `True`

3. **Script-level simplification**:
   - `simplify_script(script: &Script) -> Script`: Apply simplification to all Assert command terms
   - Walk each `Command::Assert(term)`, apply `simplify_term(term)` recursively
   - Preserve all non-Assert commands unchanged (DeclareConst, SetLogic, CheckSat, etc.)

4. **Public API**:
   - `pub fn simplify_term(term: &Term) -> Term` -- recursive single-term simplification
   - `pub fn simplify_script(script: &Script) -> Script` -- simplify all assertions in a script

Add module declaration `pub mod simplify;` to `crates/analysis/src/lib.rs`.

Create `crates/analysis/tests/simplify_tests.rs` with unit tests:
- Constant folding for each bitvector and boolean case
- Identity elimination for each pattern
- Double negation
- Ite simplification
- Script-level simplification preserving non-Assert commands
- Nested simplification (simplify inside BvAdd inside And, etc.)
- No-change case (already simplified terms pass through unchanged)

Note: This is AST-level simplification on our own Term type. Z3's built-in simplify() API could also be used via the native backend, but AST-level simplification avoids solver overhead entirely and works with both subprocess and native backends. Per user decision: "pick based on measured impact" -- start with AST-level, benchmark both approaches in Task 2.
  </action>
  <verify>
`cargo test -p rust-fv-analysis --test simplify_tests` passes all simplification unit tests.
`cargo test -p rust-fv-analysis` passes (all existing tests unaffected).
`cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
simplify_term correctly folds constants, eliminates identities, and handles nested terms. simplify_script transforms VC scripts with simplified assertions. All existing 498+ tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Benchmark suite extension with A/B simplification comparison</name>
  <files>
    crates/analysis/benches/vcgen_bench.rs
    crates/analysis/benches/stress_bench.rs
    crates/analysis/Cargo.toml
  </files>
  <action>
Extend the existing Criterion benchmark suite per user decisions:
- Both existing E2E test programs (regression baselines) AND synthetic stress tests (scalability limits)
- Formula simplification measured via A/B comparison
- Benchmarks are developer-only, not CI-gated

**1. Extend `crates/analysis/benches/vcgen_bench.rs`:**

Add an A/B benchmark group `simplification` that compares:
- `without_simplify`: Generate VCs and submit to Z3 directly (existing flow)
- `with_simplify`: Generate VCs, apply `simplify_script`, then submit to Z3

Use the existing `make_max_function()` and `make_clamp_function()` (which already exist in the file) as test subjects. Import `rust_fv_analysis::simplify::simplify_script`.

Add a group for each existing function:
```rust
let mut group = c.benchmark_group("simplification");
group.bench_function("max_without", |b| { ... });
group.bench_function("max_with", |b| { ... });
group.bench_function("clamp_without", |b| { ... });
group.bench_function("clamp_with", |b| { ... });
group.finish();
```

**2. Create `crates/analysis/benches/stress_bench.rs`:**

Add synthetic stress test functions:

a. **Loop stress test**: Function with a loop and invariant (10+ basic blocks). Use the loop IR pattern from existing tests: header block with condition, body block with counter increment, exit block.

b. **Inter-procedural stress test**: Function that calls 3+ other functions (using ContractDatabase with mock summaries). Create caller with multiple CallSiteInfo entries.

c. **Large function stress test**: Function with 20+ basic blocks (deep nesting of if/else). Tests VCGen path explosion.

Each stress function gets:
- `vcgen_only` benchmark (VCGen without solver -- measures VC generation time)
- `e2e` benchmark (VCGen + Z3 -- measures total verification time)
- `e2e_simplified` benchmark (VCGen + simplify + Z3 -- measures simplification benefit)

Register in Cargo.toml:
```toml
[[bench]]
name = "stress_bench"
harness = false
```

**3. Update `crates/analysis/Cargo.toml`:**

Add `rust-fv-analysis` itself as a dependency in dev-dependencies if simplify module needs to be importable from benches (it should be accessible via `rust_fv_analysis::simplify::simplify_script`).

Running benchmarks: `cargo bench -p rust-fv-analysis` runs all benchmark groups. Developer-only, not CI-gated per decision.
  </action>
  <verify>
`cargo bench -p rust-fv-analysis -- --test` compiles and runs all benchmarks (quick validation mode).
Benchmark output shows both "with_simplify" and "without_simplify" groups for each function.
`cargo clippy -p rust-fv-analysis -- -D warnings` produces zero warnings.
  </verify>
  <done>
Criterion benchmarks establish A/B comparison for simplification impact. Stress benchmarks cover loop, inter-procedural, and large-function scenarios. All benchmarks compile and run without errors.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes all 498+ tests
- `cargo bench -p rust-fv-analysis -- --test` compiles all benchmarks
- `cargo clippy --workspace -- -D warnings` produces zero warnings
- simplify_term correctly handles all constant folding and identity patterns
</verification>

<success_criteria>
- Formula simplification module exists with constant folding, identity elimination, and double negation
- Criterion A/B benchmarks compare solver time with and without simplification
- Stress benchmarks establish scalability baselines for loops and inter-procedural calls
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-and-polish/05-01-SUMMARY.md`
</output>

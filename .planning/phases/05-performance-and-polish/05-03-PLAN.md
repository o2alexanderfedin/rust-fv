---
phase: 05-performance-and-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/driver/src/diagnostics.rs
  - crates/driver/src/json_output.rs
  - crates/driver/src/output.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/cargo_verify.rs
  - crates/driver/src/main.rs
  - crates/driver/Cargo.toml
  - crates/analysis/src/vcgen.rs
autonomous: true

must_haves:
  truths:
    - "Verification failure messages show source file and line number"
    - "Verification failure messages show the specific property (contract) that failed"
    - "Verification failure messages show counterexample with concrete variable values"
    - "Error format uses rustc-style colored arrows pointing to the failing spec"
    - "Common failure patterns include fix suggestions (overflow, precondition, invariant)"
    - "--output-format json produces structured JSON output to stdout"
  artifacts:
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Ariadne-based rustc-style error reporting with source locations and fix suggestions"
      min_lines: 150
    - path: "crates/driver/src/json_output.rs"
      provides: "Structured JSON output with serde for --output-format json"
      min_lines: 80
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/diagnostics.rs"
      via: "report_failure called for SAT results"
      pattern: "diagnostics::report|format_failure"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/json_output.rs"
      via: "JSON output when --output-format json"
      pattern: "json_output|output_format"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/driver/src/diagnostics.rs"
      via: "VcLocation carries source span info for error reporting"
      pattern: "VcLocation|source_span"
---

<objective>
Polish verification error messages to guide developers to fixes using rustc-style diagnostics and add structured JSON output for IDE integration.

Purpose: TOOL-05 requires error messages with source location, failed property, and counterexample. This makes rust-fv usable as a development tool rather than a bare pass/fail oracle.

Output: diagnostics.rs with ariadne-based error formatting, json_output.rs for structured output, enhanced VcLocation with source span information, fix suggestions for common patterns.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/driver/src/callbacks.rs
@crates/driver/src/output.rs
@crates/driver/src/cargo_verify.rs
@crates/driver/src/main.rs
@crates/driver/Cargo.toml
@crates/analysis/src/vcgen.rs
@crates/solver/src/result.rs
@crates/solver/src/model.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhanced VcLocation and ariadne diagnostics</name>
  <files>
    crates/driver/src/diagnostics.rs
    crates/driver/src/output.rs
    crates/driver/Cargo.toml
    crates/analysis/src/vcgen.rs
  </files>
  <action>
**1. Enhance `VcLocation` in `crates/analysis/src/vcgen.rs`:**

Add optional source span information to VcLocation:
```rust
pub struct VcLocation {
    pub function: String,
    pub block: usize,
    pub statement: usize,
    // New fields:
    pub source_file: Option<String>,    // Source file path
    pub source_line: Option<usize>,     // 1-based line number
    pub contract_text: Option<String>,  // The specific contract that failed (e.g., "result > 0")
    pub vc_kind: VcKind,                // What kind of VC this is
}

#[derive(Debug, Clone)]
pub enum VcKind {
    Precondition,        // requires clause
    Postcondition,       // ensures clause
    LoopInvariantInit,   // loop invariant initialization
    LoopInvariantPreserve, // loop invariant preservation
    LoopInvariantExit,   // loop invariant after loop
    Overflow,            // arithmetic overflow check
    DivisionByZero,      // division by zero check
    ShiftBounds,         // shift amount bounds check
    Assertion,           // assert!() in code
    PanicFreedom,        // panic-freedom check (unwrap, index, etc.)
}
```

Update all VcLocation construction sites in vcgen.rs to populate `vc_kind` with the appropriate variant based on what VC is being generated (postcondition checks -> Postcondition, overflow checks -> Overflow, etc.). Set `source_file`, `source_line`, and `contract_text` to None for now (they'll be populated by the driver which has access to rustc's source map). The important thing is `vc_kind` and `contract_text` -- `contract_text` should be set when creating postcondition/precondition VCs to the raw spec string.

**2. Create `crates/driver/src/diagnostics.rs`** with ariadne-based error reporting:

Per user decisions:
- Rustc-style error format: source file + line number, colored arrows pointing to failing spec, counterexample below
- Suggest fixes for common patterns
- Variable assignments for counterexample display (already extractable from Z3 model)

```rust
use ariadne::{Report, ReportKind, Label, Color, Source, ColorGenerator};
```

Public functions:

`pub fn report_verification_failure(failure: &VerificationFailure)`:
- Takes a `VerificationFailure` struct containing:
  - `function_name: String`
  - `vc_kind: VcKind`
  - `contract_text: Option<String>` (the spec that failed)
  - `source_file: Option<String>`
  - `source_line: Option<usize>`
  - `counterexample: Option<Vec<(String, String)>>` (variable assignments)
  - `message: String` (description of what failed)

- If source_file and source_line are available:
  - Use ariadne Report::build(ReportKind::Error, source_file, offset)
  - Label pointing to the line with the failing contract
  - Note section with formatted counterexample
  - Help section with fix suggestion based on VcKind

- If source info is NOT available (common case initially):
  - Fall back to enhanced text output with colors via `colored` crate
  - Format: `error[V001]: verification failed: function_name`
  - Show contract text, counterexample, and fix suggestion

`pub fn suggest_fix(vc_kind: &VcKind) -> Option<String>`:
- `Overflow` -> "Consider adding a bounds check or using `checked_add`/`wrapping_add`"
- `Precondition` -> "The caller does not satisfy the callee's precondition. Strengthen the caller's requires clause or weaken the callee's."
- `Postcondition` -> "The function body does not satisfy the ensures clause. Check return paths and edge cases."
- `LoopInvariantInit` -> "The loop invariant does not hold before the loop. Ensure initialization establishes the invariant."
- `LoopInvariantPreserve` -> "The loop body does not preserve the invariant. Check that the invariant holds after each iteration."
- `DivisionByZero` -> "Add a check `divisor != 0` or add `#[requires(divisor != 0)]`"
- `Assertion` -> "The assert condition may not hold on all paths. Add preconditions to constrain inputs."
- Others -> None

`pub fn format_counterexample(assignments: &[(String, String)]) -> String`:
- Filter out internal variables (those starting with `_` that aren't parameters)
- Format as indented variable assignments:
  ```
  Counterexample:
    a = -2147483648
    b = 1
  ```
- Map bitvector hex values to decimal where recognizable

**3. Update `crates/driver/src/output.rs`:**

Add a `VerificationFailure` struct that captures all info needed for diagnostics:
```rust
pub struct VerificationFailure {
    pub function_name: String,
    pub vc_kind: VcKind,
    pub contract_text: Option<String>,
    pub source_file: Option<String>,
    pub source_line: Option<usize>,
    pub counterexample: Option<Vec<(String, String)>>,
    pub message: String,
}
```

Re-export VcKind from analysis crate for use in driver.

Add `ariadne = "0.4"` to `crates/driver/Cargo.toml`.
  </action>
  <verify>
`cargo build -p rust-fv-driver` compiles with ariadne dependency.
`cargo build -p rust-fv-analysis` compiles with enhanced VcLocation.
`cargo test --workspace` passes all existing tests.
`cargo clippy --workspace -- -D warnings` produces zero warnings.
  </verify>
  <done>
VcLocation carries vc_kind and contract_text for all VC types. Ariadne-based diagnostics format errors with source location, counterexample, and fix suggestions. Fallback text output works when source info is unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 2: JSON output and driver integration</name>
  <files>
    crates/driver/src/json_output.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/cargo_verify.rs
    crates/driver/src/main.rs
  </files>
  <action>
**1. Create `crates/driver/src/json_output.rs`** for structured JSON output:

Per user decision: Add --output-format json flag for structured JSON output (enables IDE/rust-analyzer integration).

Define output schema using serde:

```rust
use serde::Serialize;

#[derive(Serialize)]
pub struct JsonVerificationReport {
    pub crate_name: String,
    pub functions: Vec<JsonFunctionResult>,
    pub summary: JsonSummary,
}

#[derive(Serialize)]
pub struct JsonFunctionResult {
    pub name: String,
    pub status: String,           // "ok", "fail", "timeout"
    pub vc_count: usize,
    pub verified_count: usize,
    pub failures: Vec<JsonFailure>,
}

#[derive(Serialize)]
pub struct JsonFailure {
    pub vc_kind: String,          // "postcondition", "overflow", etc.
    pub description: String,
    pub contract: Option<String>, // The spec text
    pub source_file: Option<String>,
    pub source_line: Option<usize>,
    pub counterexample: Option<Vec<JsonAssignment>>,
    pub suggestion: Option<String>,
}

#[derive(Serialize)]
pub struct JsonAssignment {
    pub variable: String,
    pub value: String,
}

#[derive(Serialize)]
pub struct JsonSummary {
    pub total: usize,
    pub ok: usize,
    pub fail: usize,
    pub timeout: usize,
}
```

Function `pub fn print_json_report(report: &JsonVerificationReport)`:
- Serialize to JSON with `serde_json::to_string_pretty`
- Print to **stdout** (not stderr -- per pitfall #5 from research)
- All non-JSON output (progress, warnings) goes to stderr

**2. Update `crates/driver/src/callbacks.rs`:**

Integrate diagnostics and JSON output into the verification pipeline:

Add to `VerificationCallbacks`:
- `output_format: OutputFormat` enum (Text, Json)
- `failures: Vec<VerificationFailure>` -- collect structured failure info

In the verification loop (after each SAT result):
- Build `VerificationFailure` from `VerificationResult` + `VcLocation`
- Extract `vc_kind` and `contract_text` from VcLocation
- Extract counterexample assignments from solver Model

In `print_results()`:
- If `output_format == Text`:
  - Call existing `output::print_verification_results()` for the summary
  - For each failure, call `diagnostics::report_verification_failure()`
- If `output_format == Json`:
  - Build `JsonVerificationReport` from results
  - Call `json_output::print_json_report()`

**3. Update `crates/driver/src/cargo_verify.rs`:**

Add `--output-format` flag parsing:
- `--output-format json` sets `RUST_FV_OUTPUT_FORMAT=json` env var
- `--output-format text` (default) sets nothing
- Update `print_usage()` to document the new flag

When `--output-format json` is active:
- Suppress progress messages (no "Running verification...")
- Only JSON goes to stdout, stderr gets progress/warnings

**4. Update `crates/driver/src/main.rs`:**

Read `RUST_FV_OUTPUT_FORMAT` env var, set `output_format` on `VerificationCallbacks`.

Add module declarations for `diagnostics` and `json_output`.

**Strict separation rule (per research pitfall #5):**
- JSON output -> stdout ONLY
- All diagnostics, progress, tracing -> stderr ONLY
- When `output_format == Json`: suppress colored text output, only emit JSON to stdout
  </action>
  <verify>
`cargo build -p rust-fv-driver` compiles with all new modules.
`cargo test --workspace` passes all existing tests.
`cargo clippy --workspace -- -D warnings` produces zero warnings.
Manually test: `cargo verify --output-format json 2>/dev/null | python3 -m json.tool` produces valid JSON (if test crate available).
  </verify>
  <done>
Verification failures show vc_kind, contract text, counterexample, and fix suggestions in rustc-style format. --output-format json produces valid structured JSON to stdout. All existing colored output preserved for default text mode.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes all 498+ tests
- `cargo build -p rust-fv-driver` compiles with ariadne, serde_json
- `cargo clippy --workspace -- -D warnings` produces zero warnings
- Error messages include vc_kind classification for all VC types
- Fix suggestions appear for overflow, precondition, postcondition, loop invariant failures
- JSON output is valid (parseable by jq/python)
- Counterexample variables are formatted clearly
</verification>

<success_criteria>
- Verification failures include source location (when available), failed property, and counterexample (TOOL-05)
- Fix suggestions guide developers for common failure patterns
- --output-format json produces structured JSON for IDE integration
- Existing colored text output remains the default and is enhanced with diagnostics
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-and-polish/05-03-SUMMARY.md`
</output>

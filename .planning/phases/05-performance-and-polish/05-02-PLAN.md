---
phase: 05-performance-and-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/driver/src/cache.rs
  - crates/driver/src/parallel.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/cargo_verify.rs
  - crates/driver/src/main.rs
  - crates/driver/Cargo.toml
  - crates/analysis/src/call_graph.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/Cargo.toml
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Re-running cargo verify after no source changes skips all verification via cache hits"
    - "Changing one function body or contract invalidates cache for that function, re-verifies it"
    - "Multiple functions verify in parallel using rayon, completing faster than sequential"
    - "Topological order ensures leaf functions (callees) are verified before callers"
    - "--fresh flag forces re-verification bypassing cache"
    - "--jobs N flag controls parallel verification concurrency"
    - "Cache is stored in target/rust-fv-cache/ and cleaned by cargo clean"
  artifacts:
    - path: "crates/driver/src/cache.rs"
      provides: "VC cache with SHA-256 hashing and JSON persistence in target/rust-fv-cache/"
      min_lines: 120
    - path: "crates/driver/src/parallel.rs"
      provides: "Rayon-based parallel verification with configurable thread count"
      min_lines: 80
    - path: "crates/analysis/src/call_graph.rs"
      provides: "Call graph extraction and topological sorting for verification order"
      min_lines: 60
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/cache.rs"
      via: "cache lookup before solver, cache insert after solver"
      pattern: "cache\\.(get|insert)"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/parallel.rs"
      via: "parallel verification dispatch"
      pattern: "verify_parallel|par_iter"
    - from: "crates/driver/src/parallel.rs"
      to: "crates/analysis/src/call_graph.rs"
      via: "topological order for verification"
      pattern: "topological_order|call_graph"
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/simplify.rs"
      via: "simplify VCs before solver submission"
      pattern: "simplify_script"
---

<objective>
Implement VC caching with hash-based invalidation and Rayon-based parallel verification with topological ordering.

Purpose: PERF-03 requires caching to skip unchanged functions. PERF-04 requires parallel verification across solver instances. Together these make `cargo verify` fast enough for interactive development on multi-function crates.

Output: cache.rs with SHA-256 hash-based per-function caching, parallel.rs with rayon per-function parallelism, call_graph.rs for topological ordering, and integration into the driver pipeline.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-and-polish/05-01-SUMMARY.md
@crates/driver/src/callbacks.rs
@crates/driver/src/cargo_verify.rs
@crates/driver/src/main.rs
@crates/driver/src/output.rs
@crates/driver/Cargo.toml
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/lib.rs
@crates/analysis/src/simplify.rs
@crates/solver/src/result.rs
@crates/solver/src/model.rs
@crates/solver/src/solver.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: VC cache and call graph modules</name>
  <files>
    crates/driver/src/cache.rs
    crates/analysis/src/call_graph.rs
    crates/analysis/src/lib.rs
    crates/driver/Cargo.toml
    crates/analysis/Cargo.toml
    Cargo.toml
  </files>
  <action>
**1. Create `crates/driver/src/cache.rs`** implementing per-function VC caching per user decisions:

- Per-function cache granularity: hash function body + contracts as cache key
- Cache stored in `target/rust-fv-cache/` directory (cleaned by `cargo clean`)
- Conservative invalidation: hash of all contracts + all function bodies
- JSON persistence for debuggability

Implementation:
```rust
use sha2::{Sha256, Digest};
use rustc_hash::FxHashMap;
use serde::{Serialize, Deserialize};
```

Struct `VcCache`:
- `entries: FxHashMap<[u8; 32], CacheEntry>` -- in-memory cache
- `cache_dir: PathBuf` -- target/rust-fv-cache/

Struct `CacheEntry` (Serialize/Deserialize):
- `verified: bool` -- overall verification result
- `vc_count: usize` -- number of VCs
- `verified_count: usize` -- number passing
- `message: Option<String>` -- failure message if any

Methods:
- `VcCache::new(cache_dir: PathBuf) -> Self` -- create cache, create dir if needed
- `VcCache::load(&mut self)` -- load all .json files from cache_dir into memory
- `VcCache::compute_key(func_name: &str, contracts: &Contracts, ir_debug: &str) -> [u8; 32]` -- SHA-256 of function name + requires + ensures + invariants + IR debug representation. Use `format!("{:?}", ...)` for IR (conservative: any change in MIR structure changes hash)
- `VcCache::get(&self, key: &[u8; 32]) -> Option<&CacheEntry>` -- lookup
- `VcCache::insert(&mut self, key: [u8; 32], entry: CacheEntry)` -- insert in memory + persist to disk as `{hex_hash}.json`
- `VcCache::clear(&mut self)` -- remove all entries (for --fresh flag)

Use `hex` crate (or manual hex encoding) for hash-to-filename conversion. Prefer writing hex encoding manually (two-char-per-byte loop) to avoid adding the `hex` dependency.

Add to `crates/driver/Cargo.toml`:
```toml
sha2 = "0.10"
rustc-hash = "2.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

Add `sha2`, `rustc-hash`, `serde`, `serde_json` to `[workspace.dependencies]` in root `Cargo.toml`.

**2. Create `crates/analysis/src/call_graph.rs`** for topological verification ordering:

Per user decision: topological verification order -- build call graph, verify leaf functions first.

Struct `CallGraph`:
- `edges: HashMap<String, Vec<String>>` -- caller -> list of callees
- `all_functions: HashSet<String>` -- all function names

Methods:
- `CallGraph::from_functions(functions: &[(String, &Function)]) -> Self` -- scan each function's basic blocks for `Terminator::Call { func_name, .. }` to extract call edges
- `CallGraph::topological_order(&self) -> Vec<String>` -- Kahn's algorithm (BFS-based topological sort). Leaf functions (no outgoing call edges to other verified functions) come first. On cycles, break arbitrarily (warn via tracing).

Add `pub mod call_graph;` to `crates/analysis/src/lib.rs`.

No new dependencies needed for analysis crate -- use std::collections.
  </action>
  <verify>
`cargo build -p rust-fv-driver` compiles with new dependencies.
`cargo build -p rust-fv-analysis` compiles with call_graph module.
`cargo test -p rust-fv-analysis` passes all existing tests.
`cargo clippy --workspace -- -D warnings` produces zero warnings.
  </verify>
  <done>
VcCache persists per-function results to target/rust-fv-cache/ with SHA-256 keys and JSON entries. CallGraph extracts call edges from IR functions and produces topological ordering. Both modules compile without warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parallel verification and driver pipeline integration</name>
  <files>
    crates/driver/src/parallel.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/cargo_verify.rs
    crates/driver/src/main.rs
    crates/driver/Cargo.toml
  </files>
  <action>
**1. Create `crates/driver/src/parallel.rs`** implementing Rayon-based parallel verification:

Per user decisions:
- Per-function parallelism: verify multiple functions simultaneously, each function's VCs run sequentially
- Process-based parallelism via subprocess solver instances (Rayon + subprocess solver)
- Default to cores/2 parallel instances, configurable via --jobs N
- Topological order: verify leaf functions first

Implementation:

```rust
use rayon::prelude::*;
```

Struct `VerificationTask`:
- `name: String`
- `ir_func: Function` (owned, moved into thread)
- `contract_db: Arc<ContractDatabase>` (shared across threads)
- `cache_key: [u8; 32]`

Struct `VerificationTaskResult`:
- `name: String`
- `results: Vec<VerificationResult>` (from callbacks.rs)
- `cache_key: [u8; 32]`
- `from_cache: bool`

Function `verify_functions_parallel(tasks: Vec<VerificationTask>, cache: &mut VcCache, jobs: usize, fresh: bool) -> Vec<VerificationTaskResult>`:
- Build Rayon thread pool with `num_threads(jobs)`
- Group tasks by topological wave (functions in same wave can run parallel)
- For each wave:
  - Check cache for each task (skip if hit and not --fresh)
  - Run remaining tasks in parallel via `par_iter().map(|task| verify_single(task))`
  - `verify_single` creates a NEW Z3Solver per thread (subprocess-based -- each thread gets its own Z3 process)
  - Apply `simplify_script` from 05-01 to VCs before solver submission
  - Insert results into cache

Add to `crates/driver/Cargo.toml`:
```toml
rayon = "1.10"
rust-fv-analysis = { workspace = true }  # already present
```

Add `rayon` to `[workspace.dependencies]` in root `Cargo.toml`.

**2. Update `crates/driver/src/callbacks.rs`:**

Refactor `after_analysis` to:
1. Extract all functions and convert to IR (existing code)
2. Build call graph via `rust_fv_analysis::call_graph::CallGraph::from_functions()`
3. Compute cache keys for each function
4. Load cache from `target/rust-fv-cache/`
5. Check `fresh` flag (from env var `RUST_FV_FRESH=1` or CLI)
6. Dispatch to `parallel::verify_functions_parallel()`
7. Collect results and print via existing `output::print_verification_results()`

Add fields to `VerificationCallbacks`:
- `jobs: usize` -- thread count (default: num_cpus::get() / 2, min 1)
- `fresh: bool` -- force re-verification
- `use_simplification: bool` -- apply formula simplification (default: true)

Log cache statistics via tracing::info: "N functions: M cached, K verified (P in parallel)".

**3. Update `crates/driver/src/cargo_verify.rs`:**

Add `--fresh` flag: sets `RUST_FV_FRESH=1` env var for the driver subprocess.
Add `--jobs N` flag: sets `RUST_FV_JOBS=N` env var. Default: cores/2.
Update `print_usage()` to document new flags.

**4. Update `crates/driver/src/main.rs`:**

Read `RUST_FV_FRESH` and `RUST_FV_JOBS` env vars, pass to `VerificationCallbacks`.

**Important notes:**
- Each parallel worker must create its own `Z3Solver::with_default_config()` to avoid sharing subprocess state.
- Use subprocess solver (not native) for parallel verification -- native Z3 uses global state that is not thread-safe. The subprocess approach naturally isolates each thread's solver.
- Arc<ContractDatabase> for shared read access across threads.
- Cache directory: determine via `std::env::var("CARGO_TARGET_DIR").unwrap_or("target".into())` + "/rust-fv-cache/".
  </action>
  <verify>
`cargo build -p rust-fv-driver` compiles successfully with rayon.
`cargo test --workspace` passes all existing tests.
`cargo clippy --workspace -- -D warnings` produces zero warnings.
Manual test: create a small Rust file with 2+ annotated functions, run `cargo verify`, verify parallel execution via tracing output.
  </verify>
  <done>
cargo verify runs verification in parallel (cores/2 default, --jobs N configurable). Cache hits skip re-verification on unchanged functions. --fresh flag forces full re-verification. Topological order ensures callees are verified before callers. Formula simplification from 05-01 is applied to all VCs before solver submission.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes all 498+ tests
- `cargo build -p rust-fv-driver` compiles with rayon, sha2, rustc-hash, serde_json
- `cargo clippy --workspace -- -D warnings` produces zero warnings
- Cache files appear in target/rust-fv-cache/ after verification run
- Second run with no changes completes faster (cache hits logged)
- --fresh flag causes full re-verification
- --jobs N flag controls parallelism
</verification>

<success_criteria>
- VC caching skips re-verification for unchanged functions (PERF-03)
- Parallel verification runs solver instances concurrently (PERF-04)
- Topological ordering verifies leaf functions first
- --fresh and --jobs flags work as specified
- Formula simplification integrated into verification pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-and-polish/05-02-SUMMARY.md`
</output>

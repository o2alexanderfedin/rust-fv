---
phase: 08-trait-objects
plan: 02
type: tdd
wave: 2
depends_on: ["08-01"]
files_modified:
  - crates/analysis/src/behavioral_subtyping.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/spec_parser.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Behavioral subtyping VCs verify each impl refines trait contracts"
    - "Precondition weakening VC: trait_requires => impl_requires"
    - "Postcondition strengthening VC: impl_ensures => trait_ensures"
    - "Open-world dyn Trait calls use uninterpreted functions with trait contract axioms"
    - "Sealed traits encode as SMT sum types over known implementations"
  artifacts:
    - path: "crates/analysis/src/behavioral_subtyping.rs"
      provides: "Behavioral subtyping VC generation"
      exports: ["generate_subtyping_vcs", "SubtypingVc"]
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Dyn Trait method call handling in VCGen"
      contains: "TraitObject"
    - path: "crates/analysis/src/encode_sort.rs"
      provides: "Sealed trait sum type encoding"
      contains: "sealed"
  key_links:
    - from: "crates/analysis/src/behavioral_subtyping.rs"
      to: "crates/analysis/src/trait_analysis.rs"
      via: "TraitDatabase for trait/impl lookup"
      pattern: "use crate::trait_analysis::"
    - from: "crates/analysis/src/behavioral_subtyping.rs"
      to: "crates/analysis/src/ir.rs"
      via: "TraitDef, TraitImpl for VC generation"
      pattern: "use crate::ir::"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/behavioral_subtyping.rs"
      via: "Calling generate_subtyping_vcs for trait impls"
      pattern: "behavioral_subtyping::"
    - from: "crates/analysis/src/encode_sort.rs"
      to: "crates/analysis/src/trait_analysis.rs"
      via: "TraitDatabase for sealed trait detection"
      pattern: "trait_analysis::"
---

<objective>
Implement behavioral subtyping verification and dynamic dispatch encoding for trait objects.

Purpose: This is the core verification logic for Phase 8. It generates behavioral subtyping VCs
that prove each impl satisfies the trait contract (LSP compliance), encodes dyn Trait method calls
using trait-level contracts (open-world: uninterpreted functions; closed-world: sum types), and
integrates trait-aware handling into VCGen.

Output: behavioral_subtyping.rs module, extended VCGen with dyn Trait support, sealed trait
sum type encoding in encode_sort.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-trait-objects/08-RESEARCH.md
@.planning/phases/08-trait-objects/08-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/trait_analysis.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/encode_term.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/behavioral_subtyping.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create behavioral_subtyping module with LSP verification VCs (TDD)</name>
  <files>
    crates/analysis/src/behavioral_subtyping.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    Create crates/analysis/src/behavioral_subtyping.rs with:

    1. SubtypingVc struct:
       - trait_name: String
       - impl_type: String
       - method_name: String
       - kind: SubtypingKind (enum: PreconditionWeakening, PostconditionStrengthening)
       - description: String (human-readable, e.g., "VecStack::push must accept all inputs Stack::push accepts")
       Derive: Debug, Clone

    2. SubtypingKind enum:
       - PreconditionWeakening (trait_requires => impl_requires)
       - PostconditionStrengthening (impl_ensures => trait_ensures)
       Derive: Debug, Clone, PartialEq, Eq

    3. generate_subtyping_vcs(trait_def: &TraitDef, impl_info: &TraitImpl, trait_db: &TraitDatabase) -> Vec<SubtypingVc>:
       - For each method in trait_def.methods that has contracts (requires or ensures):
         - If method is in impl_info.method_names:
           - If trait method has requires: generate PreconditionWeakening VC
             Description: "{impl_type}::{method} must accept all inputs {trait_name}::{method} accepts"
           - If trait method has ensures: generate PostconditionStrengthening VC
             Description: "{impl_type}::{method} must guarantee at least what {trait_name}::{method} promises"
       - Return collected VCs

    4. encode_precondition_weakening_vc(trait_method: &TraitMethod, impl_type: &str) -> Vec<Command>:
       - Generate SMT commands that encode:
         (assert (not (=> trait_requires impl_requires)))
         For the negation check: if SAT, the precondition weakening FAILS (impl has stronger precondition).
       - Parse trait requires specs via spec_parser::parse_spec, encode as SMT terms.
       - For impl: if impl has no additional requires, impl_requires = true (trivially weaker).
       - Use the trait method's parameter names for variable declarations.
       - Add (check-sat) at end.

    5. encode_postcondition_strengthening_vc(trait_method: &TraitMethod, impl_type: &str) -> Vec<Command>:
       - Generate SMT commands that encode:
         (assert (not (=> impl_ensures trait_ensures)))
         For the negation check: if SAT, the postcondition strengthening FAILS (impl doesn't guarantee trait postcondition).
       - Parse trait ensures specs, encode as SMT terms.
       - For impl: if impl has no additional ensures beyond trait, use trait ensures (trivially satisfied).
       - Use the trait method's parameter names for variable declarations.
       - Add (check-sat) at end.

    6. generate_subtyping_script(trait_def: &TraitDef, impl_info: &TraitImpl) -> Vec<Script>:
       - For each contracted method, generate full SMT-LIB scripts:
         a) Declare parameter sorts
         b) Declare parameter constants
         c) Encode the VC (precondition or postcondition)
         d) check-sat
       - Return one Script per VC.

    Register module in lib.rs: pub mod behavioral_subtyping;

    Tests to write FIRST (RED phase):
    - test_subtyping_vc_creation: Create SubtypingVc with PreconditionWeakening, verify fields
    - test_subtyping_kind_equality: PreconditionWeakening == PreconditionWeakening, != PostconditionStrengthening
    - test_generate_subtyping_vcs_basic: Trait with push(requires, ensures) + impl -> 2 VCs (1 pre-weak, 1 post-strong)
    - test_generate_subtyping_vcs_no_contracts: Trait with no contracts -> 0 VCs
    - test_generate_subtyping_vcs_requires_only: Trait method with only requires -> 1 PreconditionWeakening VC
    - test_generate_subtyping_vcs_ensures_only: Trait method with only ensures -> 1 PostconditionStrengthening VC
    - test_generate_subtyping_vcs_multiple_methods: Trait with 2 contracted methods -> 4 VCs
    - test_generate_subtyping_vcs_missing_impl_method: Trait method not in impl -> skip (no VC for missing method)
    - test_generate_subtyping_vcs_description_format: Verify description contains trait name, impl type, method name
    - test_encode_precondition_weakening_produces_commands: Verify non-empty command list with assert and check-sat
    - test_encode_postcondition_strengthening_produces_commands: Verify non-empty command list with assert and check-sat
    - test_generate_subtyping_script_basic: Trait with 1 contracted method -> 2 scripts (pre + post)
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    behavioral_subtyping.rs module exists with SubtypingVc, SubtypingKind, generate_subtyping_vcs,
    encode_precondition_weakening_vc, encode_postcondition_strengthening_vc, generate_subtyping_script.
    All 12 tests pass. Module registered in lib.rs.
    0 clippy warnings. 0 formatting issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend VCGen and encode_sort for dyn Trait dispatch and sealed traits (TDD)</name>
  <files>
    crates/analysis/src/vcgen.rs
    crates/analysis/src/encode_sort.rs
    crates/analysis/src/encode_term.rs
    crates/analysis/src/spec_parser.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    In vcgen.rs, add trait object handling in generate_vcs():

    1. Add optional TraitDatabase parameter to generate_vcs (or make a new function
       generate_vcs_with_traits that wraps generate_vcs, following the generate_vcs_monomorphized
       pattern for backward compatibility):
       - Accept Option<&TraitDatabase> parameter.
       - When TraitDatabase is provided, check for trait object parameters (Ty::TraitObject).

    2. For each function parameter of type Ty::TraitObject(trait_name):
       - Look up trait_name in TraitDatabase.
       - If trait is found and has method contracts:
         - For OPEN-WORLD (is_sealed = false): Encode trait method as uninterpreted function.
           Add declare-fun for each contracted method: (declare-fun {TraitName}_{method} (TraitObjSort param_sorts...) return_sort).
           Add axiom for each contract: (assert (forall ((obj TraitObjSort) (params...)) (=> pre post))).
         - For CLOSED-WORLD (is_sealed = true): Use sum type encoding (see encode_sort below).
           Declare trait methods as define-fun with match over known implementations.

    3. When processing Call terminators where the callee is a trait object method call:
       - Detect trait object method calls by checking if the callee function name matches a
         trait method pattern (e.g., contains "::" and the receiver param is Ty::TraitObject).
       - Use trait-level contracts (from TraitDatabase) instead of impl-specific contracts.
       - Encode call as: assert trait-level precondition, havoc return, assume trait-level postcondition.
       - This follows the existing modular verification pattern from Phase 3 (ContractDatabase).

    In encode_sort.rs:

    4. Add function encode_sealed_trait_sum_type(trait_name: &str, impl_types: &[String]) -> Command:
       - Generate DeclareDatatype with one variant per known impl:
         (declare-datatype TraitName
           ((TraitName_ImplType1 (as-ImplType1 ImplType1Sort))
            (TraitName_ImplType2 (as-ImplType2 ImplType2Sort))))
       - Each variant has constructor TraitName_ImplType and selector as-ImplType.

    5. Update collect_from_type for Ty::TraitObject:
       - For now, just trace and return (no datatype declaration needed for open-world).
       - Sealed trait sum types will be declared explicitly by VCGen when TraitDatabase is provided.

    In encode_term.rs:

    6. Handle Ty::TraitObject in encode_operand and encode_place_with_type:
       - TraitObject variables are encoded as SMT constants with the trait object sort.
       - For open-world: Sort::Uninterpreted(trait_name) (already done in Plan 01).
       - For sealed: Sort::Datatype(trait_name) (use the sum type declared by encode_sealed_trait_sum_type).

    In spec_parser.rs:

    7. Add trait-level contract parsing support:
       - When parsing specs for a function with trait object parameters, trait method contracts
         should reference the trait object parameter by name (already works via existing spec_parser).
       - Add is_trait_method_call(callee: &str, trait_db: &TraitDatabase) -> Option<(String, String)>
         that returns (trait_name, method_name) if callee matches a known trait method pattern.

    Tests to write FIRST (RED phase):
    - test_encode_sealed_trait_sum_type_two_impls: 2 impls -> DeclareDatatype with 2 variants
    - test_encode_sealed_trait_sum_type_single_impl: 1 impl -> DeclareDatatype with 1 variant
    - test_encode_sealed_trait_sum_type_three_impls: 3 impls -> 3 variants with correct names
    - test_vcgen_trait_object_param_open_world: Function with dyn Trait param, open-world trait -> uninterpreted fn declarations in VCs
    - test_vcgen_trait_object_param_sealed: Function with dyn Trait param, sealed trait with 2 impls -> sum type declaration in VCs
    - test_vcgen_trait_method_call_uses_trait_contract: Call to trait method on dyn Trait -> trait-level precondition asserted
    - test_vcgen_trait_method_call_postcondition_assumed: After trait method call -> trait-level postcondition assumed
    - test_is_trait_method_call_recognized: "Stack::push" recognized with TraitDatabase containing "Stack"
    - test_is_trait_method_call_unknown: "Unknown::method" with empty TraitDatabase returns None
    - test_vcgen_without_trait_db_backward_compatible: generate_vcs with None TraitDatabase -> existing behavior preserved
  </action>
  <verify>
    cargo test --workspace 2>&1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    VCGen handles Ty::TraitObject parameters with open-world (uninterpreted) and
    closed-world (sealed sum type) encoding. encode_sealed_trait_sum_type generates
    correct DeclareDatatype commands. Trait method calls on dyn Trait use trait-level contracts.
    Backward compatibility preserved (None TraitDatabase = existing behavior).
    All 10 new tests pass plus all existing tests. 0 clippy warnings. 0 formatting issues.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- behavioral_subtyping module generates correct VCs for precondition weakening and postcondition strengthening
- VCGen correctly handles trait object parameters (both open-world and sealed)
- encode_sealed_trait_sum_type produces valid SMT-LIB datatype declarations
- Backward compatibility: existing tests pass without TraitDatabase
</verification>

<success_criteria>
1. behavioral_subtyping.rs generates SubtypingVcs for each contracted trait method
2. Precondition weakening VCs encode trait_requires => impl_requires (negated for SAT check)
3. Postcondition strengthening VCs encode impl_ensures => trait_ensures (negated for SAT check)
4. VCGen generates uninterpreted function declarations for open-world dyn Trait params
5. VCGen generates sum type declarations for sealed dyn Trait params
6. Trait method calls on dyn Trait use trait-level contracts (not impl-specific)
7. encode_sealed_trait_sum_type produces DeclareDatatype with one variant per impl
8. ~22 new tests passing (12 + 10), 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-trait-objects/08-02-SUMMARY.md`
</output>

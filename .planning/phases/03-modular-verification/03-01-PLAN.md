---
phase: 03-modular-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/contract_db.rs
  - crates/analysis/tests/interprocedural_tests.rs
  - crates/driver/src/callbacks.rs
autonomous: true

must_haves:
  truths:
    - "A function calling another annotated function has the callee's precondition asserted at the call site"
    - "The callee's return value is havoced (unconstrained) and the callee's postcondition is assumed after the call"
    - "If the call site violates the callee's precondition, verification reports the specific precondition violation"
    - "A 10-function call chain verifies without exponential blowup because each function is checked independently"
    - "Functions without contracts have their calls treated as opaque (backward compatible)"
  artifacts:
    - path: "crates/analysis/src/contract_db.rs"
      provides: "ContractDatabase mapping function names to parsed contracts"
      min_lines: 60
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Call-site encoding: assert-precondition, havoc-return, assume-postcondition"
      contains: "encode_call_site"
    - path: "crates/analysis/tests/interprocedural_tests.rs"
      provides: "E2E tests for inter-procedural verification with Z3"
      min_lines: 200
    - path: "crates/driver/src/callbacks.rs"
      provides: "Contract database construction from HIR and injection into VCGen"
      contains: "ContractDatabase"
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/contract_db.rs"
      via: "ContractDatabase construction from extracted HIR contracts"
      pattern: "ContractDatabase::new|ContractDatabase::from"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/contract_db.rs"
      via: "generate_vcs receives ContractDatabase for callee contract lookup"
      pattern: "contract_db.*lookup|get_contracts"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/spec_parser.rs"
      via: "parse_spec called for callee preconditions and postconditions at call site"
      pattern: "parse_spec.*pre|parse_spec.*post"
---

<objective>
Build the contract database and inter-procedural call-site encoding so that function calls are verified using callee contracts as summaries.

Purpose: This is the core of modular verification -- instead of inlining callee bodies (which causes exponential blowup), each call site asserts the callee's precondition and assumes the callee's postcondition. This enables compositional verification of arbitrarily deep call chains.

Output: ContractDatabase type, call-site VC encoding in VCGen, driver integration, and E2E tests proving inter-procedural verification with Z3.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/lib.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/mir_converter.rs
@crates/analysis/tests/e2e_verification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ContractDatabase and call-site encoding in VCGen</name>
  <files>
    crates/analysis/src/contract_db.rs
    crates/analysis/src/lib.rs
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
  </files>
  <action>
**1. Create `crates/analysis/src/contract_db.rs`:**

Define a `ContractDatabase` that maps function names (String) to their contracts:

```rust
use std::collections::HashMap;
use crate::ir::{Contracts, SpecExpr};

/// Database of function contracts for inter-procedural verification.
///
/// When verifying a function `foo` that calls `bar`, the VCGen looks up
/// `bar`'s contracts here and encodes:
///   1. Assert bar's preconditions (substituting actual arguments for formals)
///   2. Havoc the return value (declare unconstrained)
///   3. Assume bar's postconditions (with `result` bound to the destination)
#[derive(Debug, Clone, Default)]
pub struct ContractDatabase {
    contracts: HashMap<String, FunctionSummary>,
}

#[derive(Debug, Clone)]
pub struct FunctionSummary {
    pub contracts: Contracts,
    /// Parameter names for argument substitution (e.g., ["_1", "_2"])
    pub param_names: Vec<String>,
    /// Parameter types for correct SMT encoding
    pub param_types: Vec<crate::ir::Ty>,
    /// Return type
    pub return_ty: crate::ir::Ty,
}
```

Provide methods:
- `new() -> Self` (empty database)
- `insert(name: String, summary: FunctionSummary)` to register a function
- `get(name: &str) -> Option<&FunctionSummary>` to look up callee contracts
- `contains(name: &str) -> bool` for quick existence check

**2. Update `crates/analysis/src/lib.rs`:**

Add `pub mod contract_db;` declaration.

**3. Update `crates/analysis/src/vcgen.rs` -- modify `generate_vcs` signature:**

Change `generate_vcs` to accept an optional `&ContractDatabase`:

```rust
pub fn generate_vcs(func: &Function, contract_db: Option<&ContractDatabase>) -> FunctionVCs {
```

For backward compatibility, all existing callers pass `None` and behavior is identical. The `contract_db` parameter is `Option` so unit tests and callers that don't need inter-procedural reasoning can omit it.

**4. Update `enumerate_paths` / `traverse_block` to record call information:**

In the `Terminator::Call` branch of `traverse_block` (currently at line ~407-418), instead of just ignoring the call, record it in the path state:

Add a `CallSiteInfo` struct:
```rust
#[derive(Debug, Clone)]
struct CallSiteInfo {
    callee_name: String,
    args: Vec<Operand>,
    destination: Place,
    block_idx: usize,
    /// Assignments before this call in the current path
    prior_assignments: Vec<PathAssignment>,
    /// Path condition at call point
    path_condition: Option<Term>,
}
```

Add `call_sites: Vec<CallSiteInfo>` to `PathState` and `CfgPath`.

In the `Terminator::Call` handler, push a `CallSiteInfo` with the function name, args, and destination, then continue traversal to target block as before. The callee function name from IR is in `func` field of `Terminator::Call` -- it may contain debug formatting from MIR (e.g., `const add`). Normalize by stripping common prefixes: `const ` prefix and path qualifiers to get the bare function name for lookup. Add a helper `fn normalize_callee_name(raw: &str) -> String` that:
- Strips `const ` prefix
- Takes the last path segment (after `::`)
- Trims whitespace

**5. Add `generate_call_site_vcs` function:**

This is the key encoding. For each call site found in path traversal:

```rust
fn generate_call_site_vcs(
    func: &Function,
    contract_db: &ContractDatabase,
    datatype_declarations: &[Command],
    declarations: &[Command],
    paths: &[CfgPath],
) -> Vec<VerificationCondition> {
```

For each call site in each path:
1. Look up callee name in `contract_db.get(normalized_name)`. If not found, skip (treat as opaque -- backward compatible).
2. If callee has preconditions:
   a. Build argument substitution map: callee param `_1` -> caller's actual argument at position 0, etc.
   b. For each precondition, parse with `parse_spec`, then apply argument substitution on the resulting Term (replace callee parameter constants with caller argument terms).
   c. Create a VC script: base declarations + encode prior assignments along the path + assume caller's preconditions + assert NOT(callee's precondition with substitution). If SAT, the caller violates the callee's precondition.
   d. Description: `"{caller}: call to {callee} satisfies precondition {idx} ({spec_raw})"`.
3. If callee has postconditions:
   - These are ASSUMED (not checked) during the caller's postcondition verification. Encode them by adding assertions in `generate_contract_vcs` after encoding call site assignments.

**6. Integrate call postcondition assumptions into `generate_contract_vcs`:**

After encoding path assignments, before asserting the caller's postconditions, for each call site on each path:
- If callee found in contract_db and has postconditions:
  - Substitute `result` with the call's destination variable in the postcondition term
  - Substitute callee param names with actual arguments
  - Assert the postcondition as an assumption (positive assertion, not negated)

This means: when checking the caller's postcondition, Z3 can use the callee's postcondition as a known fact.

**7. Wire it into `generate_vcs`:**

After existing VC generation, if `contract_db` is `Some`:
```rust
if let Some(db) = contract_db {
    let mut call_vcs = generate_call_site_vcs(func, db, &datatype_declarations, &declarations, &paths);
    conditions.append(&mut call_vcs);
}
```

**Important implementation notes:**
- Term substitution: Create a helper `fn substitute_term(term: &Term, substitutions: &HashMap<String, Term>) -> Term` that recursively walks a Term tree and replaces `Term::Const(name)` with the mapped term if present. This is essential for mapping callee parameter names to actual argument terms.
- When encoding a call site for postcondition assumption, the callee's `result` in its postcondition maps to the caller's destination variable for that call.
- Preserve all existing behavior when `contract_db` is `None` -- every existing test must still pass.
- Use `tracing::debug!` to log when a call site is encoded modularly vs. treated as opaque.
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis` -- all existing tests (98+ unit tests) must pass unchanged.
Run `cargo clippy -p rust-fv-analysis -- -D warnings` -- zero warnings.
Verify that `generate_vcs(&func, None)` produces identical results to before for all existing test functions.
  </verify>
  <done>
ContractDatabase type exists with insert/get/contains. VCGen accepts optional ContractDatabase. Call sites in path traversal record CallSiteInfo. generate_call_site_vcs creates precondition VCs for call sites. Postcondition assumptions wired into generate_contract_vcs. All existing tests pass with None contract_db.
  </done>
</task>

<task type="auto">
  <name>Task 2: Driver integration and E2E inter-procedural tests</name>
  <files>
    crates/driver/src/callbacks.rs
    crates/analysis/tests/interprocedural_tests.rs
  </files>
  <action>
**1. Update `crates/driver/src/callbacks.rs`:**

In the `after_analysis` callback, after building `contracts_map`, construct a `ContractDatabase`:

```rust
use rust_fv_analysis::contract_db::{ContractDatabase, FunctionSummary};

// After extract_contracts(tcx):
let mut contract_db = ContractDatabase::new();
for (&local_def_id, contracts) in &contracts_map {
    let def_id = local_def_id.to_def_id();
    let name = tcx.def_path_str(def_id);
    let mir = tcx.optimized_mir(def_id);

    // Extract param names and types from MIR
    let params: Vec<_> = mir.args_iter().map(|local| {
        let decl = &mir.local_decls[local];
        (format!("_{}", local.as_usize()), mir_converter::convert_ty_pub(decl.ty))
    }).collect();

    let return_ty = mir_converter::convert_ty_pub(mir.local_decls[rustc_middle::mir::Local::ZERO].ty);

    contract_db.insert(name, FunctionSummary {
        contracts: contracts.clone(),
        param_names: params.iter().map(|(n, _)| n.clone()).collect(),
        param_types: params.iter().map(|(_, t)| t.clone()).collect(),
        return_ty,
    });
}
```

Note: `convert_ty` in `mir_converter.rs` is currently `fn convert_ty(ty: ty::Ty<'_>) -> ir::Ty` (private). Make it `pub` or add a `pub fn convert_ty_pub(ty: ty::Ty<'_>) -> ir::Ty` wrapper so callbacks.rs can use it. Update `crates/driver/src/mir_converter.rs` to make `convert_ty` public.

Then pass `Some(&contract_db)` to `generate_vcs`:

```rust
let func_vcs = rust_fv_analysis::vcgen::generate_vcs(&ir_func, Some(&contract_db));
```

**2. Create `crates/analysis/tests/interprocedural_tests.rs`:**

Build comprehensive E2E tests following the established pattern from `e2e_verification.rs`. Each test constructs IR `Function` structs manually, builds a `ContractDatabase`, and verifies with Z3.

Test cases (at minimum):

a. **test_call_site_precondition_satisfied**: Caller `foo(x: i32)` with `#[requires(x > 0)]` calls `bar(y: i32)` with `#[requires(y > 0)]`, passing `x` as argument. Since foo's precondition implies bar's, verification succeeds (all VCs UNSAT).

b. **test_call_site_precondition_violated**: Caller `baz(x: i32)` with `#[requires(x > 0)]` calls `bar(y: i32)` with `#[requires(y > 10)]`, passing `x`. Since `x > 0` does NOT imply `x > 10`, the precondition VC should be SAT (violation detected).

c. **test_call_site_postcondition_assumed**: Caller `compute(a: i32, b: i32)` calls `add(x: i32, y: i32)` which has `#[ensures(result == x + y)]`. Caller has `#[ensures(result == a + b)]` and assigns the return of add to `_0`. With postcondition assumption, the caller's postcondition should verify.

d. **test_call_site_postcondition_not_assumed_without_db**: Same as (c) but pass `None` for contract_db. The caller's postcondition should NOT verify (destination is unconstrained without the callee's postcondition).

e. **test_call_chain_no_blowup**: Build a chain of 5+ functions, each calling the next, with simple contracts. All should verify. This demonstrates that modular verification scales linearly.

f. **test_call_without_contracts_treated_as_opaque**: Caller calls a function not in the ContractDatabase. The call destination remains unconstrained (existing behavior). No crash, no VC generated for the call site.

g. **test_precondition_violation_reports_callee_name**: When a precondition VC is SAT, the VC description includes the callee function name and the specific precondition string.

h. **test_multiple_preconditions_each_checked**: Callee has two preconditions. Each gets its own VC with a clear description.

For each test, construct IR Functions with appropriate basic blocks. The caller function should have a `Terminator::Call` pointing to the callee name. Build a `ContractDatabase` with callee entries. Run `generate_vcs` with `Some(&contract_db)` and check VC results with Z3.

Use the same `solver_or_skip()` and `script_to_smtlib()` helpers established in existing test files.

Also include unit tests (without Z3):
- `test_normalize_callee_name` tests for the name normalization helper
- `test_substitute_term` tests for term substitution
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis` -- all tests pass (existing + new interprocedural tests).
Run `cargo test -p rust-fv-driver` -- driver tests pass (if any).
Run `cargo clippy --workspace -- -D warnings` -- zero warnings across all crates.
Run `cargo test --workspace` -- all 399+ existing tests plus new tests pass.
  </verify>
  <done>
Driver constructs ContractDatabase from HIR contracts and passes to generate_vcs. At least 8 E2E tests verify inter-procedural reasoning: precondition satisfied, precondition violated, postcondition assumed, chain scalability, opaque calls, error reporting. All workspace tests pass. Zero clippy warnings.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures (all 399+ existing + new tests)
2. `cargo clippy --workspace -- -D warnings` produces zero warnings
3. E2E test `test_call_site_precondition_satisfied` returns UNSAT (verified)
4. E2E test `test_call_site_precondition_violated` returns SAT (violation found)
5. E2E test `test_call_site_postcondition_assumed` returns UNSAT (verified with assumption)
6. E2E test `test_call_chain_no_blowup` completes in under 5 seconds for 5+ functions
7. E2E test `test_call_without_contracts_treated_as_opaque` matches existing behavior
8. `generate_vcs(&func, None)` produces identical output to pre-change behavior for all existing test functions
</verification>

<success_criteria>
- ContractDatabase maps function names to contracts with param info
- Call sites encode assert-precondition / havoc-return / assume-postcondition
- Precondition violations at call sites are detected and reported with callee name
- Postcondition assumptions enable compositional verification
- All existing tests pass unchanged (backward compatibility)
- At least 8 new E2E inter-procedural tests pass with Z3
</success_criteria>

<output>
After completion, create `.planning/phases/03-modular-verification/03-01-SUMMARY.md`
</output>

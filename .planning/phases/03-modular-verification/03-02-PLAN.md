---
phase: 03-modular-verification
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/ir.rs
  - crates/analysis/src/ownership.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/tests/ownership_tests.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/mir_converter.rs
autonomous: true

must_haves:
  truths:
    - "A moved value used after a function call produces a verification error"
    - "An immutable borrow passed to a function is guaranteed unchanged after the call returns"
    - "Ownership constraints are derived from Rust's type system (move vs borrow vs mut-borrow) without additional user annotations"
    - "Mutable borrows have their target havoced after the call (callee may modify)"
    - "Ownership reasoning integrates with call-site encoding from 03-01 to strengthen postcondition assumptions"
  artifacts:
    - path: "crates/analysis/src/ownership.rs"
      provides: "Ownership analysis: classify arguments as moved/borrowed/mut-borrowed and generate constraints"
      min_lines: 80
    - path: "crates/analysis/tests/ownership_tests.rs"
      provides: "E2E tests for ownership-aware verification with Z3"
      min_lines: 200
  key_links:
    - from: "crates/analysis/src/ownership.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Reads Ty::Ref mutability and Operand::Move/Copy to classify arguments"
      pattern: "Ty::Ref|Operand::Move|Operand::Copy"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/ownership.rs"
      via: "Call-site encoding uses ownership classification to add/omit constraints"
      pattern: "classify_argument|OwnershipKind"
---

<objective>
Add ownership-aware reasoning to inter-procedural verification so the verifier leverages Rust's move/borrow semantics to strengthen verification without additional annotations.

Purpose: Rust's ownership system provides free information: moved values cannot be used after the call, immutable borrows cannot be mutated by the callee, and mutable borrows may be changed. Encoding these constraints tightens the verification conditions and catches more bugs without requiring users to write additional specs.

Output: Ownership analysis module, integration with call-site encoding, and E2E tests proving ownership-aware verification.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-modular-verification/03-01-SUMMARY.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/contract_db.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/mir_converter.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ownership classification and constraint generation</name>
  <files>
    crates/analysis/src/ownership.rs
    crates/analysis/src/lib.rs
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
  </files>
  <action>
**1. Create `crates/analysis/src/ownership.rs`:**

Define ownership classification for function call arguments:

```rust
use crate::ir::{Operand, Ty, Mutability, Place};

/// How an argument is passed to a function call.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OwnershipKind {
    /// Value is moved into the callee (T, not behind a reference).
    /// After the call, the original variable is consumed -- cannot be used.
    Moved,
    /// Value is passed by shared reference (&T).
    /// After the call, the original value is guaranteed unchanged.
    SharedBorrow,
    /// Value is passed by mutable reference (&mut T).
    /// After the call, the original value may have been modified (havoced).
    MutableBorrow,
    /// Value is copied (Copy types like i32, bool).
    /// After the call, the original value is unchanged (it's a copy).
    Copied,
}
```

Implement `classify_argument(operand: &Operand, param_ty: &Ty) -> OwnershipKind`:

- If `param_ty` is `Ty::Ref(_, Mutability::Shared)` -> `SharedBorrow`
- If `param_ty` is `Ty::Ref(_, Mutability::Mutable)` -> `MutableBorrow`
- If operand is `Operand::Copy(_)` -> `Copied`
- If operand is `Operand::Move(_)` -> `Moved`
- Default fallback: `Copied` (conservative, safe)

Implement `fn generate_ownership_constraints(kind: OwnershipKind, arg_operand: &Operand, destination: &Place) -> Vec<OwnershipConstraint>`:

```rust
#[derive(Debug, Clone)]
pub enum OwnershipConstraint {
    /// The argument's value is unchanged after the call.
    /// Encoded as: (assert (= arg_after_call arg_before_call))
    ValuePreserved { variable: String },
    /// The argument's value is consumed (moved). Any subsequent use is invalid.
    /// For now, we don't generate a constraint here -- the Rust borrow checker
    /// already prevents this. But we log it for tracing purposes.
    ValueConsumed { variable: String },
    /// The argument's target may be modified (havoced).
    /// Encoded by NOT adding a preservation constraint -- the destination
    /// of the dereferenced mutable borrow remains unconstrained.
    ValueMayChange { variable: String },
}
```

Rules:
- `Copied`: emit `ValuePreserved` (copy semantics -- value unchanged)
- `SharedBorrow`: emit `ValuePreserved` (immutable borrow -- value unchanged)
- `MutableBorrow`: emit `ValueMayChange` (mutable borrow -- value may change)
- `Moved`: emit `ValueConsumed` (value consumed -- borrow checker handles this)

**2. Update `crates/analysis/src/lib.rs`:**

Add `pub mod ownership;` declaration.

**3. Update `crates/analysis/src/vcgen.rs` -- integrate ownership into call-site encoding:**

In the call-site encoding logic (from 03-01), after encoding callee postcondition assumptions:

a. For each argument at the call site, classify its ownership using `classify_argument`.
b. For `SharedBorrow` and `Copied` arguments:
   - Extract the source variable name from the operand
   - After the call, assert that the variable's value equals its value before the call
   - This is encoded as: `(assert (= var var_pre))` where `var_pre` is the pre-call snapshot
   - To create the pre-call snapshot, declare a fresh constant `{var}_pre_call_{block}` and assert it equals the variable before the call, then after the call assert the variable equals this snapshot
   - Simpler approach: since we do path-sensitive encoding and the call doesn't assign to the argument variable, the variable's value is already preserved in the path assignments. The key insight is: for `SharedBorrow`, even if the callee's postcondition mentions the parameter, we do NOT havoc the caller's original variable. Only the callee's own local is affected.

   **Practical encoding:** When assuming callee postconditions at the call site, for `SharedBorrow` arguments, add an extra assertion: `(assert (= callee_param_substituted caller_arg_value))`. This encodes that the shared-borrow argument was not modified. For `MutableBorrow`, do NOT add this constraint -- the mutable borrow means the callee may have changed the referent.

c. For `MutableBorrow` arguments:
   - The referent (the value behind `&mut`) is havoced after the call
   - If the callee has no postcondition about the `&mut` parameter, the referent becomes unconstrained
   - If the callee has a postcondition mentioning the parameter, that postcondition is assumed (already handled by 03-01)

d. For `Moved` arguments:
   - Log via `tracing::debug!` that the argument is moved
   - No SMT constraint needed -- Rust's borrow checker prevents use-after-move at compile time
   - The value is simply not available after the call (already the case since we don't re-assert it)

**4. Optionally update `crates/analysis/src/ir.rs`:**

If the current `Terminator::Call` does not carry enough type information about arguments, we may need to enrich `CallSiteInfo` (from 03-01) with param types from the contract database. This is likely already available via `FunctionSummary::param_types` in the ContractDatabase.
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis` -- all tests pass (existing + from 03-01).
Run `cargo clippy -p rust-fv-analysis -- -D warnings` -- zero warnings.
Unit tests for `classify_argument` cover all four OwnershipKind variants.
  </verify>
  <done>
OwnershipKind enum classifies move/copy/shared-borrow/mutable-borrow. classify_argument derives ownership from operand and parameter type. Call-site encoding adds value-preservation constraints for shared borrows and copies. Mutable borrows leave referent unconstrained. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Driver integration and E2E ownership tests</name>
  <files>
    crates/driver/src/callbacks.rs
    crates/driver/src/mir_converter.rs
    crates/analysis/tests/ownership_tests.rs
  </files>
  <action>
**1. Update `crates/driver/src/mir_converter.rs` if needed:**

Ensure `convert_ty` is accessible (should be `pub` from 03-01). Verify that `Ty::Ref(_, Mutability::Shared)` and `Ty::Ref(_, Mutability::Mutable)` are correctly produced for `&T` and `&mut T` parameters. The existing `convert_ty` already handles these cases (line ~315-320 in mir_converter.rs).

Verify that `convert_operand` correctly produces `Operand::Copy` vs `Operand::Move` for borrow-vs-move semantics. The current implementation maps `mir::Operand::Copy` to `Operand::Copy` and `mir::Operand::Move` to `Operand::Move` (line ~230-232), which is correct.

**2. Update `crates/driver/src/callbacks.rs`:**

No changes needed beyond 03-01 -- the ownership analysis is driven by the VCGen when it encounters call sites and examines argument types from the ContractDatabase's FunctionSummary. The driver already populates param_types in 03-01.

**3. Create `crates/analysis/tests/ownership_tests.rs`:**

Build E2E tests exercising ownership-aware verification. Each test constructs IR manually and verifies with Z3.

Test cases:

a. **test_shared_borrow_preserved**: Function `caller(x: &i32)` calls `reader(y: &i32)` (shared borrow). After the call, `*x` retains its pre-call value. Postcondition `result == *x` should verify because `x` is unchanged.

   Build IR: parameter `_1` with `Ty::Ref(Box::new(Ty::Int(IntTy::I32)), Mutability::Shared)`. Call `reader` with `Operand::Copy(Place::local("_1"))`. Assign return of reader to `_3`. Then assign `_0` = deref of `_1`. Postcondition checks `result == _1_deref` or similar.

   **Simpler variant**: Function `caller(x: i32)` calls `identity(y: i32)` with `Operand::Copy`. After the call, use `x` in a computation. Since Copy semantics, `x` is preserved. Postcondition references `x`.

b. **test_mutable_borrow_havoced**: Function `caller(x: &mut i32)` calls `mutator(y: &mut i32)` (mutable borrow). After the call, `*x` is unconstrained (havoced). Postcondition `result == old(*x)` should FAIL because the mutable borrow means the callee may have changed `*x`.

c. **test_copy_semantics_preserved**: Function `caller(a: i32, b: i32)` calls `compute(x: i32)` with `Operand::Copy(a)`. After the call, `a` still has its original value. Postcondition `result == a + b` where result uses `a` after the call should verify.

d. **test_move_semantics_value_consumed**: Function `caller(s: String)` moves `s` into callee. After the call, `s` should not be used (Rust borrow checker handles this). The test verifies that no crash occurs and the call is processed correctly even for moved values.

e. **test_ownership_classification_unit**: Unit tests for `classify_argument`:
   - `Operand::Copy + Ty::Int(I32)` -> `Copied`
   - `Operand::Move + Ty::Int(I32)` -> `Moved` (even though i32 is Copy in Rust, the IR says Move)
   - `Operand::Copy + Ty::Ref(_, Shared)` -> `SharedBorrow`
   - `Operand::Copy + Ty::Ref(_, Mutable)` -> `MutableBorrow`

f. **test_mixed_ownership_call**: Function calls callee with mixed argument types: one copied, one shared-borrowed, one mutable-borrowed. Verify that only the mutable-borrow argument is havoced.

g. **test_ownership_with_postcondition_assumption**: Caller calls `reader(x: &i32)` which has `#[ensures(result > 0)]`. After the call, caller's postcondition uses both the unchanged `x` (shared borrow preserved) and the callee's return (postcondition assumed). Both should be available to the verifier.

h. **test_no_ownership_without_contract_db**: When `contract_db` is `None`, ownership constraints are not generated (backward compatible). Same test as (a) but with `None` -- postcondition may or may not verify depending on path encoding, but no crash.
  </action>
  <verify>
Run `cargo test -p rust-fv-analysis` -- all tests pass (existing + 03-01 + ownership tests).
Run `cargo clippy --workspace -- -D warnings` -- zero warnings across all crates.
Run `cargo test --workspace` -- all tests pass.
Specifically verify:
- `test_shared_borrow_preserved` returns UNSAT (verified)
- `test_mutable_borrow_havoced` returns SAT (violation detected -- value was havoced)
- `test_copy_semantics_preserved` returns UNSAT (verified)
  </verify>
  <done>
At least 8 E2E tests verify ownership-aware verification. Shared borrows and copies are provably preserved after function calls. Mutable borrows are correctly havoced. Move semantics handled without crash. All workspace tests pass. Zero clippy warnings. Phase 3 success criteria met: modular verification with ownership reasoning works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures
2. `cargo clippy --workspace -- -D warnings` produces zero warnings
3. `classify_argument` correctly classifies Copy, Move, SharedBorrow, MutableBorrow
4. Shared borrow arguments are provably unchanged after calls (E2E test with Z3)
5. Mutable borrow arguments are correctly havoced after calls (E2E test with Z3)
6. Copy-typed arguments retain value after calls (E2E test with Z3)
7. Ownership reasoning composes with postcondition assumptions from 03-01
8. No ownership constraints generated when contract_db is None (backward compat)
</verification>

<success_criteria>
- OwnershipKind enum with Moved/Copied/SharedBorrow/MutableBorrow variants
- classify_argument derives ownership from IR operand and parameter type
- SharedBorrow and Copied arguments have value-preservation constraints after calls
- MutableBorrow arguments are havoced (unconstrained) after calls
- Ownership integrates with inter-procedural call encoding from 03-01
- All existing tests pass unchanged
- At least 8 new ownership E2E tests pass with Z3
- Phase 3 Success Criteria 4 met: "verifier leverages Rust's ownership guarantees"
</success_criteria>

<output>
After completion, create `.planning/phases/03-modular-verification/03-02-SUMMARY.md`
</output>

---
phase: 18-bv2int-optimization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/bv2int.rs
  - crates/analysis/src/encode_sort.rs
  - crates/analysis/src/encode_term.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/ir.rs
autonomous: true
requirements:
  - PERF-05

must_haves:
  truths:
    - "EncodingMode::Integer produces Int sorts instead of BitVec sorts for integer types"
    - "Functions with bitwise operations (& | ^ << >>) are rejected as ineligible for bv2int"
    - "Functions with only arithmetic and comparisons are accepted as bv2int-eligible"
    - "Integer encoding includes wrapping overflow guards via modulo constraints"
    - "Signed types use signed bv2int conversion, unsigned types use unsigned bv2nat"
    - "#[fv::no_bv2int] attribute detected and respected"
  artifacts:
    - path: "crates/analysis/src/bv2int.rs"
      provides: "EncodingMode enum, applicability analysis, integer encoding functions"
      min_lines: 150
  key_links:
    - from: "crates/analysis/src/bv2int.rs"
      to: "crates/analysis/src/ir.rs"
      via: "BinOp matching for eligibility check"
      pattern: "BinOp::BitAnd|BitOr|BitXor|Shl|Shr"
    - from: "crates/analysis/src/bv2int.rs"
      to: "crates/analysis/src/encode_sort.rs"
      via: "encode_type_with_mode for Int sort selection"
      pattern: "EncodingMode::Integer.*Sort::Int"
---

<objective>
Implement the core bv2int encoding infrastructure: EncodingMode enum, conservative applicability analysis that rejects functions with bitwise operations, and integer encoding with proper overflow guards.

Purpose: Provides the foundational encoding layer that translates bitvector SMT terms to integer arithmetic terms for eligible functions, enabling significant speedup on arithmetic-heavy proofs.

Output: bv2int.rs module with EncodingMode, eligibility analysis, integer encoding functions; extended encode_sort.rs with mode-aware type encoding.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-bv2int-optimization/18-RESEARCH.md
@.planning/phases/18-bv2int-optimization/18-CONTEXT.md
@crates/analysis/src/encode_term.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/lib.rs
</context>

<feature>
  <name>bv2int core encoding infrastructure</name>
  <files>crates/analysis/src/bv2int.rs, crates/analysis/src/encode_sort.rs, crates/analysis/src/encode_term.rs, crates/analysis/src/lib.rs, crates/analysis/src/ir.rs</files>
  <behavior>
    EncodingMode enum:
    - EncodingMode::Bitvector (default) -> existing BitVec encoding unchanged
    - EncodingMode::Integer -> Int sorts, integer arithmetic operators

    Applicability analysis (is_bv2int_eligible):
    - Function with Add, Sub, Mul, Div, Rem, comparisons -> Ok(())
    - Function with BitAnd -> Err(IneligibilityReason::BitwiseOp("&amp;", source_location))
    - Function with BitOr -> Err(IneligibilityReason::BitwiseOp("|", source_location))
    - Function with BitXor -> Err(IneligibilityReason::BitwiseOp("^", source_location))
    - Function with Shl -> Err(IneligibilityReason::ShiftOp("&lt;&lt;", source_location))
    - Function with Shr -> Err(IneligibilityReason::ShiftOp(">>", source_location))
    - Function with #[fv::no_bv2int] attribute -> Err(IneligibilityReason::OptOut)
    - Entire function rejected if ANY bitwise/shift op present (conservative, per user decision)

    Integer encoding (encode_type_with_mode):
    - Ty::Int(_) with EncodingMode::Integer -> Sort::Int
    - Ty::Uint(_) with EncodingMode::Integer -> Sort::Int
    - All other types unchanged regardless of mode

    Integer binop encoding (encode_binop_with_mode):
    - Add with Integer mode -> IntAdd with wrapping modulo guard
    - Sub with Integer mode -> IntSub with wrapping modulo guard
    - Mul with Integer mode -> IntMul with wrapping modulo guard
    - Div with Integer mode -> IntDiv (integer division)
    - Rem with Integer mode -> IntMod
    - Comparisons with Integer mode -> standard Int comparisons (no bitvec signedness needed)
    - Wrapping guard for unsigned: (mod result (2^N)) where N = bit width
    - Wrapping guard for signed: two's complement range enforcement via (ite (>= result 2^(N-1)) (- result 2^N) result)

    IneligibilityReason:
    - BitwiseOp(op_symbol, location_desc) -> "Function uses bitwise operation `{op}` at {location} -- bv2int not applicable"
    - ShiftOp(op_symbol, location_desc) -> "Function uses shift operation `{op}` at {location} -- bv2int not applicable"
    - OptOut -> "Function has #[fv::no_bv2int] attribute"
  </behavior>
  <implementation>
    1. Create crates/analysis/src/bv2int.rs with:
       - EncodingMode enum (Bitvector, Integer) with Debug, Clone, Copy, PartialEq, Eq, Default(Bitvector)
       - IneligibilityReason enum with Display impl providing actionable messages
       - is_bv2int_eligible(func: &amp;Function) -> Result&lt;(), IneligibilityReason&gt;
         - Walk all basic blocks and statements
         - Check for BinOp::BitAnd/BitOr/BitXor/Shl/Shr -> reject with reason
         - Check function attributes for no_bv2int
       - encode_type_with_mode(ty: &amp;Ty, mode: EncodingMode) -> Sort
         - Delegates to existing encode_type for Bitvector mode
         - Returns Sort::Int for integer types in Integer mode
       - encode_binop_with_mode(op, lhs, rhs, ty, mode) -> Term
         - Delegates to existing encode_binop for Bitvector mode
         - Uses IntAdd/IntSub/IntMul/IntDiv for Integer mode with overflow guards
       - wrap_overflow(result: Term, ty: &amp;Ty) -> Term
         - Applies modulo constraint for wrapping arithmetic per Rust RFC 0560
         - unsigned: (mod result 2^N)
         - signed: two's complement range [-2^(N-1), 2^(N-1))

    2. Register module in crates/analysis/src/lib.rs

    3. Add no_bv2int attribute detection in IR (small extension to Function attributes or a helper function)
  </implementation>
</feature>

<verification>
- `cargo test -p rust-fv-analysis --lib bv2int` passes all tests
- `cargo clippy -p rust-fv-analysis -- -D warnings` clean
- `cargo fmt --check -p rust-fv-analysis` clean
- Tests cover: eligibility acceptance, each bitwise rejection, opt-out attribute, Int sort encoding, all arithmetic operators, overflow wrapping for signed and unsigned
</verification>

<success_criteria>
- EncodingMode::Integer produces Sort::Int for integer types
- All 5 bitwise operations correctly rejected with actionable error messages
- Arithmetic-only functions accepted as eligible
- Wrapping overflow guards produce correct modulo constraints
- Signed/unsigned distinction handled correctly
- At least 15 unit tests covering all behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/18-bv2int-optimization/18-01-SUMMARY.md`
</output>

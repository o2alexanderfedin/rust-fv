---
phase: 18-bv2int-optimization
plan: 02
type: tdd
wave: 2
depends_on:
  - 18-01
files_modified:
  - crates/analysis/src/differential.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/vcgen.rs
  - crates/driver/src/cache.rs
autonomous: true
requirements:
  - PERF-06

must_haves:
  truths:
    - "Differential testing runs both bitvector and bv2int encodings and compares SAT/UNSAT results"
    - "Divergence between encodings reported as error with counterexample"
    - "Equivalence results cached per function content hash in VcCache"
    - "Timing comparison always shown: bitvector time, bv2int time, speedup factor"
    - "Cached equivalence result reused when function hash unchanged"
    - "Re-test triggered when function body changes (mir_hash differs)"
  artifacts:
    - path: "crates/analysis/src/differential.rs"
      provides: "EquivalenceResult struct, test_encoding_equivalence function"
      min_lines: 100
    - path: "crates/driver/src/cache.rs"
      provides: "Extended CacheEntry with bv2int equivalence fields"
      contains: "bv2int_equiv_tested"
  key_links:
    - from: "crates/analysis/src/differential.rs"
      to: "crates/analysis/src/bv2int.rs"
      via: "Uses EncodingMode to run both encodings"
      pattern: "EncodingMode::Bitvector.*EncodingMode::Integer"
    - from: "crates/analysis/src/differential.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "Calls VC generation with different encoding modes"
      pattern: "generate_vcs"
    - from: "crates/driver/src/cache.rs"
      to: "crates/analysis/src/differential.rs"
      via: "Stores/retrieves EquivalenceResult"
      pattern: "bv2int_equiv_tested"
---

<objective>
Implement the differential testing engine that proves equivalence between bitvector and bv2int encodings, with result caching integrated into Phase 14's VcCache infrastructure.

Purpose: Ensures soundness of the bv2int optimization by automatically verifying that both encodings produce identical verification results. Caches results to avoid redundant testing.

Output: differential.rs module with equivalence testing; extended CacheEntry with bv2int fields; VCGen mode-awareness.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-bv2int-optimization/18-RESEARCH.md
@.planning/phases/18-bv2int-optimization/18-CONTEXT.md
@.planning/phases/18-bv2int-optimization/18-01-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/bv2int.rs
@crates/driver/src/cache.rs
</context>

<feature>
  <name>Differential testing and equivalence caching</name>
  <files>crates/analysis/src/differential.rs, crates/analysis/src/lib.rs, crates/analysis/src/vcgen.rs, crates/driver/src/cache.rs</files>
  <behavior>
    EquivalenceResult struct:
    - equivalent: bool
    - bitvec_time_ms: u64
    - bv2int_time_ms: u64
    - speedup_factor: f64
    - counterexample: Option&lt;String&gt; (model description if divergent)

    test_encoding_equivalence(func, bv_vcs, int_vcs, solver):
    - Run solver on bitvector VCs, time it
    - Run solver on integer VCs, time it
    - Compare: both Unsat -> equivalent
    - Compare: both Sat with agreeing models -> equivalent
    - Compare: divergent -> not equivalent, extract counterexample from SAT side
    - Return EquivalenceResult with timing and outcome

    CacheEntry extension:
    - bv2int_equiv_tested: bool (default false for backward compat via serde default)
    - bv2int_bitvec_time_ms: Option&lt;u64&gt;
    - bv2int_int_time_ms: Option&lt;u64&gt;
    - bv2int_speedup: Option&lt;f64&gt;
    - Equivalence result invalidated when mir_hash changes (existing mechanism)

    VCGen mode-awareness:
    - generate_vcs gains optional EncodingMode parameter (default Bitvector for backward compat)
    - When Integer mode: use encode_type_with_mode and encode_binop_with_mode from bv2int.rs
    - Set SMT logic to QF_LIA (or QF_NIA for multiplication) instead of QF_BV in Integer mode

    format_equivalence_result(result: &amp;EquivalenceResult, func_name: &amp;str) -> String:
    - Equivalent: "bitvector: {X}ms, bv2int: {Y}ms ({Z:.1}x faster)" or "({Z:.1}x slower)"
    - Divergent: "ENCODING DIVERGENCE in {func}: bitvector={SAT/UNSAT}, bv2int={SAT/UNSAT}. Counterexample: {model}"
  </behavior>
  <implementation>
    1. Extend CacheEntry in crates/driver/src/cache.rs:
       - Add bv2int_equiv_tested, bv2int_bitvec_time_ms, bv2int_int_time_ms, bv2int_speedup fields
       - All with #[serde(default)] for backward compatibility
       - Add methods: store_equivalence_result, get_equivalence_result

    2. Create crates/analysis/src/differential.rs:
       - EquivalenceResult struct
       - test_encoding_equivalence function comparing VC results from both modes
       - format_equivalence_result for human-readable output
       - Divergence detection with counterexample extraction

    3. Extend VCGen in crates/analysis/src/vcgen.rs:
       - Add generate_vcs_with_mode(func, contract_db, mode) that threads EncodingMode through encoding calls
       - Existing generate_vcs unchanged (always Bitvector for backward compat)
       - Select SMT logic based on mode (QF_BV vs QF_LIA/QF_NIA)

    4. Register differential module in crates/analysis/src/lib.rs
  </implementation>
</feature>

<verification>
- `cargo test -p rust-fv-analysis --lib differential` passes all tests
- `cargo test -p rust-fv-driver --lib cache` passes (including new bv2int cache fields)
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` clean
- `cargo fmt --check` clean
- Tests cover: equivalence detection (both Unsat), divergence detection, timing capture, cache store/retrieve, cache invalidation on hash change, backward compatibility (old cache entries without bv2int fields)
</verification>

<success_criteria>
- Differential testing correctly identifies equivalent and divergent encodings
- Divergence reported as error with counterexample details
- Timing always captured and formatted as "bitvector: Xms, bv2int: Yms (Zx faster/slower)"
- Cache stores and retrieves equivalence results
- Old cache entries without bv2int fields load correctly (serde defaults)
- VCGen supports both Bitvector and Integer encoding modes
- At least 12 unit tests covering all behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/18-bv2int-optimization/18-02-SUMMARY.md`
</output>

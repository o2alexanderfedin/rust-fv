---
phase: 35-opaque-callee-diagnostics
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/vcgen.rs
  - crates/driver/src/diagnostics.rs
  - crates/driver/src/callbacks.rs
autonomous: true
requirements:
  - OPAQUE-01
  - OPAQUE-02

must_haves:
  truths:
    - "cargo verify emits a V060 warning when a verified function calls a callee with no #[requires]/#[ensures] contract"
    - "cargo verify emits a V061 error when an uncontracted callee is called from within an unsafe block or unsafe fn"
    - "The silent tracing::debug!() + continue at vcgen.rs:2375 is replaced — uncontracted callees produce VcKind::OpaqueCallee or VcKind::OpaqueCalleeUnsafe VCs"
    - "cargo test (unit) passes: OpaqueCallee routes to warning severity, OpaqueCalleeUnsafe routes to error severity in diagnostics.rs"
  artifacts:
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::OpaqueCallee and VcKind::OpaqueCalleeUnsafe variants; generate_call_site_vcs replaces None-arm with always-SAT diagnostic VC"
      contains: "OpaqueCallee"
    - path: "crates/driver/src/diagnostics.rs"
      provides: "vc_kind_description entries + suggest_fix entries for OpaqueCallee/OpaqueCalleeUnsafe; severity dispatch routes OpaqueCallee to Warning, OpaqueCalleeUnsafe to Error"
      contains: "OpaqueCallee"
    - path: "crates/driver/src/callbacks.rs"
      provides: "vc_kind_to_string entries for OpaqueCallee and OpaqueCalleeUnsafe; SAT result for OpaqueCallee treated as warning-diagnostic (not failure)"
      contains: "OpaqueCallee"
  key_links:
    - from: "crates/analysis/src/vcgen.rs generate_call_site_vcs None-arm"
      to: "VcKind::OpaqueCallee / VcKind::OpaqueCalleeUnsafe"
      via: "always-SAT VC emission with func.is_unsafe_fn or unsafe_blocks.block_index check"
      pattern: "OpaqueCallee"
    - from: "crates/driver/src/diagnostics.rs report_kind dispatch"
      to: "ReportKind::Warning for OpaqueCallee, ReportKind::Error for OpaqueCalleeUnsafe"
      via: "if condition on vc_kind"
      pattern: "OpaqueCallee.*Warning"
---

<objective>
Replace the silent `continue` at `vcgen.rs:2375` with always-SAT diagnostic VCs that surface when a verified function calls an uncontracted callee. Add two new `VcKind` variants (`OpaqueCallee` for safe context, `OpaqueCalleeUnsafe` for unsafe context) and wire severity dispatch across `vcgen.rs`, `diagnostics.rs`, and `callbacks.rs`.

Purpose: Closes OPAQUE-01 and OPAQUE-02 — users now receive actionable V060/V061 diagnostics instead of a silent skip.
Output: Two new VcKind variants, updated generate_call_site_vcs None-arm, severity routing in diagnostics.rs, vc_kind_to_string + SAT handling in callbacks.rs.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-opaque-callee-diagnostics/35-CONTEXT.md

<interfaces>
<!-- Key contracts extracted from codebase for executor reference. No exploration needed. -->

From crates/analysis/src/vcgen.rs (VcKind enum, ~line 86):
```rust
pub enum VcKind {
    Precondition,
    Postcondition,
    // ... existing variants ...
    DataRaceFreedom,
    // OpaqueCallee and OpaqueCalleeUnsafe go here (new)
    WeakMemoryCoherence,
    WeakMemoryRace,
    WeakMemoryAtomicity,
    AsyncStateInvariantSuspend,
    AsyncStateInvariantResume,
    AsyncPostcondition,
}
```

From crates/analysis/src/vcgen.rs (always-SAT VC pattern, ~line 4176):
```rust
// Diagnostic VC (always-SAT pattern) — replicate this in generate_call_site_vcs None-arm:
let mut script = rust_fv_smtlib::script::Script::new();
script.push(rust_fv_smtlib::command::Command::SetLogic("QF_BV".to_string()));
script.push(rust_fv_smtlib::command::Command::Assert(
    rust_fv_smtlib::term::Term::BoolLit(true),
));
script.push(rust_fv_smtlib::command::Command::CheckSat);

vcs.push(VerificationCondition {
    description: warning_description,
    script,
    location: VcLocation {
        function: func.name.clone(),
        block: 0,
        statement: 0,
        source_file: None,
        source_line: None,
        source_column: None,
        contract_text: Some("...".to_string()),
        vc_kind: VcKind::DataRaceFreedom,  // use OpaqueCallee or OpaqueCalleeUnsafe
    },
});
```

From crates/analysis/src/vcgen.rs (generate_call_site_vcs None-arm to replace, ~line 2370):
```rust
None => {
    tracing::debug!(
        caller = %func.name,
        callee = %call_site.callee_name,
        "Call to function without contracts -- treating as opaque"
    );
    continue;
}
```
Replace with: emit always-SAT VC with VcKind::OpaqueCallee or VcKind::OpaqueCalleeUnsafe based on unsafe context, then continue.

From crates/analysis/src/ir.rs (unsafe context fields):
```rust
pub struct UnsafeBlockInfo {
    pub block_index: usize,
    // ...
}

pub struct Function {
    pub unsafe_blocks: Vec<UnsafeBlockInfo>,
    pub is_unsafe_fn: bool,
    // ...
}
```

Unsafe escalation rule (from CONTEXT.md decisions):
- `func.is_unsafe_fn == true` → OpaqueCalleeUnsafe
- `func.unsafe_blocks.iter().any(|b| b.block_index == call_site.block_idx)` → OpaqueCalleeUnsafe
- Otherwise → OpaqueCallee

From crates/driver/src/diagnostics.rs (severity dispatch, ~line 78):
```rust
let report_kind = if failure.vc_kind == VcKind::MemorySafety
    || failure.vc_kind == VcKind::FloatingPointNaN
    || failure.vc_kind == VcKind::Deadlock
{
    ReportKind::Warning
} else {
    ReportKind::Error
};
```
Add `|| failure.vc_kind == VcKind::OpaqueCallee` to the Warning branch.
OpaqueCalleeUnsafe falls through to ReportKind::Error (no change needed for error branch).

From crates/driver/src/callbacks.rs (DataRaceFreedom SAT handling, ~line 700):
```rust
if !result.verified
    && result.vc_location.vc_kind != rust_fv_analysis::vcgen::VcKind::Postcondition
```
OpaqueCallee VCs return SAT from solver. SAT for OpaqueCallee = "diagnostic fired", NOT a verification failure.
Check how DataRaceFreedom always-SAT is handled — exclude OpaqueCallee from the failure push path similarly.
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add OpaqueCallee/OpaqueCalleeUnsafe VcKind variants + unit tests (RED phase)</name>
  <files>crates/analysis/src/vcgen.rs</files>
  <behavior>
    - Test 1: `VcKind::OpaqueCallee` exists and is distinct from all other variants (PartialEq check)
    - Test 2: `VcKind::OpaqueCalleeUnsafe` exists and is distinct from `VcKind::OpaqueCallee`
    - Test 3: `generate_call_site_vcs` for a func calling an uncontracted callee (contract_db has no entry for callee) produces at least one VC with `vc_kind == VcKind::OpaqueCallee`
    - Test 4: When `func.is_unsafe_fn == true` and callee has no contract, produces `VcKind::OpaqueCalleeUnsafe`
    - Test 5: When callee is in `func.unsafe_blocks` block index and callee has no contract, produces `VcKind::OpaqueCalleeUnsafe`
    - Test 6: When callee HAS a contract (Some(summary)), produces ZERO OpaqueCallee VCs (no spurious diagnostic for contracted callees)
  </behavior>
  <action>
    Write tests first (RED). Then implement:

    1. In `VcKind` enum (around line 145 after `AsyncPostcondition`), add:
       ```rust
       /// Uncontracted callee called from a verified function (safe context). Diagnostic warning V060.
       OpaqueCallee,
       /// Uncontracted callee called from unsafe context. Diagnostic error V061.
       OpaqueCalleeUnsafe,
       ```

    2. In `generate_call_site_vcs`, replace the `None => { tracing::debug!(...); continue; }` arm with:
       ```rust
       None => {
           tracing::debug!(
               caller = %func.name,
               callee = %call_site.callee_name,
               "Call to function without contracts -- emitting opaque callee diagnostic"
           );
           let is_unsafe_context = func.is_unsafe_fn
               || func.unsafe_blocks.iter().any(|b| b.block_index == call_site.block_idx);
           let vc_kind = if is_unsafe_context {
               VcKind::OpaqueCalleeUnsafe
           } else {
               VcKind::OpaqueCallee
           };
           let description = format!(
               "opaque callee: call to '{}' in '{}' has no verification contract — callee behavior is unverified",
               call_site.callee_name, func.name
           );
           let contract_text = format!(
               "Add #[requires] / #[ensures] to '{}' to enable cross-function verification",
               call_site.callee_name
           );
           let mut script = rust_fv_smtlib::script::Script::new();
           script.push(rust_fv_smtlib::command::Command::SetLogic("QF_BV".to_string()));
           script.push(rust_fv_smtlib::command::Command::Assert(
               rust_fv_smtlib::term::Term::BoolLit(true),
           ));
           script.push(rust_fv_smtlib::command::Command::CheckSat);
           vcs.push(VerificationCondition {
               description,
               script,
               location: VcLocation {
                   function: func.name.clone(),
                   block: call_site.block_idx,
                   statement: 0,
                   source_file: None,
                   source_line: None,
                   source_column: None,
                   contract_text: Some(contract_text),
                   vc_kind,
               },
           });
           continue;
       }
       ```

    Note: Deduplicate calls to the same callee within one function — use a `seen_opaque` HashSet keyed on `(call_site.callee_name.clone(), vc_kind)` to skip duplicate OpaqueCallee VCs for the same callee. This is the "nice-to-have dedup" from Claude's discretion in CONTEXT.md. Implement it: `let mut seen_opaque: std::collections::HashSet<String> = Default::default();` at the top of `generate_call_site_vcs`, then check before emitting.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis -- test_opaque_callee 2>&1 | tail -20</automated>
  </verify>
  <done>
    All 6 unit tests pass (RED→GREEN cycle complete). VcKind enum has OpaqueCallee and OpaqueCalleeUnsafe. generate_call_site_vcs None-arm emits always-SAT diagnostic VCs. No clippy warnings introduced.
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Wire severity dispatch in diagnostics.rs and vc_kind_to_string + SAT handling in callbacks.rs</name>
  <files>crates/driver/src/diagnostics.rs, crates/driver/src/callbacks.rs</files>
  <behavior>
    - Test 1 (diagnostics.rs): `vc_kind_description(&VcKind::OpaqueCallee)` returns `"opaque callee: unverified function call"`
    - Test 2 (diagnostics.rs): `vc_kind_description(&VcKind::OpaqueCalleeUnsafe)` returns `"opaque callee (unsafe): unverified function call in unsafe context"`
    - Test 3 (diagnostics.rs): `suggest_fix(&VcKind::OpaqueCallee)` returns `Some(...)` containing "Add #[requires]"
    - Test 4 (diagnostics.rs): `suggest_fix(&VcKind::OpaqueCalleeUnsafe)` returns `Some(...)` containing "Add #[requires]"
    - Test 5 (diagnostics.rs): severity dispatch routes `VcKind::OpaqueCallee` to `ReportKind::Warning` (matches the MemorySafety/FloatingPointNaN/Deadlock branch)
    - Test 6 (callbacks.rs): `vc_kind_to_string(&VcKind::OpaqueCallee)` returns `"opaque_callee"`
    - Test 7 (callbacks.rs): `vc_kind_to_string(&VcKind::OpaqueCalleeUnsafe)` returns `"opaque_callee_unsafe"`
  </behavior>
  <action>
    Write tests first (RED). Then implement:

    **diagnostics.rs changes:**

    1. In `vc_kind_description` match, add after `AsyncPostcondition` entry:
       ```rust
       VcKind::OpaqueCallee => "opaque callee: unverified function call",
       VcKind::OpaqueCalleeUnsafe => "opaque callee (unsafe): unverified function call in unsafe context",
       ```

    2. In `suggest_fix` match, add:
       ```rust
       VcKind::OpaqueCallee | VcKind::OpaqueCalleeUnsafe => Some(
           "Add #[requires] / #[ensures] to the callee to enable cross-function verification. \
            See V060 (warning) for safe context, V061 (error) for unsafe context."
               .to_string(),
       ),
       ```

    3. In severity dispatch (the `if failure.vc_kind == VcKind::MemorySafety || ...` block), add `|| failure.vc_kind == VcKind::OpaqueCallee` to the Warning branch. OpaqueCalleeUnsafe falls through to Error naturally.

    **callbacks.rs changes:**

    4. In `vc_kind_to_string` match, add after `AsyncPostcondition` entry:
       ```rust
       VcKind::OpaqueCallee => "opaque_callee",
       VcKind::OpaqueCalleeUnsafe => "opaque_callee_unsafe",
       ```

    5. In the failures push path (the `if !result.verified && result.vc_location.vc_kind != VcKind::Postcondition` block), also exclude `VcKind::OpaqueCallee` from the failure push — it is a warning-only diagnostic, SAT means "diagnostic fired" not "verification failed". OpaqueCalleeUnsafe SAT IS a failure and should remain in the failures list.
       Change the condition to:
       ```rust
       if !result.verified
           && result.vc_location.vc_kind != rust_fv_analysis::vcgen::VcKind::Postcondition
           && result.vc_location.vc_kind != rust_fv_analysis::vcgen::VcKind::OpaqueCallee
       ```
       Note: DataRaceFreedom is handled the same way — verify existing DataRaceFreedom exclusion pattern in callbacks.rs (grep for DataRaceFreedom in the failure push block) and mirror it for OpaqueCallee.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-driver -- test_vc_kind_to_string test_vc_kind_description test_suggest_fix 2>&1 | tail -20</automated>
  </verify>
  <done>
    All 7 unit tests pass. diagnostics.rs has OpaqueCallee in warning branch and vc_kind_description/suggest_fix entries. callbacks.rs has vc_kind_to_string entries and OpaqueCallee excluded from failure push. `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` passes with zero warnings.
  </done>
</task>

<task type="auto">
  <name>Task 3: Full cargo test + clippy green</name>
  <files></files>
  <action>
    Run the full test suite and linter to confirm no regressions before Plan 02 integration tests.

    1. `cargo test -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -30`
    2. `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings 2>&1 | tail -20`
    3. `cargo fmt --check -p rust-fv-analysis -p rust-fv-driver 2>&1`

    Fix any issues found. Do NOT proceed to Plan 02 if any test is red or clippy has errors.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis -p rust-fv-driver 2>&1 | grep -E "^test result|FAILED|error\[" | tail -10</automated>
  </verify>
  <done>
    `cargo test` reports "test result: ok" for both crates. Zero clippy errors. Zero fmt differences.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
- `cargo test -p rust-fv-analysis -p rust-fv-driver` passes with zero failures
- `cargo clippy -p rust-fv-analysis -p rust-fv-driver -- -D warnings` passes
- `cargo fmt --check` passes
- VcKind enum contains OpaqueCallee and OpaqueCalleeUnsafe
- generate_call_site_vcs None-arm emits always-SAT VC (no silent continue)
- diagnostics.rs routes OpaqueCallee to Warning, OpaqueCalleeUnsafe to Error
</verification>

<success_criteria>
1. `VcKind::OpaqueCallee` and `VcKind::OpaqueCalleeUnsafe` variants exist in vcgen.rs
2. Uncontracted callee in safe context → OpaqueCallee VC in conditions (not silence)
3. Uncontracted callee in unsafe fn or unsafe block → OpaqueCalleeUnsafe VC
4. Contracted callee → zero OpaqueCallee VCs (no regression)
5. diagnostics.rs: OpaqueCallee → ReportKind::Warning; OpaqueCalleeUnsafe → ReportKind::Error
6. callbacks.rs: vc_kind_to_string maps OpaqueCallee → "opaque_callee", OpaqueCalleeUnsafe → "opaque_callee_unsafe"
7. callbacks.rs: OpaqueCallee SAT excluded from failure push (warning-only); OpaqueCalleeUnsafe SAT IS a failure
8. All existing tests remain GREEN
</success_criteria>

<output>
After completion, create `.planning/phases/35-opaque-callee-diagnostics/35-01-SUMMARY.md`
</output>

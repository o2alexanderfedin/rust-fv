---
phase: 21-weak-memory-models
plan: 02
type: execute
wave: 2
depends_on: [21-01]
files_modified:
  - crates/analysis/src/concurrency/rc11.rs
  - crates/analysis/src/vcgen.rs
autonomous: true
requirements: [WMM-01, WMM-03, WMM-04]

must_haves:
  truths:
    - "generate_concurrency_vcs() calls generate_weak_memory_vcs() only when has_non_seqcst_atomics() is true"
    - "Functions with only SeqCst atomics produce zero WeakMemory* VCs (WMM-04 regression guard)"
    - "generate_weak_memory_vcs() produces WeakMemoryCoherence VCs for functions with Acquire/Release/Relaxed ops"
    - "generate_weak_memory_vcs() produces WeakMemoryRace VCs for Relaxed-vs-Relaxed same-location accesses from different threads"
    - "All existing concurrency tests continue to pass"
  artifacts:
    - path: "crates/analysis/src/concurrency/rc11.rs"
      provides: "generate_rc11_vcs() and generate_weak_memory_vcs() functions"
      contains: "generate_rc11_vcs"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "RC11 path gated in generate_concurrency_vcs()"
      contains: "has_non_seqcst_atomics"
  key_links:
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/concurrency/rc11.rs"
      via: "generate_rc11_vcs(func) call in generate_concurrency_vcs()"
      pattern: "generate_rc11_vcs"
    - from: "crates/analysis/src/concurrency/rc11.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::WeakMemoryCoherence used in VerificationCondition"
      pattern: "WeakMemoryCoherence"
---

<objective>
Implement generate_rc11_vcs() in rc11.rs that produces WeakMemoryCoherence, WeakMemoryRace, and WeakMemoryAtomicity VCs from a Function's atomic_ops. Wire it into generate_concurrency_vcs() in vcgen.rs, gated on has_non_seqcst_atomics() to prevent SeqCst regressions (WMM-04).

Purpose: This is the core algorithmic work — translating the RC11 axiomatic model into SMT VCs that Z3 can check. The VCGen integration is what makes WMM-01 and WMM-03 observable from outside.

Output: generate_rc11_vcs() function in rc11.rs; gate in vcgen.rs; zero SeqCst regressions.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-weak-memory-models/21-RESEARCH.md
@.planning/phases/21-weak-memory-models/21-01-SUMMARY.md
@crates/analysis/src/concurrency/rc11.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/concurrency/happens_before.rs
@crates/analysis/tests/concurrency_verification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_rc11_vcs() in rc11.rs</name>
  <files>
    crates/analysis/src/concurrency/rc11.rs
  </files>
  <action>
Implement `pub fn generate_rc11_vcs(func: &Function) -> Vec&lt;VerificationCondition&gt;` in rc11.rs.

**Algorithm:**

**Step A — Partition atomic ops by thread_id:**
```rust
// Separate events by thread
let ops = &func.atomic_ops;
// For each event, get: (event_id, location, is_write, thread_id, ordering)
```

**Step B — Build SMT script preamble (QF_LIA):**
Use `rust_fv_smtlib::script::Script` or assemble `Vec&lt;Command&gt;` directly:
- `Command::SetLogic("QF_LIA".to_string())`
- For each store event: `declare_mo_order(event_id)`
- For each (load, store) same-location pair: `declare_rf(load_event, store_event)`

**Step C — Assert mo is a total order per location:**
Group store events by `location`. For each location group, call `assert_mo_total_order(&store_event_ids)`.

**Step D — Assert rf is a function (each load reads from exactly one same-location store):**
For each load event at location L, collect all store events at location L. Call `assert_rf_functional(load_event, &same_location_stores)`. Include a sentinel "initial store" (value = 0) using event_id N (one past last real event) for the initial memory state.

**Step E — Build sb (sequenced-before) pairs:**
`sb(i, j)` holds iff `ops[i].thread_id == ops[j].thread_id && i &lt; j` (program order within thread).

**Step F — Build sw (synchronizes-with) pairs:**
For each (store_event, load_event) pair where `rf_S_L` is declared (same location, store before load in mo):
- `sw(S, L)` = encode_sw(S, store_ordering, L, load_ordering)
- Collect all (S, L, sw_term) triples.

**Step G — Build hb (happens-before) relation:**
For bounded N events, compute hb transitively:
- `hb(i, j)` = sb(i, j) OR sw(i, j) OR (exists k. hb(i, k) AND sw(k, j))
- For bounded N, use BFS/fixpoint over the N×N Boolean matrix.
- Represent hb as a 2D Vec&lt;Vec&lt;bool&gt;&gt; for static events (sb is static) + Terms for sw-dependent parts.
- Simplification: For Phase 21, represent hb as a Term per pair:
  - If sb(i,j): `Term::BoolLit(true)`
  - If exists k where sb(i,k) and sw(k,j): `encode_sw(k, ..., j, ...)`
  - Else: `Term::BoolLit(false)`

**Step H — Build eco (extended coherence order) = rf ∪ mo ∪ fr:**
For each (i, j) pair:
- rf(i, j): `Term::Const(format!("rf_{}_{}", i, j))` if i is load and j is store at same location
- mo(i, j): `Term::BvSLt(mo_order_i, mo_order_j)` — use integer &lt; for QF_LIA (find correct term from smtlib crate)
- fr(i, j): encode_fr(i, store_events_at_same_location) to get fr term from i toward j
- eco(i, j) = Or(rf_term, mo_term, fr_term) where each is BoolLit(false) if not applicable

**Step I — Generate WeakMemoryCoherence VCs:**
For all pairs (i, j) where i != j:
- `hb_i_j = hb_term(i, j)`
- `eco_j_i = eco_term(j, i)`
- If neither is BoolLit(false): emit coherence_check(i, j, hb_i_j, eco_j_i) as a VC
- VcKind = WeakMemoryCoherence

**Step J — Generate WeakMemoryRace VCs:**
For all pairs (i, j) where:
- `ops[i].location == ops[j].location` (same memory location)
- `ops[i].thread_id != ops[j].thread_id` (different threads)
- At least one is a write (is_write)
- Both are Relaxed ordering
- There is no hb in either direction (hb(i,j) = false AND hb(j,i) = false)
For each such pair: emit a VC with `Term::BoolLit(false)` (race is always present — the condition itself is the race evidence) with VcKind::WeakMemoryRace.

**Step K — Generate WeakMemoryAtomicity VCs:**
For RMW events (FetchAdd, CompareExchange, Swap) with non-SeqCst ordering:
- rmw atomicity: the value read by the RMW must be the value immediately before it in mo (no intervening store from another thread)
- Encode as: for each (rmw_event, other_store) pair at same location where `mo(rmw_read_from) &lt; mo(other_store) &lt; mo(rmw_write)` is IMPOSSIBLE
- Emit VerificationCondition with VcKind::WeakMemoryAtomicity

**VerificationCondition construction:**
Each VC uses:
```rust
VerificationCondition {
    location: VcLocation {
        function: func.name.clone(),
        block: 0,
        statement: 0,
        vc_kind: VcKind::WeakMemoryCoherence, // or Race/Atomicity
    },
    script: Script::from_commands(commands), // all preamble + axiom assertions + check-sat
    message: format!("RC11 coherence violation possible between events {} and {}", i, j),
    source_location: None,
}
```

Inspect the `Script` type and `VerificationCondition` fields from existing code to match the exact API. Follow the pattern from `data_race_freedom_vcs()` in `happens_before.rs` for VC construction.

After writing, run `cargo build -p rust-fv-analysis 2>&1 | grep "^error"` and fix all errors. Then run `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1` and fix warnings.
  </action>
  <verify>
    Run: `cargo build -p rust-fv-analysis 2>&1 | grep "^error" | head -10`
    Expected: 0 errors.
    Run: `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep "^error" | wc -l`
    Expected: 0.
  </verify>
  <done>
    generate_rc11_vcs() compiles and returns VCs of kinds WeakMemoryCoherence, WeakMemoryRace, WeakMemoryAtomicity. Zero compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generate_rc11_vcs() into vcgen.rs with SeqCst gate</name>
  <files>
    crates/analysis/src/vcgen.rs
  </files>
  <action>
In `generate_concurrency_vcs()` (around line 3451, after Step 2 data race freedom VCs), add Step 2b:

```rust
// Step 2b: RC11 weak memory axioms for non-SeqCst orderings (WMM-01, WMM-03)
// Scoped to WeakMemory* VcKind only — does NOT affect existing DataRaceFreedom VCs (WMM-04)
if crate::concurrency::rc11::has_non_seqcst_atomics(func) {
    let mut wmm_vcs = crate::concurrency::rc11::generate_rc11_vcs(func);
    vcs.append(&mut wmm_vcs);
}
```

This gate ensures: functions with only SeqCst atomics skip the RC11 path entirely. The existing `data_race_freedom_vcs()` call (Step 2) is unchanged — it continues to produce `DataRaceFreedom` VCs for all atomic functions.

Run `cargo test -p rust-fv-analysis 2>&1 | tail -20` to verify existing tests pass.

If any existing test fails (e.g., VcKind match exhaustiveness in tests), check if the tests use `match vc_kind` or `if let` — add wildcard arms if needed. Do NOT change test assertions that are specific to SeqCst behavior.

Verify SeqCst regression guard: read the test in `concurrency_verification.rs` that constructs a function with only `SeqCst` atomic ops and generates VCs — confirm it produces zero `WeakMemoryCoherence` VCs by running the test with `RUST_LOG=debug cargo test -p rust-fv-analysis -- seqcst 2>&1 | grep -i "weakmemory"`.

Run `cargo fmt --all 2>&1` to ensure formatting.
  </action>
  <verify>
    Run: `cargo test -p rust-fv-analysis 2>&1 | tail -5`
    Expected: "test result: ok. N passed; 0 failed"
    Run: `cargo test -p rust-fv-analysis -- seqcst 2>&1 | grep -c "FAILED"`
    Expected: 0 (all SeqCst tests pass)
    Run: `grep -c "has_non_seqcst_atomics" crates/analysis/src/vcgen.rs`
    Expected: at least 1
  </verify>
  <done>
    generate_concurrency_vcs() invokes generate_rc11_vcs() only for non-SeqCst functions. All existing concurrency tests pass. Zero regressions. WMM-04 constraint satisfied by the has_non_seqcst_atomics gate.
  </done>
</task>

</tasks>

<verification>
Run full test suite: `cargo test -p rust-fv-analysis 2>&1 | grep -E "FAILED|test result"`
Expected: zero FAILED lines, "test result: ok" line.

Verify RC11 path activated for non-SeqCst: Write and run an inline check in existing test file:
```
cargo test -p rust-fv-analysis -- weak_memory 2>&1 | tail -10
```

Verify SeqCst not affected:
```
cargo test -p rust-fv-analysis -- data_race 2>&1 | tail -5
```
Expected: Tests that previously passed still pass.
</verification>

<success_criteria>
- generate_rc11_vcs() is called from generate_concurrency_vcs() only when has_non_seqcst_atomics() returns true
- WeakMemoryCoherence, WeakMemoryRace, WeakMemoryAtomicity VCs are produced for Relaxed/Acquire/Release/AcqRel functions
- Zero existing test failures (WMM-04: SeqCst functions produce no WeakMemory* VCs)
- cargo test -p rust-fv-analysis passes with 0 failures
- cargo clippy passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/21-weak-memory-models/21-02-SUMMARY.md`
</output>

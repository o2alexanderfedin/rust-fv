---
phase: 21-weak-memory-models
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/concurrency/rc11.rs
  - crates/analysis/src/concurrency/mod.rs
autonomous: true
requirements: [WMM-01, WMM-04]

must_haves:
  truths:
    - "VcKind enum has WeakMemoryCoherence, WeakMemoryRace, WeakMemoryAtomicity variants"
    - "AtomicOp IR struct carries thread_id: usize (default 0 = main thread)"
    - "rc11.rs module compiles with declare_mo_order, declare_rf, assert_mo_total_order, assert_rf_functional, encode_sw, encode_fr, coherence_check public functions"
    - "cargo test --lib passes with no regressions on existing concurrency tests"
  artifacts:
    - path: "crates/analysis/src/concurrency/rc11.rs"
      provides: "RC11 SMT encoding primitives"
      min_lines: 150
    - path: "crates/analysis/src/vcgen.rs"
      provides: "WeakMemory* VcKind variants"
      contains: "WeakMemoryCoherence"
    - path: "crates/analysis/src/ir.rs"
      provides: "thread_id field on AtomicOp"
      contains: "thread_id"
  key_links:
    - from: "crates/analysis/src/concurrency/rc11.rs"
      to: "crates/analysis/src/concurrency/mod.rs"
      via: "pub mod rc11 declaration"
      pattern: "pub mod rc11"
    - from: "crates/analysis/src/vcgen.rs"
      to: "VcKind enum"
      via: "new variants"
      pattern: "WeakMemoryCoherence"
---

<objective>
Implement the RC11 weak memory model SMT encoding foundation: extend the IR with thread_id on AtomicOp, add three new VcKind variants for weak memory VCs, and create the rc11.rs module with core RC11 relation primitives (mo, rf, sw, fr, coherence check).

Purpose: Every subsequent plan depends on these types and functions. The VcKind variants establish the scoping contract (WMM-04: WeakMemory* VCs are separate from DataRaceFreedom). The rc11.rs primitives implement the RC11 formal model from Lahav et al. PLDI 2017.

Output: Compilable rc11.rs module, extended VcKind enum, extended AtomicOp struct with thread_id.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-weak-memory-models/21-RESEARCH.md
@crates/analysis/src/concurrency/happens_before.rs
@crates/analysis/src/concurrency/mod.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/ir.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IR AtomicOp with thread_id and add WeakMemory* VcKind variants</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
  </files>
  <action>
**ir.rs — extend AtomicOp struct:**

Find the `AtomicOp` struct (contains fields: `kind: AtomicOpKind`, `ordering: AtomicOrdering`, `atomic_place: Place`, `value: Option&lt;Operand&gt;`). Add field:
```rust
/// Thread that performs this atomic operation.
/// 0 = main thread; N = Nth spawned thread (in thread_spawns order).
/// Used by RC11 weak memory encoding to partition events by thread.
pub thread_id: usize,
```

After adding the field, find all construction sites of `AtomicOp { ... }` in the codebase. In `callbacks.rs` and test files, any literal `AtomicOp { kind, ordering, atomic_place, value }` will now fail to compile. Add `thread_id: 0` as default to all construction sites (both in `callbacks.rs` and in test helper files like `concurrency_verification.rs`). Use `cargo build 2>&1` to identify all sites.

**vcgen.rs — add WeakMemory* variants to VcKind enum:**

In the `VcKind` enum (around line 85-126), after the `ChannelSafety` variant, add:
```rust
/// RC11 coherence check: hb;eco? is irreflexive under weak memory ordering.
/// Generated only for functions with at least one non-SeqCst atomic op.
WeakMemoryCoherence,
/// Weak memory data race: conflicting Relaxed accesses to same location from different threads.
/// Under Relaxed ordering, Relaxed-vs-Relaxed to same location without ordering is a race.
WeakMemoryRace,
/// Weak memory atomicity: RMW atomicity under RC11 (rmw ∩ (rb;mo) = ∅).
/// Generated for fetch_add/compare_exchange ops under non-SeqCst ordering.
WeakMemoryAtomicity,
```

In the `impl VcKind` block, check if there is a `description()` or `Display` method that needs updating — if so, add arms for the new variants returning "RC11 coherence", "weak memory race", and "RC11 RMW atomicity" respectively.

Run `cargo build -p rust-fv-analysis 2>&1` and fix all compilation errors from the new field and enum variants.
  </action>
  <verify>
    Run: `cargo build -p rust-fv-analysis 2>&1 | grep -E "^error" | head -20`
    Expected: No error lines (warnings acceptable).
    Run: `cargo test -p rust-fv-analysis --lib 2>&1 | tail -5`
    Expected: "test result: ok" with 0 failures.
  </verify>
  <done>
    AtomicOp has thread_id field. VcKind has WeakMemoryCoherence, WeakMemoryRace, WeakMemoryAtomicity. Crate compiles. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rc11.rs with RC11 SMT encoding primitives</name>
  <files>
    crates/analysis/src/concurrency/rc11.rs
    crates/analysis/src/concurrency/mod.rs
  </files>
  <action>
Create `crates/analysis/src/concurrency/rc11.rs`. This module implements the RC11 formal model (Lahav et al. PLDI 2017) as bounded SMT primitives for QF_LIA logic.

**Imports:**
```rust
use crate::ir::{AtomicOrdering, AtomicOpKind, Function};
use crate::vcgen::{VcKind, VcLocation, VerificationCondition};
use rust_fv_smtlib::command::Command;
use rust_fv_smtlib::sort::Sort;
use rust_fv_smtlib::term::Term;
```

**Module-level doc comment:** "RC11 weak memory model SMT encoding. Implements mo (modification order), rf (reads-from), sw (synchronizes-with), fr (from-read), and the four RC11 consistency axioms as bounded QF_LIA SMT formulas. See Lahav et al. PLDI 2017."

**Implement these public functions:**

1. `pub fn declare_mo_order(event_id: usize) -> Command`
   - Returns `Command::DeclareFun(format!("mo_order_{}", event_id), vec![], Sort::Int)`
   - For store events: mo_order_N is an Int giving modification order position

2. `pub fn declare_rf(load_event: usize, store_event: usize) -> Command`
   - Returns `Command::DeclareFun(format!("rf_{}_{}", load_event, store_event), vec![], Sort::Bool)`
   - rf_L_S = true means load event L reads from store event S

3. `pub fn assert_mo_total_order(store_events: &[usize]) -> Vec&lt;Command&gt;`
   - For all pairs (i, j) where i &lt; j: assert `Not(Eq(Const("mo_order_i"), Const("mo_order_j")))`
   - This makes mo a strict total order (all distinct positions)

4. `pub fn assert_rf_functional(load_event: usize, store_events: &[usize]) -> Vec&lt;Command&gt;`
   - At-least-one: `Or(rf_L_S0, rf_L_S1, ...)` — load reads from some store
   - At-most-one: for each pair (Si, Sj): `Not(And(rf_L_Si, rf_L_Sj))`
   - Includes initial store event (event_id=usize::MAX represents initial value x=0)

5. `pub fn is_release(ordering: AtomicOrdering) -> bool`
   - True for Release, AcqRel, SeqCst

6. `pub fn is_acquire(ordering: AtomicOrdering) -> bool`
   - True for Acquire, AcqRel, SeqCst

7. `pub fn encode_sw(store_event: usize, store_ordering: AtomicOrdering, load_event: usize, load_ordering: AtomicOrdering) -> Term`
   - If !is_release(store_ordering) || !is_acquire(load_ordering): return `Term::BoolLit(false)`
   - Else: return `Term::Const(format!("rf_{}_{}", load_event, store_event))`
   - AcqRel note: AcqRel passes both is_release and is_acquire checks — this is correct

8. `pub fn encode_fr(load_event: usize, store_events: &[usize]) -> Term`
   - fr(L, S2) = exists S1. rf(L, S1) AND mo(S1, S2)
   - For bounded N: `Or` over all S1 of `And(rf_L_S1, BvSLt(mo_order_S1, mo_order_S2))`
   - Use `Term::BvSLt` only if it exists; otherwise use `Term::Lt` if available, else construct as `Const("mo_order_{s1}") &lt; Const("mo_order_{s2}")` as a custom encoding
   - Actually: use integer comparison. Check smtlib crate for `Term::Lt` or use `Term::Not(Term::Eq(...)) with Term::BvSLt`. The smtlib crate has `Term::BvSLt` for bitvectors — for QF_LIA integers, construct via `(< mo_order_s1 mo_order_s2)` as `Term::App("&lt;".to_string(), vec![...])` or find the correct Term constructor. Inspect `smtlib/src/term.rs` first to find the correct integer comparison term constructor.

9. `pub fn coherence_check(event_i: usize, event_j: usize, hb_i_j: Term, eco_j_i: Term) -> Command`
   - Returns `Command::Assert(Term::Not(Box::new(Term::And(vec![hb_i_j, eco_j_i]))))`
   - Asserts NOT(hb(i,j) AND eco(j,i)) — RC11 COHERENCE axiom for pair (i,j)

10. `pub fn weak_memory_smt_logic() -> &'static str { "QF_LIA" }`
    - Logic selection for weak memory VCs (NOT QF_BV — integers for mo)

11. `pub fn has_non_seqcst_atomics(func: &Function) -> bool`
    - `func.atomic_ops.iter().any(|op| op.ordering != AtomicOrdering::SeqCst)`

**In mod.rs:** Add `pub mod rc11;` and re-export: `pub use rc11::{has_non_seqcst_atomics, weak_memory_smt_logic};`

Before implementing encode_fr: read `crates/smtlib/src/term.rs` to find the correct term constructor for integer `&lt;` comparison. Use whatever exists (e.g., `Term::Lt`, `Term::BvSLt`, or a generic `Term::App`). Do not invent constructors.

Run `cargo build -p rust-fv-analysis 2>&1 | grep "^error"` and fix all errors.
Run `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep "^error"` and fix.
  </action>
  <verify>
    Run: `cargo build -p rust-fv-analysis 2>&1 | grep -c "^error"`
    Expected: 0
    Run: `cargo test -p rust-fv-analysis --lib -- rc11 2>&1 | tail -10`
    Expected: Either "0 failed" or "running 0 tests" (no failures)
    Run: `cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep "^error" | wc -l`
    Expected: 0
  </verify>
  <done>
    rc11.rs compiles with all 11 functions. mod.rs exports pub mod rc11. No clippy errors. Existing tests unaffected.
  </done>
</task>

</tasks>

<verification>
Run full analysis test suite: `cargo test -p rust-fv-analysis 2>&1 | tail -10`
Expected: "test result: ok" with 0 failures on existing tests.

Check new VcKind variants: `grep -c "WeakMemoryCoherence\|WeakMemoryRace\|WeakMemoryAtomicity" crates/analysis/src/vcgen.rs`
Expected: at least 3 matches.

Check rc11.rs exists: `wc -l crates/analysis/src/concurrency/rc11.rs`
Expected: 150+ lines.

Check thread_id on AtomicOp: `grep -c "thread_id" crates/analysis/src/ir.rs`
Expected: at least 1 match.
</verification>

<success_criteria>
- AtomicOp.thread_id: usize compiles without breaking existing tests
- VcKind has three new WeakMemory* variants, no existing variants removed
- rc11.rs has 11 public functions covering mo, rf, sw, fr, coherence_check, and gates
- cargo test -p rust-fv-analysis passes with 0 failures
- cargo clippy passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/21-weak-memory-models/21-01-SUMMARY.md`
</output>

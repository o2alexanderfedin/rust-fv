---
phase: 21-weak-memory-models
plan: 03
type: tdd
wave: 3
depends_on: [21-02]
files_modified:
  - crates/analysis/tests/weak_memory_litmus.rs
autonomous: true
requirements: [WMM-02, WMM-03]

must_haves:
  truths:
    - "All 8 canonical C11 litmus tests (IRIW, SB, LB, MP, CoRR, CoRW, CoWR, CoWW) produce correct SAT/UNSAT verdicts"
    - "MP forbidden scenario (r1=1, r2=0) returns UNSAT from Z3 — RC11 Release/Acquire guarantee holds"
    - "SB allowed scenario (both stores visible from opposite threads) returns SAT under Relaxed"
    - "LB forbidden scenario returns UNSAT — no-thin-air axiom (sb∪rf acyclic)"
    - "Data race test: two Relaxed writes to same location from different threads produces WeakMemoryRace VC"
    - "IRIW forbidden scenario returns UNSAT — coherence rules out inconsistent reads"
  artifacts:
    - path: "crates/analysis/tests/weak_memory_litmus.rs"
      provides: "8 litmus test functions + data race detection test"
      min_lines: 300
      contains: "test_mp_message_passing"
  key_links:
    - from: "crates/analysis/tests/weak_memory_litmus.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "vcgen::generate_concurrency_vcs() call"
      pattern: "generate_concurrency_vcs"
    - from: "crates/analysis/tests/weak_memory_litmus.rs"
      to: "crates/analysis/src/concurrency/rc11.rs"
      via: "VcKind::WeakMemoryCoherence filter"
      pattern: "WeakMemoryCoherence"
---

<objective>
Implement the 8 canonical C11 litmus tests (IRIW, SB, LB, MP, CoRR, CoRW, CoWR, CoWW) as TDD integration tests that validate the RC11 encoding produces correct SAT/UNSAT Z3 verdicts. These tests are the soundness specification for Phase 21 (WMM-02). Also include a Relaxed-vs-Relaxed data race test (WMM-03).

Purpose: The litmus tests are the ground truth — if they pass, the RC11 encoding is correct by construction. If they fail, rc11.rs must be fixed. TDD approach: RED (write tests that specify correct behavior) → GREEN (fix encoding until tests pass) → no separate refactor needed.

Output: weak_memory_litmus.rs with 9 tests; all passing against live Z3.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-weak-memory-models/21-RESEARCH.md
@.planning/phases/21-weak-memory-models/21-01-SUMMARY.md
@.planning/phases/21-weak-memory-models/21-02-SUMMARY.md
@crates/analysis/tests/concurrency_verification.rs
@crates/analysis/src/concurrency/rc11.rs
@crates/analysis/src/vcgen.rs
</context>

<feature>
  <name>8 C11 Litmus Tests + Data Race Test</name>
  <files>crates/analysis/tests/weak_memory_litmus.rs</files>
  <behavior>
Each test constructs a Function IR with atomic_ops having correct thread_id assignments, calls generate_concurrency_vcs(), filters for WeakMemoryCoherence VCs, submits to Z3, and asserts the SAT/UNSAT result.

Expected results per test:
| Test | Scenario | Expected |
|------|----------|----------|
| MP (Message Passing) | r1=flag(Acq)=1 BUT r2=x(Acq)=0 | UNSAT (RC11 Release/Acquire guarantee: if flag seen, x must be seen) |
| SB (Store Buffering) | Both T1 and T2 see stale values | SAT under Relaxed (no ordering constraint between stores) |
| LB (Load Buffering) | T1: r1=x; y=1; T2: r2=y; x=1; both r1=1,r2=1 | UNSAT under RC11 (no-thin-air: sb∪rf would be cyclic) |
| IRIW (Indep. Reads) | T3: x=1,y=0; T4: y=1,x=0 simultaneously | UNSAT (coherence: both cannot see different mo orderings) |
| CoRR | Two reads in same thread see non-monotone mo | UNSAT |
| CoRW | Read sees value before subsequent write in mo | UNSAT |
| CoWR | Write then read same location; read sees earlier value | UNSAT |
| CoWW | Two writes to same location without total mo | UNSAT |
| Data Race | Two Relaxed writes same location, different threads, no ordering | WeakMemoryRace VC present |

Thread layout for each test (using thread_id field added in Plan 01):
- Main thread: thread_id = 0
- First spawned thread: thread_id = 1
- Second spawned thread: thread_id = 2

Cases (I/O contract):
- make_concurrent_function("mp_test", ..., vec![AtomicOp{..., thread_id: 0}, AtomicOp{..., thread_id: 0}, AtomicOp{..., thread_id: 1}, AtomicOp{..., thread_id: 1}], ...)
  -> generate_concurrency_vcs() returns VCs including WeakMemoryCoherence
  -> Z3 on coherence VC for MP-forbidden scenario: UNSAT
  </behavior>
  <implementation>
**RED phase (write tests first):**

Create `crates/analysis/tests/weak_memory_litmus.rs` with:

```rust
//! Litmus test suite for RC11 weak memory model encoding.
//!
//! The 8 canonical C11 litmus tests validate that the RC11 SMT encoding in
//! rc11.rs produces correct SAT/UNSAT verdicts from Z3.
//! These are the soundness specification for WMM-02.

use rust_fv_analysis::ir::*;
use rust_fv_analysis::vcgen::{self, VcKind};
use rust_fv_smtlib::script::Script;
use rust_fv_solver::Z3Solver;

fn solver_or_skip() -> Z3Solver {
    match Z3Solver::with_default_config() {
        Ok(s) => s,
        Err(e) => { eprintln!("Skipping -- Z3 not available: {e}"); panic!("Z3_NOT_AVAILABLE"); }
    }
}

fn make_litmus_function(name: &str, atomic_ops: Vec&lt;AtomicOp&gt;) -> Function {
    // Build minimal Function with concurrency_config enabled
    // Follow pattern from concurrency_verification.rs make_concurrent_function
    // but set thread_id on each AtomicOp directly
    Function {
        name: name.to_string(),
        atomic_ops,
        thread_spawns: vec![ThreadSpawn { ... }], // at least one spawn to trigger concurrency path
        concurrency_config: Some(ConcurrencyConfig { verify_concurrency: true, max_threads: 4, max_context_switches: 3 }),
        // all other fields: default/empty
        ..Function::default() // or manually specify required fields
    }
}
```

**Implement each test:**

1. `test_mp_release_acquire_forbidden()`:
   - Events: W_x(thread=0, Release), W_flag(thread=0, Release), R_flag(thread=1, Acquire), R_x(thread=1, Acquire)
   - Assert: coherence VCs generated, Z3 returns UNSAT for the scenario where R_flag reads 1 but R_x reads 0

2. `test_sb_store_buffering_allowed()`:
   - Events: W_x=1(thread=0, Relaxed), R_y(thread=0, Relaxed), W_y=1(thread=1, Relaxed), R_x(thread=1, Relaxed)
   - Assert: either SAT (allowed) or check VcKind::WeakMemoryRace is NOT generated (no ordering violation)

3. `test_lb_load_buffering_forbidden()`:
   - Events: R_x(thread=0, Relaxed), W_y=1(thread=0, Relaxed), R_y(thread=1, Relaxed), W_x=1(thread=1, Relaxed)
   - Assert: coherence VC for LB-forbidden (both reads = 1) returns UNSAT

4. `test_iriw_forbidden()`:
   - Events: W_x=1(thread=0, Relaxed), W_y=1(thread=1, Relaxed), R_x(thread=2, Relaxed), R_y(thread=2, Relaxed), R_y(thread=3, Relaxed), R_x(thread=3, Relaxed)
   - Assert: coherence VC for scenario (T2: x=1,y=0 AND T3: y=1,x=0) returns UNSAT

5-8. `test_corr_coherence_forbidden()`, `test_corw_coherence_forbidden()`, `test_cowr_coherence_forbidden()`, `test_coww_coherence_forbidden()`:
   - Each tests a single-location coherence scenario
   - All assert UNSAT

9. `test_relaxed_data_race_detected()`:
   - Events: W_x=1(thread=0, Relaxed), W_x=2(thread=1, Relaxed)
   - Assert: VcKind::WeakMemoryRace VC is present in generate_concurrency_vcs() output

**RED phase: Run tests and confirm they FAIL (because generate_rc11_vcs may not yet produce correct VCs for all litmus scenarios):**
```
cargo test -p rust-fv-analysis --test weak_memory_litmus 2>&1 | tail -30
```

**GREEN phase: Fix rc11.rs until all 9 tests pass.**
Key fixes likely needed:
- Correct hb transitive closure for multi-hop chains (sb;sw transitive)
- Correct fr encoding for CoRR/CoRW/CoWR tests
- LB test may need no-thin-air axiom (sb∪rf acyclicity) — add to generate_rc11_vcs() if missing
- IRIW needs correct multi-thread coherence with 4 threads

If Z3 returns UNKNOWN instead of UNSAT/SAT, check that QF_LIA logic is set correctly. If QF_LIA rejects any assertion, fall back to ALL or QF_ALIA.

For each failing test, diagnose by printing the generated SMT script:
```rust
let script_text = script_to_smtlib(&vc.script);
eprintln!("SMT:\n{}", script_text);
```
Then trace through rc11.rs logic to find the encoding bug.

**Commit after RED, commit after GREEN.**
  </implementation>
</feature>

<verification>
Run: `cargo test -p rust-fv-analysis --test weak_memory_litmus 2>&1 | tail -20`
Expected: "test result: ok. 9 passed; 0 failed" (or "test result: ok. N passed; 0 failed" with N up to 9 if Z3 unavailable causes skips)

Run: `cargo test -p rust-fv-analysis 2>&1 | grep -E "FAILED|test result"`
Expected: No FAILED lines. "test result: ok" for the analysis crate.

Check each litmus test name appears: `grep -c "^fn test_" crates/analysis/tests/weak_memory_litmus.rs`
Expected: 9

Verify MP test is present: `grep -c "test_mp" crates/analysis/tests/weak_memory_litmus.rs`
Expected: at least 1

Verify data race test is present: `grep -c "WeakMemoryRace" crates/analysis/tests/weak_memory_litmus.rs`
Expected: at least 1
</verification>

<success_criteria>
- weak_memory_litmus.rs has 9 tests covering all 8 litmus scenarios + data race
- All 9 tests pass (Z3 returns correct SAT/UNSAT)
- MP forbidden returns UNSAT (Release/Acquire guarantee proven)
- SB returns SAT or produces no coherence violation (Relaxed allows this behavior)
- Data race test confirms WeakMemoryRace VC is generated for Relaxed-vs-Relaxed conflict
- Full cargo test -p rust-fv-analysis passes with 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/21-weak-memory-models/21-03-SUMMARY.md`
</output>

---
phase: 12-concurrency-verification
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/concurrency/mod.rs
  - crates/analysis/src/concurrency/thread_encoding.rs
  - crates/analysis/src/lib.rs
  - crates/macros/src/lib.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "IR has ThreadSpawn, AtomicOp, SyncOp, AtomicOrdering, SyncOpKind structs for concurrency representation"
    - "Function struct has fields for thread_spawns, atomic_ops, sync_ops, lock_invariants, concurrency_config"
    - "VcKind has DataRaceFreedom, LockInvariant, Deadlock, ChannelSafety variants"
    - "Driver diagnostics handle all 4 new VcKind variants with descriptions, suggestions, help text"
    - "#[lock_invariant(expr)] and #[verify(concurrent, threads=N, switches=M)] proc macros exist"
    - "ThreadEncoding module provides Interleaving, InterleavingState, ThreadState types and enumeration"
    - "ConcurrencyConfig holds max_threads (default 3), max_context_switches (default 5), verify_concurrency flag"
  artifacts:
    - path: "crates/analysis/src/ir.rs"
      provides: "ThreadSpawn, AtomicOp, AtomicOpKind, AtomicOrdering, SyncOp, SyncOpKind, ConcurrencyConfig types"
      contains: "ThreadSpawn"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::DataRaceFreedom, LockInvariant, Deadlock, ChannelSafety variants"
      contains: "DataRaceFreedom"
    - path: "crates/analysis/src/concurrency/mod.rs"
      provides: "Concurrency module declaration and re-exports"
      contains: "pub mod thread_encoding"
    - path: "crates/analysis/src/concurrency/thread_encoding.rs"
      provides: "ThreadState, InterleavingState, Interleaving types and enumerate_interleavings()"
      contains: "enumerate_interleavings"
    - path: "crates/macros/src/lib.rs"
      provides: "#[lock_invariant] and #[verify] proc macros"
      contains: "lock_invariant"
    - path: "crates/driver/src/diagnostics.rs"
      provides: "DataRaceFreedom/LockInvariant/Deadlock/ChannelSafety diagnostic handling"
      contains: "DataRaceFreedom"
  key_links:
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VcKind::DataRaceFreedom match arm in diagnostic formatting"
      pattern: "VcKind::DataRaceFreedom"
    - from: "crates/analysis/src/concurrency/thread_encoding.rs"
      to: "crates/analysis/src/ir.rs"
      via: "ThreadState references ThreadSpawn, AtomicOp, SyncOp IR types"
      pattern: "ThreadSpawn"
    - from: "crates/macros/src/lib.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Proc macros encode lock_invariant/verify attributes as doc strings matching IR extraction"
      pattern: "lock_invariant"
---

<objective>
Add concurrency IR types (ThreadSpawn, AtomicOp, SyncOp, AtomicOrdering), VcKind extensions
(DataRaceFreedom, LockInvariant, Deadlock, ChannelSafety), thread interleaving enumeration
infrastructure, proc macros (#[lock_invariant], #[verify(concurrent)]), ConcurrencyConfig,
and driver diagnostics for all new VcKind variants.

Purpose: Establish the concurrency type system, interleaving infrastructure, and diagnostic
pipeline that Plans 02 and 03 will use for happens-before encoding, VC generation, deadlock
detection, and end-to-end verification.

Output: Extended IR with concurrency types, 4 new VcKind variants with full diagnostic support,
thread_encoding module with bounded interleaving enumeration, proc macros for lock_invariant
and concurrency verification configuration.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-concurrency-verification/12-RESEARCH.md
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/lib.rs
@crates/macros/src/lib.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add concurrency IR types, VcKind variants, ConcurrencyConfig, and thread_encoding module (TDD)</name>
  <files>
    crates/analysis/src/ir.rs
    crates/analysis/src/vcgen.rs
    crates/analysis/src/concurrency/mod.rs
    crates/analysis/src/concurrency/thread_encoding.rs
    crates/analysis/src/lib.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    === IR Types (crates/analysis/src/ir.rs) ===

    Add the following types AFTER the UnsafeContracts/UnsafeOperation types (end of IR types, before Function struct):

    1. ThreadSpawn -- Thread spawn site in the program:
       - handle_local: String (local variable holding JoinHandle)
       - thread_fn: String (closure or function called in spawned thread)
       - args: Vec<Operand> (arguments passed to thread function)
       - is_scoped: bool (whether std::thread::scope)
       Derive: Debug, Clone

    2. AtomicOpKind -- Type of atomic operation:
       - Load, Store, Swap, CompareExchange, FetchAdd, FetchSub
       Derive: Debug, Clone, Copy, PartialEq, Eq

    3. AtomicOrdering -- Memory ordering (maps to C11):
       - Relaxed, Acquire, Release, AcqRel, SeqCst
       Derive: Debug, Clone, Copy, PartialEq, Eq

    4. AtomicOp -- Atomic operation in the program:
       - kind: AtomicOpKind
       - ordering: AtomicOrdering
       - atomic_place: Place (atomic variable being accessed)
       - value: Option<Operand> (for stores/compare-exchange)
       Derive: Debug, Clone

    5. SyncOpKind -- Synchronization operation type:
       - MutexLock, MutexUnlock, RwLockRead, RwLockWrite, RwLockUnlock, ChannelSend, ChannelRecv
       Derive: Debug, Clone, PartialEq, Eq

    6. SyncOp -- Synchronization operation:
       - kind: SyncOpKind
       - sync_object: Place
       Derive: Debug, Clone

    7. ConcurrencyConfig -- Bounded verification configuration:
       - verify_concurrency: bool (default: false, opt-in)
       - max_threads: usize (default: 3)
       - max_context_switches: usize (default: 5)
       Derive: Debug, Clone, PartialEq, Eq
       Implement Default with above defaults.

    Add fields to Function struct (after is_unsafe_fn):
    - thread_spawns: Vec<ThreadSpawn>
    - atomic_ops: Vec<AtomicOp>
    - sync_ops: Vec<SyncOp>
    - lock_invariants: Vec<(String, SpecExpr)> -- (mutex_local_name, invariant_expr) pairs
    - concurrency_config: Option<ConcurrencyConfig>

    Update ALL Function construction sites with the new fields (default empty Vec and None).

    === VcKind (crates/analysis/src/vcgen.rs) ===

    Add 4 new VcKind variants after FloatingPointNaN:
    - DataRaceFreedom -- "Data race freedom check (conflicting accesses must be ordered)"
    - LockInvariant -- "Lock invariant check (must hold at release)"
    - Deadlock -- "Deadlock detection (lock-order cycle)"
    - ChannelSafety -- "Channel operation safety (send-on-closed, capacity overflow, recv deadlock)"

    === Concurrency Module ===

    Create crates/analysis/src/concurrency/mod.rs:
    - pub mod thread_encoding;
    - Re-export key types: ThreadState, InterleavingState, Interleaving, InterleavingEvent

    Create crates/analysis/src/concurrency/thread_encoding.rs:
    - ThreadState struct: thread_id: usize, num_steps: usize, is_spawned: bool
    - InterleavingEvent struct: thread_id: usize, step: usize, operation: String
    - Interleaving struct: events: Vec<InterleavingEvent>, context_switches: usize
    - InterleavingState struct (internal): thread_pcs: Vec<usize>, active_thread: usize, context_switches: usize
    - InterleavingState methods: all_threads_done(), can_schedule(), step()
    - pub fn enumerate_interleavings(threads: &[ThreadState], max_switches: usize) -> Vec<Interleaving>
      Uses recursive enumeration (lazy approach from RESEARCH.md Pattern 1).
      Bounds: if context_switches + switch_cost > max_switches, skip.

    Register module in crates/analysis/src/lib.rs:
    - Add: pub mod concurrency;

    Tests to write FIRST (RED phase):
    In ir.rs tests:
    - test_thread_spawn_creation: create ThreadSpawn, verify fields
    - test_atomic_op_creation: create AtomicOp with SeqCst Load, verify fields
    - test_sync_op_creation: create SyncOp with MutexLock, verify fields
    - test_concurrency_config_default: ConcurrencyConfig::default() has verify_concurrency=false, max_threads=3, max_switches=5
    - test_function_with_concurrency_fields: Function with thread_spawns and atomic_ops

    In thread_encoding.rs tests:
    - test_enumerate_single_thread: 1 thread, 2 steps => 1 interleaving, 0 switches
    - test_enumerate_two_threads_zero_switches: 2 threads, 2 steps each, max_switches=0 => only sequential interleavings (thread 0 runs all, then thread 1)
    - test_enumerate_two_threads_one_switch: 2 threads, 1 step each, max_switches=1 => 2 interleavings (0-then-1, 1-then-0)
    - test_enumerate_two_threads_two_steps_one_switch: 2 threads, 2 steps each, max_switches=1
    - test_enumerate_respects_max_switches: verify count increases with higher switch bound
    - test_interleaving_event_fields: verify event fields accessible
    - test_empty_threads: 0 threads => 1 interleaving (empty)
    - test_three_threads_bounded: 3 threads, 1 step each, max_switches=2 => enumerate all 6 orderings

    In vcgen.rs tests:
    - test_vc_kind_data_race_freedom: VcKind::DataRaceFreedom equality
    - test_vc_kind_lock_invariant: VcKind::LockInvariant equality
    - test_vc_kind_deadlock: VcKind::Deadlock equality
    - test_vc_kind_channel_safety: VcKind::ChannelSafety equality
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    IR has ThreadSpawn, AtomicOp, AtomicOrdering, SyncOp, SyncOpKind, ConcurrencyConfig types.
    Function struct has 5 new concurrency fields. All construction sites updated.
    VcKind has 4 new concurrency variants. Concurrency module with thread_encoding provides
    bounded interleaving enumeration. ~20 new tests pass. 0 regressions. 0 clippy warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add proc macros and driver diagnostics for concurrency VcKinds (TDD)</name>
  <files>
    crates/macros/src/lib.rs
    crates/driver/src/callbacks.rs
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    === Proc Macros (crates/macros/src/lib.rs) ===

    Add #[lock_invariant(expr)] proc macro:
    - Follow the spec_attribute pattern (same as #[requires], #[ensures], #[decreases])
    - Encodes as doc attribute: #[doc = "rust_fv::lock_invariant::EXPR"]
    - Place on struct fields wrapping Mutex<T> or RwLock<T>
    - Example: #[lock_invariant(value >= 0)]

    Add #[verify(concurrent)] proc macro (extend existing #[verify] if it exists, otherwise create):
    - Parses: #[verify(concurrent)], #[verify(threads = N)], #[verify(switches = M)],
      #[verify(concurrent, threads = N, switches = M)]
    - Encodes as doc attributes:
      - #[doc = "rust_fv::verify::concurrent"]
      - #[doc = "rust_fv::verify::threads::N"]
      - #[doc = "rust_fv::verify::switches::M"]
    - Place on functions to enable concurrency verification with custom bounds

    === Driver Callbacks (crates/driver/src/callbacks.rs) ===

    Add VcKind serialization for all 4 new variants:
    - VcKind::DataRaceFreedom => "data_race_freedom"
    - VcKind::LockInvariant => "lock_invariant"
    - VcKind::Deadlock => "deadlock"
    - VcKind::ChannelSafety => "channel_safety"

    === Driver Diagnostics (crates/driver/src/diagnostics.rs) ===

    Add to vc_kind_description():
    - DataRaceFreedom => "data race detected"
    - LockInvariant => "lock invariant violation"
    - Deadlock => "potential deadlock detected"
    - ChannelSafety => "channel operation safety violation"

    Add to suggest_fix():
    - DataRaceFreedom => "Add synchronization (Mutex, RwLock, or atomic operations) to protect shared state.
      Ensure all concurrent accesses to the same memory location are ordered by happens-before."
    - LockInvariant => "Ensure the lock invariant holds before releasing the lock.
      The invariant was assumed at acquire and must be re-established at release."
    - Deadlock => "Establish a consistent lock ordering. If multiple locks are needed,
      always acquire them in the same order across all threads."
    - ChannelSafety => "Check channel usage: ensure sender is not dropped before receiver reads,
      bounded channels have capacity for sends, and receivers handle closed channels."

    Add to report_text_only() (after FloatingPointNaN block):
    - DataRaceFreedom: print format_data_race_help() with interleaving trace guidance
    - Deadlock: print format_deadlock_help() with lock-ordering guidance
    - ChannelSafety: print format_channel_safety_help()

    Add to report_with_ariadne() severity:
    - DataRaceFreedom => Error (data races are UB in Rust)
    - LockInvariant => Error (invariant violation is a bug)
    - Deadlock => Warning (static analysis may have false positives)
    - ChannelSafety => Error (channel misuse causes panics/deadlocks)

    Add helper functions:
    - format_data_race_help(): explains happens-before, shows interleaving trace example
    - format_deadlock_help(): explains lock ordering, shows A->B / B->A pattern
    - format_channel_safety_help(): explains send-on-closed, recv deadlock, capacity overflow
    - format_bounded_verification_warning(threads: usize, switches: usize): emits
      "Verified up to {threads} threads and {switches} context switches.
       May miss bugs in deeper interleavings. Try --max-switches={switches*2} for broader coverage."

    Add ALL 4 new VcKinds to test arrays that exercise all VcKind variants (search for
    "VcKind::FloatingPointNaN" in test arrays and add the 4 new variants after each).

    Tests to write FIRST (RED phase):
    In macros crate tests:
    - test_lock_invariant_macro: #[lock_invariant(value >= 0)] encodes correctly
    - test_verify_concurrent_macro: #[verify(concurrent)] encodes correctly
    - test_verify_threads_switches_macro: #[verify(concurrent, threads = 4, switches = 8)] encodes

    In diagnostics.rs tests:
    - test_vc_kind_description_data_race: description returns "data race detected"
    - test_vc_kind_description_lock_invariant: description returns "lock invariant violation"
    - test_vc_kind_description_deadlock: description returns "potential deadlock detected"
    - test_vc_kind_description_channel_safety: description returns "channel operation safety violation"
    - test_suggest_fix_data_race: suggestion mentions synchronization
    - test_suggest_fix_deadlock: suggestion mentions lock ordering
    - test_format_bounded_verification_warning: warning mentions threads, switches, --max-switches
    - test_report_text_only_data_race: report produces output for DataRaceFreedom
    - test_report_text_only_deadlock: report produces output for Deadlock
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    #[lock_invariant(expr)] and #[verify(concurrent, threads=N, switches=M)] proc macros work.
    All 4 new VcKinds have serialization in callbacks and full diagnostics (description, suggestion,
    help text, severity). Bounded verification warning function emits actionable message. ~12 new
    tests pass. All existing tests pass (0 regressions). 0 clippy warnings.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- IR has all concurrency types (ThreadSpawn, AtomicOp, SyncOp, etc.)
- VcKind has 4 new variants handled in ALL match arms (no compiler warnings)
- Thread interleaving enumeration respects bounds and produces correct results
- Proc macros encode concurrency annotations as doc attributes
- ~32 new tests total across both tasks
</verification>

<success_criteria>
1. IR has 7 new concurrency types with correct fields and derives
2. Function struct has 5 new concurrency fields, all construction sites updated
3. VcKind has 4 new variants (DataRaceFreedom, LockInvariant, Deadlock, ChannelSafety)
4. enumerate_interleavings() produces bounded interleavings with correct switch counts
5. Proc macros for lock_invariant and verify(concurrent) encode correctly
6. Driver diagnostics handle all 4 new VcKinds with appropriate severities
7. Bounded verification warning provides actionable guidance
8. ~32 new tests passing, 0 regressions, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-concurrency-verification/12-01-SUMMARY.md`
</output>

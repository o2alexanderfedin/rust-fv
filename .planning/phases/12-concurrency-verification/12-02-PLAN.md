---
phase: 12-concurrency-verification
plan: 02
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - crates/analysis/src/concurrency/happens_before.rs
  - crates/analysis/src/concurrency/lock_invariants.rs
  - crates/analysis/src/concurrency/deadlock_detection.rs
  - crates/analysis/src/concurrency/channel_verification.rs
  - crates/analysis/src/concurrency/mod.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Happens-before partial order encodes all 5 atomic orderings (Relaxed, Acquire, Release, AcqRel, SeqCst) as SMT constraints"
    - "Data race freedom VCs generated for conflicting memory accesses across threads (one write, same location)"
    - "Lock invariant VCs assume invariant at acquire and assert at release"
    - "Deadlock detection finds lock-order cycles via Tarjan's SCC on lock-order graph"
    - "Channel VCs cover send-on-closed, recv-on-empty-closed deadlock, bounded capacity overflow"
    - "VCGen integrates concurrency VC generation when function has thread_spawns or verify_concurrency enabled"
    - "Bounded verification warning emitted when concurrency verification runs"
  artifacts:
    - path: "crates/analysis/src/concurrency/happens_before.rs"
      provides: "Happens-before encoding, atomic ordering mapping, data race freedom VC generation"
      exports: ["happens_before", "encode_atomic_ordering", "data_race_freedom_vcs"]
    - path: "crates/analysis/src/concurrency/lock_invariants.rs"
      provides: "Lock invariant VC generation (assume at acquire, assert at release)"
      exports: ["lock_invariant_vcs", "LockOp"]
    - path: "crates/analysis/src/concurrency/deadlock_detection.rs"
      provides: "Lock-order graph construction, cycle detection via Tarjan's SCC"
      exports: ["detect_deadlock", "LockOrderGraph", "DeadlockCycle"]
    - path: "crates/analysis/src/concurrency/channel_verification.rs"
      provides: "Channel operation VCs for send/recv safety"
      exports: ["channel_operation_vcs", "ChannelState", "ChannelOp"]
    - path: "crates/analysis/src/concurrency/mod.rs"
      provides: "Updated module declarations and re-exports for all concurrency submodules"
      contains: "pub mod happens_before"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Concurrency VC generation integrated into generate_vcs pipeline"
      contains: "generate_concurrency_vcs"
  key_links:
    - from: "crates/analysis/src/concurrency/happens_before.rs"
      to: "crates/smtlib/src/term.rs"
      via: "Term::BvSLt, Term::Implies, Term::Or for HB timestamp encoding"
      pattern: "Term::"
    - from: "crates/analysis/src/concurrency/lock_invariants.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VerificationCondition, VcLocation, VcKind::LockInvariant types"
      pattern: "VcKind::LockInvariant"
    - from: "crates/analysis/src/concurrency/deadlock_detection.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VerificationCondition, VcKind::Deadlock for cycle-based VCs"
      pattern: "VcKind::Deadlock"
    - from: "crates/analysis/src/concurrency/channel_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "VerificationCondition, VcKind::ChannelSafety for channel operation VCs"
      pattern: "VcKind::ChannelSafety"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/concurrency/"
      via: "generate_concurrency_vcs calls happens_before, lock_invariants, deadlock, channel modules"
      pattern: "concurrency::"
---

<objective>
Implement the core concurrency verification modules: happens-before partial order encoding with
all 5 atomic orderings (C11 mapping), data race freedom VC generation, lock invariant verification
(assume at acquire / assert at release), deadlock detection via lock-order graph cycle detection
(Tarjan's SCC), and channel operation verification (send-on-closed, recv deadlock, capacity overflow).
Integrate all concurrency VC generation into the VCGen pipeline.

Purpose: Provide the SMT encoding and VC generation logic that translates concurrency IR types
(from Plan 01) into verification conditions checkable by Z3. This is the core algorithmic module
that makes bounded concurrency verification work.

Output: Four new concurrency submodules (happens_before, lock_invariants, deadlock_detection,
channel_verification) with full VC generation, integrated into VCGen pipeline via
generate_concurrency_vcs function.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-concurrency-verification/12-RESEARCH.md
@.planning/phases/12-concurrency-verification/12-01-SUMMARY.md
@crates/analysis/src/concurrency/mod.rs
@crates/analysis/src/concurrency/thread_encoding.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/encode_term.rs
@crates/smtlib/src/term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement happens-before encoding, data race freedom VCs, lock invariant VCs, and deadlock detection (TDD)</name>
  <files>
    crates/analysis/src/concurrency/happens_before.rs
    crates/analysis/src/concurrency/lock_invariants.rs
    crates/analysis/src/concurrency/deadlock_detection.rs
    crates/analysis/src/concurrency/mod.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    === Happens-Before Module (happens_before.rs) ===

    Types:
    - EventId: usize (type alias for event identifiers)
    - MemoryAccess struct: event_id: EventId, location: String (place name), is_write: bool,
      thread_id: usize, source_line: Option<usize>
      Derive: Debug, Clone

    Functions:
    1. happens_before(event_a: EventId, event_b: EventId) -> Term
       Encode as timestamp_A < timestamp_B using Term::BvSLt on Term::Const("ts_{event_id}") constants.
       Use 64-bit bitvectors for timestamps.

    2. reads_from(load_event: EventId, store_event: EventId) -> Term
       Encode as rf_{load} == event_{store} using Term::Eq.

    3. encode_atomic_ordering(ordering: AtomicOrdering, store_event: EventId, load_event: EventId) -> Term
       Map all 5 Rust orderings to C11 semantics (from RESEARCH.md Pattern 2):
       - SeqCst: total order via happens_before(store, load)
       - Release: implies(reads_from(load, store), happens_before(store, load))
       - Acquire: implies(reads_from(load, store), happens_before(store, load))
       - AcqRel: same as Acquire (both acquire and release semantics)
       - Relaxed: Term::BoolLit(true) (no synchronization, only atomicity)

    4. mutex_happens_before(release_thread: usize, release_pc: usize, acquire_thread: usize, acquire_pc: usize) -> Term
       Encode release -> acquire ordering using timestamps.

    5. data_race_freedom_vcs(accesses: &[MemoryAccess]) -> Vec<VerificationCondition>
       For each pair of conflicting accesses (same location, different threads, at least one write):
       Assert a HB b OR b HB a (ordered). Generate VcKind::DataRaceFreedom VC.
       Use a helper fn conflicting(a, b) -> bool to check same location, different thread, one is write.

    === Lock Invariants Module (lock_invariants.rs) ===

    Types:
    - LockOp enum: Acquire, Release
      Derive: Debug, Clone, PartialEq, Eq

    Functions:
    1. lock_invariant_vcs(mutex_local: &str, invariant_expr: &str, locations: &[(VcLocation, LockOp)]) -> Vec<VerificationCondition>
       At Acquire: return None (assume invariant, add to path condition -- no VC generated).
       At Release: generate VcKind::LockInvariant VC asserting invariant holds.
       Description: "Lock invariant for {mutex_local} must hold at release: {invariant_expr}"
       Use Term::Const for the invariant expression placeholder (symbolic encoding, real spec parsing
       deferred to driver integration). Script: build SMT script asserting NOT(invariant) for UNSAT check.

    === Deadlock Detection Module (deadlock_detection.rs) ===

    Types:
    - LockId: usize (type alias)
    - LockOrderGraph struct: adjacency: HashMap<LockId, Vec<LockId>>
      Methods: new(), add_edge(held, acquired), has_self_loop(lock), edges_from(lock)
    - DeadlockCycle struct: locks: Vec<LockId>, example_trace: Vec<String>

    Functions:
    1. detect_deadlock(graph: &LockOrderGraph) -> Option<DeadlockCycle>
       Find SCCs using Tarjan's algorithm (petgraph already a dependency from Phase 6).
       Any SCC with >1 node or self-loop indicates potential deadlock.
       Reconstruct example trace showing conflicting lock orders.

    2. deadlock_vcs(cycles: &[DeadlockCycle]) -> Vec<VerificationCondition>
       Generate VcKind::Deadlock VC for each detected cycle.
       Description: "Potential deadlock: locks {cycle.locks} acquired in conflicting order"
       These are diagnostic VCs (always-SAT pattern) to report deadlock through the VC pipeline.

    Update crates/analysis/src/concurrency/mod.rs:
    - Add: pub mod happens_before;
    - Add: pub mod lock_invariants;
    - Add: pub mod deadlock_detection;
    - Re-export key types: MemoryAccess, EventId, LockOp, LockOrderGraph, DeadlockCycle

    Tests to write FIRST (RED phase):

    In happens_before.rs tests:
    - test_happens_before_encoding: happens_before(0, 1) produces BvSLt on timestamps
    - test_reads_from_encoding: reads_from(0, 1) produces Eq on rf/event vars
    - test_seqcst_ordering: encode_atomic_ordering(SeqCst, ..) produces HB constraint
    - test_acquire_ordering: encode_atomic_ordering(Acquire, ..) produces implies(reads_from, HB)
    - test_release_ordering: encode_atomic_ordering(Release, ..) produces implies(reads_from, HB)
    - test_acqrel_ordering: encode_atomic_ordering(AcqRel, ..) same as Acquire
    - test_relaxed_ordering: encode_atomic_ordering(Relaxed, ..) produces BoolLit(true)
    - test_mutex_happens_before: mutex HB encoding uses thread/pc timestamps
    - test_data_race_freedom_conflicting: two writes to same location => VC generated
    - test_data_race_freedom_no_conflict_reads: two reads to same location => no VC
    - test_data_race_freedom_no_conflict_different_location: write+write different locations => no VC
    - test_data_race_freedom_same_thread: same thread accesses => no VC

    In lock_invariants.rs tests:
    - test_lock_invariant_at_acquire: no VC generated for Acquire
    - test_lock_invariant_at_release: VcKind::LockInvariant VC generated for Release
    - test_lock_invariant_description: description contains mutex name and invariant
    - test_lock_invariant_multiple_releases: one VC per release location

    In deadlock_detection.rs tests:
    - test_no_deadlock_linear: A->B graph has no cycle
    - test_deadlock_simple_cycle: A->B, B->A detected as deadlock
    - test_deadlock_self_loop: A->A detected
    - test_deadlock_three_node_cycle: A->B, B->C, C->A detected
    - test_deadlock_vc_generation: deadlock_vcs produces VcKind::Deadlock VCs
    - test_empty_graph: no deadlock in empty graph
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    happens_before.rs encodes all 5 atomic orderings as SMT constraints and generates data race
    freedom VCs for conflicting accesses. lock_invariants.rs generates LockInvariant VCs at release
    points (none at acquire). deadlock_detection.rs finds lock-order cycles via Tarjan's SCC.
    ~22 new tests pass. 0 regressions. 0 clippy warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement channel verification and VCGen concurrency integration (TDD)</name>
  <files>
    crates/analysis/src/concurrency/channel_verification.rs
    crates/analysis/src/concurrency/mod.rs
    crates/analysis/src/vcgen.rs
  </files>
  <action>
    TDD: Write failing tests first, then implement.

    === Channel Verification Module (channel_verification.rs) ===

    Types:
    - ChannelState struct: name: String, capacity: Option<usize> (None = unbounded),
      is_closed: bool
      Derive: Debug, Clone
    - ChannelOp enum: Send { value: String }, Recv
      Derive: Debug, Clone

    Functions:
    1. channel_operation_vcs(channel: &ChannelState, operation: &ChannelOp, location: VcLocation) -> Vec<VerificationCondition>
       For Send:
       - VC 1: Channel not closed at send (VcKind::ChannelSafety).
         Term: NOT({name}_closed). Description: "Channel must not be closed at send"
       - VC 2 (bounded only): Channel has capacity.
         Term: {name}_size < capacity. Description: "Bounded channel has capacity (max {N})"
       - Warning (unbounded only): Emit diagnostic VC noting unbounded channel modeled with limit.
         Description: "Unbounded channel modeled with verification limit; may miss capacity issues"
       For Recv:
       - VC: Channel not empty-and-closed (avoid deadlock).
         Term: OR({name}_size > 0, NOT({name}_closed)).
         Description: "Channel must have items or be open (avoid deadlock)"

    Update crates/analysis/src/concurrency/mod.rs:
    - Add: pub mod channel_verification;
    - Re-export: ChannelState, ChannelOp

    === VCGen Integration (crates/analysis/src/vcgen.rs) ===

    Add pub fn generate_concurrency_vcs(func: &Function) -> Vec<VerificationCondition>:
    - Guard: only run if func.concurrency_config.map(|c| c.verify_concurrency).unwrap_or(false)
      OR func.thread_spawns is non-empty.
    - Step 1: Build MemoryAccess list from atomic_ops (each AtomicOp becomes a MemoryAccess with
      is_write = kind is Store/Swap/CompareExchange/FetchAdd/FetchSub).
    - Step 2: Call data_race_freedom_vcs(&accesses) for DataRaceFreedom VCs.
    - Step 3: Call lock_invariant_vcs for each (mutex_name, invariant) in func.lock_invariants,
      building locations from func.sync_ops where sync_object matches mutex_name.
    - Step 4: Build LockOrderGraph from func.sync_ops (MutexLock operations), tracking
      which locks are held when a new lock is acquired. Call detect_deadlock and deadlock_vcs.
    - Step 5: Call channel_operation_vcs for ChannelSend/ChannelRecv in func.sync_ops.
    - Step 6: Add bounded verification warning VC (VcKind::DataRaceFreedom, always-SAT pattern)
      with description: "Bounded verification: up to {max_threads} threads, {max_switches} context
      switches. May miss bugs in deeper interleavings."
    - Return all collected VCs.

    Call generate_concurrency_vcs from the main generate_vcs function (after existing VC generation
    sections like float_verification). Append results to the vc list.

    Tests to write FIRST (RED phase):

    In channel_verification.rs tests:
    - test_send_on_closed_channel: Send on closed channel generates ChannelSafety VC
    - test_send_on_open_channel: Send on open channel generates no closed-channel VC
    - test_bounded_send_capacity: Send on bounded channel generates capacity VC
    - test_unbounded_send_warning: Send on unbounded channel generates warning VC
    - test_recv_deadlock: Recv on empty-and-closed channel covered by VC
    - test_recv_open_channel: Recv on open channel covered by VC (OR condition)
    - test_send_generates_two_vcs_bounded: bounded Send produces 2 VCs (closed + capacity)
    - test_recv_generates_one_vc: Recv produces 1 VC

    In vcgen.rs tests:
    - test_generate_concurrency_vcs_empty: function without concurrency => empty VCs
    - test_generate_concurrency_vcs_with_atomics: function with atomic_ops => DataRaceFreedom VCs
    - test_generate_concurrency_vcs_with_lock_invariants: function with lock_invariants => LockInvariant VCs
    - test_generate_concurrency_vcs_with_sync_ops: function with MutexLock ops => deadlock check runs
    - test_generate_concurrency_vcs_bounded_warning: concurrency verification produces bounded warning VC
    - test_generate_concurrency_vcs_integration: function with thread_spawns auto-enables verification
  </action>
  <verify>
    cargo test --workspace 2>&amp;1 | tail -5
    cargo clippy --workspace -- -D warnings 2>&amp;1 | tail -5
    cargo fmt --all -- --check
  </verify>
  <done>
    channel_verification.rs generates ChannelSafety VCs for send-on-closed, capacity overflow,
    and recv deadlock. VCGen generate_concurrency_vcs integrates all concurrency modules (happens_before,
    lock_invariants, deadlock_detection, channel_verification) and produces bounded verification
    warning. ~14 new tests pass. All existing tests pass. 0 clippy warnings.
  </done>
</task>

</tasks>

<verification>
- All workspace tests pass: cargo test --workspace
- 0 clippy warnings: cargo clippy --workspace -- -D warnings
- 0 formatting issues: cargo fmt --all -- --check
- happens_before.rs encodes all 5 atomic orderings correctly
- data_race_freedom_vcs generates VCs for conflicting accesses, ignores safe accesses
- lock_invariant_vcs generates VCs at release (not acquire)
- detect_deadlock finds cycles in lock-order graphs
- channel_operation_vcs covers send-on-closed, capacity, recv deadlock
- generate_concurrency_vcs integrates all modules and produces bounded warning
- ~36 new tests total across both tasks
</verification>

<success_criteria>
1. All 5 atomic orderings (Relaxed, Acquire, Release, AcqRel, SeqCst) encoded as SMT constraints
2. Data race freedom VCs generated for conflicting concurrent accesses
3. Lock invariant VCs generated at release points (assumed at acquire)
4. Deadlock detection finds lock-order graph cycles via Tarjan's SCC
5. Channel VCs cover send-on-closed, bounded capacity, recv deadlock
6. VCGen pipeline integrates concurrency verification via generate_concurrency_vcs
7. Bounded verification warning emitted with thread/switch counts
8. ~36 new tests passing, 0 regressions, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-concurrency-verification/12-02-SUMMARY.md`
</output>

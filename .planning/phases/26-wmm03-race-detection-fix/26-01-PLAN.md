---
phase: 26-wmm03-race-detection-fix
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/concurrency/rc11.rs
  - crates/analysis/tests/weak_memory_litmus.rs
autonomous: true
requirements:
  - WMM-03

must_haves:
  truths:
    - "WeakMemoryRace VC script is SAT-returning (Z3 finds a model, not UNSAT)"
    - "test_relaxed_data_race_detected calls Z3 and asserts SolverResult::Sat"
    - "Two Relaxed writes to the same location from different threads produce a WeakMemoryRace VC with mo_cmds and rf_cmds included"
  artifacts:
    - path: "crates/analysis/src/concurrency/rc11.rs"
      provides: "WeakMemoryRace VC with Assert(BoolLit(true)) + mo_cmds + rf_cmds"
      contains: "BoolLit(true)"
    - path: "crates/analysis/tests/weak_memory_litmus.rs"
      provides: "Z3 SAT check for WeakMemoryRace VC"
      contains: "SolverResult::Sat"
  key_links:
    - from: "rc11.rs generate_rc11_vcs() Step J"
      to: "Z3 solver"
      via: "Script with preamble + mo_cmds + rf_cmds + Assert(BoolLit(true)) + CheckSat"
      pattern: "BoolLit\\(true\\)"
    - from: "test_relaxed_data_race_detected"
      to: "Z3Solver.check_sat_raw"
      via: "solver_or_skip() + race_vcs[0].script.to_string()"
      pattern: "SolverResult::Sat"
---

<objective>
Fix the WeakMemoryRace VC body in rc11.rs to emit a SAT-returning formula (preamble + mo_cmds + rf_cmds + Assert(BoolLit(true))) instead of the current Assert(BoolLit(false)) stub that always returns UNSAT, silently hiding Relaxed data races.

Purpose: WMM-03 soundness gap — with Assert(BoolLit(false)), the driver always marks WeakMemoryRace VCs as verified:true regardless of whether a race exists. The fix makes Z3 return SAT so the existing pipeline (parallel.rs SAT → verified:false → callbacks.rs push failure) correctly surfaces race errors.

Output:
- rc11.rs: Step J WeakMemoryRace script uses preamble + mo_cmds + rf_cmds + Assert(BoolLit(true))
- weak_memory_litmus.rs: test_relaxed_data_race_detected calls Z3 and asserts SAT
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-wmm03-race-detection-fix/26-CONTEXT.md
@.planning/phases/26-wmm03-race-detection-fix/26-RESEARCH.md
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Fix WeakMemoryRace VC body in rc11.rs (RED → GREEN)</name>
  <files>crates/analysis/src/concurrency/rc11.rs</files>
  <action>
RED phase — confirm existing test_relaxed_data_race_detected does NOT call Z3 (it just checks VC existence). Add Z3 SAT assertion to the test first (see Task 2 below) — it will fail because the VC returns UNSAT with the current bug.

GREEN phase — fix the bug at line 572 of rc11.rs in generate_rc11_vcs(), Step J (WeakMemoryRace VC construction):

BEFORE (buggy):
```rust
let mut script = Script::new();
script.extend(preamble.clone());
script.push(Command::Assert(Term::BoolLit(false)));  // ALWAYS UNSAT — BUG
script.push(Command::CheckSat);
```

AFTER (fixed):
```rust
let mut script = Script::new();
script.extend(preamble.clone());
script.extend(mo_cmds.clone());   // total-order constraints on mo_order
script.extend(rf_cmds.clone());   // rf functional constraints
// Assert BoolLit(true): preamble+mo+rf constraints are satisfiable;
// Z3 returns sat => race detected => driver reports error (verified:false)
script.push(Command::Assert(Term::BoolLit(true)));
script.push(Command::CheckSat);
```

Context:
- `preamble` is built earlier in generate_rc11_vcs() and contains SetLogic, DeclareConst for mo_order/rf, and RC11 axiom asserts (coherence, atomicity, hb transitivity)
- `mo_cmds` contains the total-order (trichotomy + irreflexivity) and initial-store-first axioms
- `rf_cmds` contains the rf-functional constraint
- The candidate pair (opi, opj) passes all filters: same location, different threads, at least one write, both Relaxed, hb=false in both directions — the race is structurally established
- The violation-detection semantics: assert the context is satisfiable (SAT = race exists), mirror WeakMemoryCoherence pattern

DO NOT change: the filtering logic (lines 543-568), the VcLocation construction, the description format, or any other part of generate_rc11_vcs(). This is a surgical one-section fix.

After the fix, run `cargo test -p rust-fv-analysis --test weak_memory_litmus test_relaxed_data_race_detected` — it must pass with SAT assertion.
  </action>
  <verify>
cargo test -p rust-fv-analysis --test weak_memory_litmus test_relaxed_data_race_detected -- --nocapture 2>&1 | tail -20

Expected: test passes, output shows "Expected SAT (race detected)" assertion succeeds.

Also verify no regressions:
cargo test -p rust-fv-analysis --test weak_memory_litmus 2>&1 | tail -5

All litmus tests must still pass (the fix only affects WeakMemoryRace VC body, not coherence/atomicity VCs).
  </verify>
  <done>
- rc11.rs Step J no longer has Assert(BoolLit(false))
- rc11.rs Step J has: script.extend(mo_cmds.clone()); script.extend(rf_cmds.clone()); script.push(Command::Assert(Term::BoolLit(true)));
- All weak_memory_litmus tests pass (no regressions on coherence/atomicity tests)
  </done>
</task>

<task type="tdd">
  <name>Task 2: Update test_relaxed_data_race_detected to assert Z3 SAT result</name>
  <files>crates/analysis/tests/weak_memory_litmus.rs</files>
  <action>
Update `test_relaxed_data_race_detected` (line 1487) to call Z3 and assert SAT. This closes the test gap where the test validated VC structure but not solver behavior.

Current test (just checks VC exists):
```rust
fn test_relaxed_data_race_detected() {
    let func = make_litmus_function(...);
    let vcs = vcgen::generate_concurrency_vcs(&func);
    let race_vcs: Vec<_> = vcs.iter()
        .filter(|vc| vc.location.vc_kind == VcKind::WeakMemoryRace)
        .collect();
    assert!(!race_vcs.is_empty(), "Expected WeakMemoryRace VC ...");
}
```

Updated test (calls Z3, asserts SAT):
```rust
fn test_relaxed_data_race_detected() {
    let solver = solver_or_skip();  // ADD: requires Z3, skips if unavailable
    let func = make_litmus_function(
        "data_race_test",
        vec![
            AtomicOp {
                kind: AtomicOpKind::Store,
                ordering: AtomicOrdering::Relaxed,
                atomic_place: Place::local("x"),
                value: Some(Operand::Constant(Constant::Int(1, IntTy::I32))),
                thread_id: 0,
            },
            AtomicOp {
                kind: AtomicOpKind::Store,
                ordering: AtomicOrdering::Relaxed,
                atomic_place: Place::local("x"),
                value: Some(Operand::Constant(Constant::Int(2, IntTy::I32))),
                thread_id: 1,
            },
        ],
    );

    let vcs = vcgen::generate_concurrency_vcs(&func);

    let race_vcs: Vec<_> = vcs
        .iter()
        .filter(|vc| vc.location.vc_kind == VcKind::WeakMemoryRace)
        .collect();

    assert!(
        !race_vcs.is_empty(),
        "Expected WeakMemoryRace VC for two Relaxed writes to same location from different threads. \
         Got VCs: {:?}",
        vcs.iter()
            .map(|vc| format!("{:?}: {}", vc.location.vc_kind, vc.description))
            .collect::<Vec<_>>()
    );

    // NEW: verify Z3 returns SAT (race actually detected, not silently hidden)
    let script_text = race_vcs[0].script.to_string();
    let result = solver.check_sat_raw(&script_text).expect("Z3 solver error on WeakMemoryRace VC");
    assert!(
        matches!(result, SolverResult::Sat(_)),
        "Expected SAT (race detected) for WeakMemoryRace VC — got {result:?}. \
         If UNSAT, the race VC formula is wrong (may still have BoolLit(false) stub)."
    );
}
```

Note: `solver_or_skip()` is already defined at line 43 of weak_memory_litmus.rs. `SolverResult` and `Z3Solver` are already imported at line 37. No new imports needed.

This task is written BEFORE the rc11.rs fix (RED phase: test fails because VC is UNSAT). After Task 1 fix (GREEN phase: test passes because VC is SAT).
  </action>
  <verify>
cargo test -p rust-fv-analysis --test weak_memory_litmus test_relaxed_data_race_detected -- --nocapture 2>&1 | tail -10

Expected after Task 1 fix: "test test_relaxed_data_race_detected ... ok"

Run full litmus suite to confirm no regressions:
cargo test -p rust-fv-analysis --test weak_memory_litmus 2>&1 | grep -E "^test |FAILED|error"
  </verify>
  <done>
- test_relaxed_data_race_detected calls solver_or_skip() at the top
- test_relaxed_data_race_detected asserts matches!(result, SolverResult::Sat(_)) on the WeakMemoryRace VC
- Full weak_memory_litmus test suite passes with 0 failures
  </done>
</task>

</tasks>

<verification>
Run the full analysis test suite:
cargo test -p rust-fv-analysis 2>&1 | tail -10

All tests must pass. WeakMemoryRace VC must return SAT when sent to Z3. No regressions on the 8 canonical C11 litmus tests (CoRR, CoRW, CoWR, CoWW, SB, LB, MP, IRIW).

Run clippy:
cargo clippy -p rust-fv-analysis 2>&1 | grep "^error"

No new clippy errors.
</verification>

<success_criteria>
- rc11.rs: WeakMemoryRace VC script contains mo_cmds, rf_cmds, and Assert(BoolLit(true)) — NOT Assert(BoolLit(false))
- test_relaxed_data_race_detected: calls solver_or_skip() and asserts SolverResult::Sat(_)
- cargo test -p rust-fv-analysis: all tests pass, 0 failures
- cargo clippy -p rust-fv-analysis: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-wmm03-race-detection-fix/26-01-SUMMARY.md`
</output>

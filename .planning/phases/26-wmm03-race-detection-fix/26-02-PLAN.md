---
phase: 26-wmm03-race-detection-fix
plan: 02
type: execute
wave: 2
depends_on:
  - 26-01
files_modified:
  - crates/driver/src/diagnostics.rs
  - crates/driver/tests/wmm_race_e2e.rs
autonomous: true
requirements:
  - WMM-03

must_haves:
  truths:
    - "Users see actionable help text when a weak memory data race error is reported"
    - "WeakMemoryRace failures trigger the bounded concurrency warning (same as DataRaceFreedom)"
    - "End-to-end driver pipeline: two Relaxed atomic stores to same location → verify_functions_parallel returns verified:false with WeakMemoryRace failure"
  artifacts:
    - path: "crates/driver/src/diagnostics.rs"
      provides: "suggest_fix() arm for WeakMemoryRace + WeakMemoryRace in bounded concurrency warning"
      contains: "WeakMemoryRace => Some("
    - path: "crates/driver/tests/wmm_race_e2e.rs"
      provides: "E2E driver integration test proving race surfaces through full pipeline"
      contains: "verify_functions_parallel"
  key_links:
    - from: "crates/driver/tests/wmm_race_e2e.rs"
      to: "rust_fv_driver::parallel::verify_functions_parallel"
      via: "VerificationTask with concurrent IR function"
      pattern: "verify_functions_parallel"
    - from: "verify_functions_parallel SAT result"
      to: "VerificationResult { verified: false }"
      via: "parallel.rs SAT handling (already correct)"
      pattern: "verified.*false"
---

<objective>
Complete the WMM-03 fix by (1) adding WeakMemoryRace to diagnostics.rs for consistent error UX and (2) adding an end-to-end driver integration test that proves a Relaxed data race surfaces as a verification failure through the full pipeline.

Purpose: Plan 01 fixes the VC formula and unit test. This plan closes the loop: UX completeness (suggest_fix + bounded warning) and E2E proof that the driver pipeline correctly surfaces race errors from input IR → verify_functions_parallel → failures list.

Output:
- diagnostics.rs: suggest_fix() has WeakMemoryRace arm; report_text_only() bounded warning includes WeakMemoryRace
- crates/driver/tests/wmm_race_e2e.rs: E2E integration test with verify_functions_parallel asserting race failure
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-wmm03-race-detection-fix/26-CONTEXT.md
@.planning/phases/26-wmm03-race-detection-fix/26-RESEARCH.md
@.planning/phases/26-wmm03-race-detection-fix/26-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete diagnostics.rs error UX for WeakMemoryRace</name>
  <files>crates/driver/src/diagnostics.rs</files>
  <action>
Two targeted additions to diagnostics.rs:

**Addition 1: suggest_fix() arm for WeakMemoryRace (line ~529)**

Find the `suggest_fix()` function (line 450). Locate the `ChannelSafety` arm followed by `_ => None`. Insert a new arm for `WeakMemoryRace` BEFORE `_ => None`:

```rust
VcKind::WeakMemoryRace => Some(
    "Weak memory data race: use Release/Acquire ordering instead of Relaxed, or protect \
     access with a Mutex. Relaxed atomics provide no ordering guarantees between threads."
        .to_string(),
),
_ => None,
```

Per user locked decision: "Follow existing DataRaceFreedom error formatting for consistency." The help message must explain the problem (Relaxed = no ordering guarantees) and provide actionable remediation (Release/Acquire or Mutex).

**Addition 2: WeakMemoryRace in bounded concurrency warning condition (line ~199)**

Find `report_text_only()` → bounded concurrency warning condition (lines 199-203):

```rust
// BEFORE:
if failure.vc_kind == VcKind::DataRaceFreedom
    || failure.vc_kind == VcKind::LockInvariant
    || failure.vc_kind == VcKind::Deadlock
    || failure.vc_kind == VcKind::ChannelSafety
{

// AFTER: add WeakMemoryRace
if failure.vc_kind == VcKind::DataRaceFreedom
    || failure.vc_kind == VcKind::LockInvariant
    || failure.vc_kind == VcKind::Deadlock
    || failure.vc_kind == VcKind::ChannelSafety
    || failure.vc_kind == VcKind::WeakMemoryRace
{
```

DO NOT touch: the existing arms in suggest_fix() for other VcKinds, the report_with_ariadne function, format_data_race_help(), or any other diagnostics logic. These are additive-only changes.

After changes, run `cargo clippy -p rust-fv-driver 2>&1 | grep "^error"` — must be clean.
  </action>
  <verify>
cargo clippy -p rust-fv-driver 2>&1 | grep "^error"
# Expected: (empty — no errors)

cargo test -p rust-fv-driver --lib 2>&1 | tail -5
# Expected: all tests pass

# Confirm the new arm exists:
grep -n "WeakMemoryRace => Some" crates/driver/src/diagnostics.rs
# Expected: line showing the new suggest_fix arm
  </verify>
  <done>
- suggest_fix() has VcKind::WeakMemoryRace arm returning Some(help text) before _ => None
- report_text_only() bounded warning condition includes || failure.vc_kind == VcKind::WeakMemoryRace
- cargo clippy -p rust-fv-driver: 0 errors
- cargo test -p rust-fv-driver --lib: all tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E driver integration test — Relaxed race surfaces as failure</name>
  <files>crates/driver/tests/wmm_race_e2e.rs</files>
  <action>
Create a new integration test file `crates/driver/tests/wmm_race_e2e.rs` that tests the FULL pipeline: IR function with two concurrent Relaxed stores → verify_functions_parallel() → failures list contains a WeakMemoryRace entry.

Model this after `crates/driver/tests/ghost_predicate_e2e.rs` — use the same verify_functions_parallel pattern.

```rust
//! End-to-end driver-level integration test for WMM-03 weak memory race detection.
//!
//! Tests the FULL pipeline: IR Function with concurrent Relaxed atomics
//! → VerificationTask → verify_functions_parallel() → VerificationResult { verified: false }
//! → callbacks race failure.
//!
//! Distinct from crates/analysis/tests/weak_memory_litmus.rs which tests at the
//! analysis (VC generation + Z3) level. This test validates the driver pipeline
//! correctly propagates race errors to users.

use rust_fv_analysis::ir::{
    AtomicOp, AtomicOpKind, AtomicOrdering, BasicBlock, Constant, Contracts, Function,
    IntTy, Local, Operand, Place, Statement, Terminator, Ty,
};
use rust_fv_analysis::vcgen::VcKind;
use rust_fv_driver::cache::VcCache;
use rust_fv_driver::invalidation::{InvalidationDecision, InvalidationReason};
use rust_fv_driver::parallel::{VerificationTask, verify_functions_parallel};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

fn temp_cache_dir(name: &str) -> PathBuf {
    let mut dir = std::env::temp_dir();
    dir.push(format!("rust-fv-wmm-e2e-{}-{}", name, std::process::id()));
    let _ = std::fs::remove_dir_all(&dir);
    dir
}

/// Build a minimal IR function with two concurrent Relaxed atomic stores to the same location.
/// Thread 0 stores 1 to `x`, thread 1 stores 2 to `x` — a textbook Relaxed data race.
fn make_relaxed_race_func() -> Function {
    Function {
        name: "relaxed_race".to_string(),
        params: vec![],
        return_local: Local::new("_0", Ty::Unit),
        locals: vec![],
        basic_blocks: vec![BasicBlock {
            statements: vec![
                Statement::AtomicStore(AtomicOp {
                    kind: AtomicOpKind::Store,
                    ordering: AtomicOrdering::Relaxed,
                    atomic_place: Place::local("x"),
                    value: Some(Operand::Constant(Constant::Int(1, IntTy::I32))),
                    thread_id: 0,
                }),
                Statement::AtomicStore(AtomicOp {
                    kind: AtomicOpKind::Store,
                    ordering: AtomicOrdering::Relaxed,
                    atomic_place: Place::local("x"),
                    value: Some(Operand::Constant(Constant::Int(2, IntTy::I32))),
                    thread_id: 1,
                }),
            ],
            terminator: Terminator::Return,
        }],
        contracts: Contracts::default(),
        loops: vec![],
        coroutine_info: None,
        is_unsafe: false,
        source_names: HashMap::new(),
    }
}

/// WMM-03: A function with two concurrent Relaxed atomic stores to the same location
/// must be reported as NOT verified (race detected) by the driver pipeline.
#[test]
fn test_relaxed_race_surfaces_as_driver_failure() {
    // Check Z3 is available — skip if not (same pattern as ghost_predicate_e2e.rs)
    if std::process::Command::new("z3")
        .arg("--version")
        .output()
        .is_err()
    {
        eprintln!("Skipping: z3 not found in PATH");
        return;
    }

    let func = make_relaxed_race_func();
    let cache_dir = temp_cache_dir("relaxed-race");
    let cache = Arc::new(VcCache::new(&cache_dir));

    let task = VerificationTask {
        function: func,
        cache: Arc::clone(&cache),
        invalidation: InvalidationDecision {
            reason: InvalidationReason::NewFunction,
            must_reverify: true,
        },
        ghost_pred_db: Arc::new(rust_fv_analysis::ghost_predicate_db::GhostPredicateDatabase::new()),
        source_location_map: HashMap::new(),
    };

    let results = verify_functions_parallel(vec![task])
        .expect("verify_functions_parallel failed");

    // At least one result must be verified:false with WeakMemoryRace vc_kind
    let race_failures: Vec<_> = results
        .iter()
        .filter(|r| !r.verified && r.vc_location.vc_kind == VcKind::WeakMemoryRace)
        .collect();

    assert!(
        !race_failures.is_empty(),
        "Expected WeakMemoryRace failure in driver results for two concurrent Relaxed stores. \
         Got results: {:?}",
        results.iter()
            .map(|r| format!("verified={} kind={:?}", r.verified, r.vc_location.vc_kind))
            .collect::<Vec<_>>()
    );

    // Cleanup
    let _ = std::fs::remove_dir_all(&cache_dir);
}
```

IMPORTANT before writing the file: Read `crates/driver/tests/ghost_predicate_e2e.rs` and `crates/analysis/ir/mod.rs` to confirm:
1. The exact IR struct field names (Function, BasicBlock, Contracts, etc.) — use the same field pattern as ghost_predicate_e2e.rs
2. Whether `Statement::AtomicStore` is the correct variant or if atomic ops are embedded differently in IR
3. Whether `Contracts::default()` is available or if it needs to be constructed explicitly
4. The exact type of `source_location_map` in VerificationTask

Adjust the test's IR construction to match actual field names/types. The test logic (asserting race_failures is non-empty) must not be changed. Only adjust struct construction to compile.

Run `cargo test -p rust-fv-driver --test wmm_race_e2e` to validate.
  </action>
  <verify>
cargo test -p rust-fv-driver --test wmm_race_e2e -- --nocapture 2>&1 | tail -20

Expected: "test test_relaxed_race_surfaces_as_driver_failure ... ok"

Also run full driver tests to confirm no regressions:
cargo test -p rust-fv-driver 2>&1 | tail -5

cargo clippy -p rust-fv-driver 2>&1 | grep "^error"
# Expected: (empty)
  </verify>
  <done>
- crates/driver/tests/wmm_race_e2e.rs exists and compiles
- test_relaxed_race_surfaces_as_driver_failure passes (race failure appears in results)
- Full driver test suite passes with 0 failures
- cargo clippy -p rust-fv-driver: 0 errors
  </done>
</task>

</tasks>

<verification>
Full test suite across all relevant crates:
cargo test -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -10

Run all weak memory specific tests:
cargo test -p rust-fv-analysis --test weak_memory_litmus 2>&1 | grep -E "FAILED|ok|error"
cargo test -p rust-fv-driver --test wmm_race_e2e 2>&1 | grep -E "FAILED|ok|error"

Linting:
cargo clippy -p rust-fv-analysis -p rust-fv-driver 2>&1 | grep "^error"

All 4 WMM-03 success criteria:
1. WeakMemoryRace VC body has race-existence constraints (not Assert(BoolLit(false))) — verified by rc11.rs inspection
2. Driver pipeline interprets SAT as race error — verified by test_relaxed_race_surfaces_as_driver_failure
3. test_relaxed_data_race_detected asserts Z3 SAT — verified by weak_memory_litmus test
4. E2E integration test proves race error surfaces end-to-end — verified by wmm_race_e2e.rs test
</verification>

<success_criteria>
- diagnostics.rs: VcKind::WeakMemoryRace arm exists in suggest_fix() with actionable help text
- diagnostics.rs: report_text_only() bounded warning condition includes WeakMemoryRace
- wmm_race_e2e.rs: test_relaxed_race_surfaces_as_driver_failure passes with Z3 available
- cargo test -p rust-fv-analysis -p rust-fv-driver: all tests pass, 0 failures
- cargo clippy -p rust-fv-analysis -p rust-fv-driver: 0 errors
- WMM-03 requirement: verified — all 4 success criteria from ROADMAP.md satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/26-wmm03-race-detection-fix/26-02-SUMMARY.md`
</output>

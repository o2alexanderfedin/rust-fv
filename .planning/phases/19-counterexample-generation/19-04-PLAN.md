---
phase: 19-counterexample-generation
plan: 04
type: execute
wave: 2
depends_on:
  - 19-01
files_modified:
  - crates/driver/src/json_output.rs
  - crates/driver/src/callbacks.rs
  - vscode-extension/src/verifier.ts
autonomous: true
requirements:
  - CEX-04

must_haves:
  truths:
    - "`--output-format=json` output includes a structured `counterexample` field on verification failure with `variables`, `failing_location`, `vc_kind`, and `violated_spec` keys"
    - "Each variable entry in JSON `counterexample.variables` has both `display` (human string) and `raw` (typed JSON tree) fields"
    - "The old flat `counterexample: [{variable, value}]` field is preserved alongside the new structured schema for backward compatibility with VSCode extension"
    - "VSCode `verifier.ts` TypeScript interfaces include the new `JsonCounterexample` and `JsonCexVariable` types matching the new Rust schema exactly"
    - "Variables with initial and at-failure values appear as a single JSON entry with `initial` and `at_failure` sub-objects"
    - "`violated_spec` field contains the text of the failing `#[ensures]`/`#[assert]` clause"
  artifacts:
    - path: "crates/driver/src/json_output.rs"
      provides: "JsonCounterexample, JsonCexVariable, JsonCexValue, JsonLocation structs and serialization"
      contains: "JsonCounterexample"
    - path: "crates/driver/src/callbacks.rs"
      provides: "Populates JsonFailure.counterexample_v2 from structured model data using cex_render"
      contains: "counterexample_v2"
    - path: "vscode-extension/src/verifier.ts"
      provides: "TypeScript interfaces matching updated JSON schema"
      contains: "JsonCounterexample"
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/json_output.rs"
      via: "JsonFailure.counterexample_v2 populated from cex_render::render_counterexample output"
      pattern: "counterexample_v2"
    - from: "crates/driver/src/json_output.rs"
      to: "vscode-extension/src/verifier.ts"
      via: "TypeScript interface mirrors Rust struct field names exactly"
      pattern: "JsonCounterexample"
---

<objective>
Extend `json_output.rs` with the structured `JsonCounterexample` schema (per CONTEXT.md decisions) and update the VSCode extension TypeScript interfaces to match. The new schema is additive — old flat `counterexample` field is kept for backward compatibility.

Purpose: CEX-04 requires machine-consumable structured counterexample output. IDEs and CI tools need to parse variable names, types, and typed values without screen-scraping display strings.

Output: Extended `json_output.rs` with new types; `callbacks.rs` populating the new field; `verifier.ts` with updated TypeScript interfaces.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-counterexample-generation/19-RESEARCH.md
@crates/driver/src/json_output.rs
@crates/driver/src/callbacks.rs
@vscode-extension/src/verifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JsonCounterexample types to json_output.rs and populate in callbacks.rs</name>
  <files>
    crates/driver/src/json_output.rs
    crates/driver/src/callbacks.rs
  </files>
  <action>
    In `json_output.rs`, add the following new types after the existing `JsonAssignment` struct. These implement the CONTEXT.md-specified JSON schema exactly:

    ```rust
    /// Structured counterexample with typed variables and metadata (v2 schema).
    #[derive(Serialize, Deserialize)]
    pub struct JsonCounterexample {
        pub variables: Vec<JsonCexVariable>,
        pub failing_location: JsonLocation,
        pub vc_kind: String,
        pub violated_spec: Option<String>,
    }

    /// A single variable in a counterexample (may have single or dual initial/at_failure values).
    #[derive(Serialize, Deserialize)]
    pub struct JsonCexVariable {
        pub name: String,
        #[serde(rename = "type")]
        pub ty: String,
        /// Present when variable has a single value at point of failure.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub display: Option<String>,
        /// Present when variable has a single value at point of failure.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub raw: Option<serde_json::Value>,
        /// Present when variable has an initial (parameter entry) value distinct from failure value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub initial: Option<JsonCexValue>,
        /// Present when variable has a value at the point of failure distinct from its initial value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub at_failure: Option<JsonCexValue>,
    }

    /// A single typed value with display string and raw JSON tree.
    #[derive(Serialize, Deserialize)]
    pub struct JsonCexValue {
        pub display: String,
        pub raw: serde_json::Value,
    }

    /// Source location with file, line, and column.
    #[derive(Serialize, Deserialize)]
    pub struct JsonLocation {
        pub file: String,
        pub line: usize,
        pub column: usize,
    }
    ```

    Add `counterexample_v2: Option<JsonCounterexample>` field to `JsonFailure` (keep the existing `counterexample: Option<Vec<JsonAssignment>>` field unchanged for backward compatibility):
    ```rust
    pub struct JsonFailure {
        // ... existing fields unchanged ...
        pub counterexample: Option<Vec<JsonAssignment>>,  // keep — backward compat
        pub counterexample_v2: Option<JsonCounterexample>, // new — rich schema
        // ... rest unchanged ...
    }
    ```

    In `callbacks.rs`, when building `JsonFailure` on verification failure, populate `counterexample_v2` using `cex_render::render_counterexample`:
    - Call `render_counterexample` with the structured model pairs (from `VcOutcome::Sat(Some(pairs))` from Plan 01), `source_names`, `locals`, and `params` from the IR function.
    - Map `Vec<CexVariable>` → `Vec<JsonCexVariable>` by converting each `CexVariable` field directly.
    - Set `failing_location` from `VcLocation.source_file` / `source_line` / `source_column` (use `0` for column if `None`).
    - Set `vc_kind` from the VcKind string (use existing `vc_kind_description` or just `format!("{:?}", vc_kind).to_lowercase()`).
    - Set `violated_spec` from `VcLocation.contract_text`.

    If `VcOutcome::Sat(None)` (no model from solver), set `counterexample_v2: None`.

    Add unit tests in `json_output.rs` `#[cfg(test)]` block:
    - Test that `JsonCounterexample` serializes to the expected JSON shape matching CONTEXT.md spec
    - Test `skip_serializing_if` works: a variable with `display`/`raw` only (no `initial`/`at_failure`) should not emit `"initial": null` in JSON

    Verify: `cargo test --package rust-fv-driver -- json_output 2>&1 | tail -20` — all json_output tests pass.
  </action>
  <verify>cargo test --package rust-fv-driver -- json_output 2>&amp;1 | tail -20 &amp;&amp; cargo build --package rust-fv-driver 2>&amp;1 | tail -20 &amp;&amp; grep -n "JsonCounterexample" crates/driver/src/json_output.rs | head -5</verify>
  <done>JsonCounterexample, JsonCexVariable, JsonCexValue, JsonLocation structs exist in json_output.rs; JsonFailure has counterexample_v2 field alongside existing counterexample field; callbacks.rs populates counterexample_v2 from cex_render output; all json_output tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Update VSCode extension TypeScript interfaces to match new JSON schema</name>
  <files>
    vscode-extension/src/verifier.ts
  </files>
  <action>
    Update `vscode-extension/src/verifier.ts` to add TypeScript interfaces matching the new Rust schema. Keep the existing interfaces unchanged for backward compatibility; add new interfaces alongside them.

    Add after the existing `JsonAssignment` interface:

    ```typescript
    /** Structured counterexample with typed variables and metadata (v2 schema). */
    export interface JsonCounterexample {
      variables: JsonCexVariable[];
      failing_location: JsonLocation;
      vc_kind: string;
      violated_spec?: string;
    }

    /** A single variable in a counterexample. */
    export interface JsonCexVariable {
      name: string;
      type: string;
      /** Present when variable has a single value at point of failure. */
      display?: string;
      /** Present when variable has a single value at point of failure. */
      raw?: unknown;
      /** Present when variable has an initial (parameter entry) value. */
      initial?: JsonCexValue;
      /** Present when variable has a value at point of failure distinct from initial. */
      at_failure?: JsonCexValue;
    }

    /** A single typed value with display string and raw JSON tree. */
    export interface JsonCexValue {
      display: string;
      raw: unknown;
    }

    /** Source location with file, line, and column. */
    export interface JsonLocation {
      file: string;
      line: number;
      column: number;
    }
    ```

    Update `JsonFailure` interface to add the new optional field while keeping `counterexample` unchanged:
    ```typescript
    export interface JsonFailure {
      vc_kind: string;
      description: string;
      contract?: string;
      source_file?: string;
      source_line?: number;
      counterexample?: JsonAssignment[];        // keep — backward compat
      counterexample_v2?: JsonCounterexample;   // new — rich schema
      suggestion?: string;
    }
    ```

    After making changes, verify that TypeScript compiles (if `tsc` is available in the extension directory):
    - `cd vscode-extension && npm run compile 2>&1 | tail -20` OR `npx tsc --noEmit 2>&1 | tail -20`
    - If npm/tsc is not available, verify manually that the interface shapes are syntactically correct.

    No behavioral changes to the extension — this is a type-only update. The extension already reads `counterexample` for the flat list; the new `counterexample_v2` field is available for future extension use.
  </action>
  <verify>grep -n "JsonCounterexample\|counterexample_v2" vscode-extension/src/verifier.ts &amp;&amp; (cd vscode-extension &amp;&amp; npx tsc --noEmit 2>&amp;1 | tail -20 || echo "tsc unavailable — interface syntax verified manually")</verify>
  <done>verifier.ts contains JsonCounterexample, JsonCexVariable, JsonCexValue, JsonLocation interfaces; JsonFailure has counterexample_v2 optional field; TypeScript compiles without errors (or syntax is verified correct if tsc unavailable)</done>
</task>

</tasks>

<verification>
cargo test --workspace 2>&amp;1 | tail -30
cargo clippy --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -10
# Confirm new types exist:
grep -n "JsonCounterexample\|JsonCexVariable\|JsonCexValue\|JsonLocation" crates/driver/src/json_output.rs
# Confirm backward compat — old field still there:
grep -n "counterexample:" crates/driver/src/json_output.rs
# Confirm new field added:
grep -n "counterexample_v2" crates/driver/src/json_output.rs
# Confirm TypeScript updated:
grep -n "JsonCounterexample\|counterexample_v2" vscode-extension/src/verifier.ts
</verification>

<success_criteria>
- `json_output.rs` contains `JsonCounterexample`, `JsonCexVariable`, `JsonCexValue`, `JsonLocation` structs with `#[derive(Serialize, Deserialize)]`
- `JsonFailure` has both `counterexample: Option&lt;Vec&lt;JsonAssignment&gt;&gt;` (backward compat) and `counterexample_v2: Option&lt;JsonCounterexample&gt;` (new schema)
- `callbacks.rs` populates `counterexample_v2` from `cex_render::render_counterexample` output
- `verifier.ts` has `JsonCounterexample`, `JsonCexVariable`, `JsonCexValue`, `JsonLocation` TypeScript interfaces
- `verifier.ts` `JsonFailure` has `counterexample_v2?: JsonCounterexample` field
- All workspace tests pass: `cargo test --workspace`
- No clippy warnings: `cargo clippy --package rust-fv-driver -- -D warnings`
</success_criteria>

<output>
After completion, create `.planning/phases/19-counterexample-generation/19-04-SUMMARY.md` with:
- New JSON schema structure with example output
- TypeScript interfaces added
- Backward compatibility approach
- Test results
- Any deviations from the plan
</output>

---
phase: 19-counterexample-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/differential.rs
  - crates/driver/src/callbacks.rs
  - crates/driver/src/mir_converter.rs
  - crates/analysis/src/ir.rs
autonomous: true
requirements:
  - CEX-01

must_haves:
  truths:
    - "VcOutcome::Sat carries Vec<(String,String)> structured pairs instead of a flat string"
    - "mir_converter::convert_mir returns source_names map (SSA index → Rust source name) built from body.var_debug_info"
    - "IR Function carries source_names: HashMap<String,String> field accessible downstream"
    - "Ghost locals are filtered: mir_converter marks is_ghost=true for locals identified as ghost via HIR attribute scan"
    - "Source location (file + line) is plumbed from MIR SourceInfo spans into VcLocation.source_file / source_line"
  artifacts:
    - path: "crates/analysis/src/differential.rs"
      provides: "VcOutcome::Sat(Option<Vec<(String,String)>>) — structured model pairs"
      contains: "Vec<(String, String)>"
    - path: "crates/analysis/src/ir.rs"
      provides: "Function.source_names field"
      contains: "source_names"
    - path: "crates/driver/src/mir_converter.rs"
      provides: "var_debug_info harvest + ghost detection"
      contains: "var_debug_info"
    - path: "crates/driver/src/callbacks.rs"
      provides: "Structured model pass-through, source location plumbing"
      contains: "source_names"
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/differential.rs"
      via: "VcOutcome::Sat carries Vec<(String,String)>"
      pattern: "VcOutcome::Sat"
    - from: "crates/driver/src/mir_converter.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Function.source_names populated from body.var_debug_info"
      pattern: "var_debug_info"
---

<objective>
Lay the structured data foundation for counterexample generation: change VcOutcome::Sat to carry structured (name, value) pairs instead of a flat string, harvest Rust source names from rustc's var_debug_info, add source_names to IR Function, plumb source location from MIR spans into VcLocation, and mark ghost locals correctly.

Purpose: Every downstream plan (cex_render, ariadne labels, JSON output) depends on having structured model data and correct name/location information. This plan creates that foundation via TDD.

Output: Updated differential.rs (VcOutcome type), ir.rs (Function.source_names), mir_converter.rs (var_debug_info + ghost detection), callbacks.rs (structured pass-through + source plumbing). All existing tests continue to pass.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-counterexample-generation/19-RESEARCH.md
@crates/analysis/src/differential.rs
@crates/analysis/src/ir.rs
@crates/driver/src/mir_converter.rs
@crates/driver/src/callbacks.rs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Change VcOutcome::Sat to carry structured model pairs</name>
  <files>
    crates/analysis/src/differential.rs
    crates/driver/src/callbacks.rs
  </files>
  <feature>
    <name>Structured model in VcOutcome</name>
    <files>crates/analysis/src/differential.rs, crates/driver/src/callbacks.rs</files>
    <behavior>
      VcOutcome::Sat carries Option&lt;Vec&lt;(String, String)&gt;&gt; (variable name, raw value string pairs) instead of Option&lt;String&gt;.

      Cases:
      - Solver returns SAT with no model → VcOutcome::Sat(None)
      - Solver returns SAT with model containing {x: "#x00000005", b: "true"} → VcOutcome::Sat(Some(vec![("x".to_string(), "#x00000005".to_string()), ("b".to_string(), "true".to_string())]))
      - Solver returns UNSAT → VcOutcome::Unsat (unchanged)
      - Solver returns Unknown → VcOutcome::Unknown (unchanged)

      In callbacks.rs Z3SolverAdapter::check: instead of serializing model to string with join(", "), pass m.assignments.clone() directly as Vec&lt;(String,String)&gt;.

      In callbacks.rs where counterexample is consumed (lines ~663-675): remove the fragile split(", ") re-parser; use the Vec&lt;(String,String)&gt; directly.

      All callsites that pattern-match on VcOutcome::Sat(Some(s)) and format_model_detail in differential.rs must be updated to handle Vec instead of String. The display formatting for the differential equivalence report can join pairs as "{k} = {v}" for the text message.
    </behavior>
    <implementation>
      RED: Write test in differential.rs tests module asserting that MockSolver returning Sat(Some(vec![("x".to_string(), "5".to_string())])) produces an EquivalenceResult where the model detail contains "x = 5".
      GREEN: Change VcOutcome enum, update all match arms, update Z3SolverAdapter, update test MockSolver implementations.
      REFACTOR: Ensure format_model_detail and outcome_name still work correctly; remove dead string parsing code in callbacks.rs.
    </implementation>
  </feature>
  <verify>cargo test --package rust-fv-analysis -- differential 2>&amp;1 | tail -20 &amp;&amp; cargo test --package rust-fv-driver 2>&amp;1 | tail -20</verify>
  <done>All differential tests pass; no "split(", ")" string parsing of models remains in callbacks.rs; VcOutcome::Sat type signature is Vec&lt;(String,String)&gt;</done>
</task>

<task type="tdd">
  <name>Task 2: Harvest var_debug_info + add source_names to IR Function + ghost detection + source location plumbing</name>
  <files>
    crates/analysis/src/ir.rs
    crates/driver/src/mir_converter.rs
    crates/driver/src/callbacks.rs
  </files>
  <feature>
    <name>SSA name recovery and source location</name>
    <files>crates/analysis/src/ir.rs, crates/driver/src/mir_converter.rs, crates/driver/src/callbacks.rs</files>
    <behavior>
      IR Function gains a new field: `pub source_names: std::collections::HashMap&lt;String, String&gt;` mapping SSA name ("_1") to Rust source name ("x").

      mir_converter::convert_mir populates source_names by iterating body.var_debug_info:
      - For each VarDebugInfo where value is VarDebugInfoContents::Place(p) and p.projection.is_empty():
        insert("_{idx}", info.name.to_string()) where idx = p.local.as_usize()
      - Skip composite/const debug info entries (non-Place or non-empty projection)

      Ghost detection: scan HIR attributes for each function (passed via a new parameter `ghost_locals: &HashSet&lt;usize&gt;`) to mark Local.is_ghost = true for locals whose debug_info name matches a ghost parameter. Simpler approach: in callbacks.rs after extract_contracts, build a ghost_locals set from functions annotated with ghost attribute markers; pass into convert_mir. If this is complex, simpler fallback: mark is_ghost based on whether any local's debug name starts with "__ghost_" (the proc macro convention from ir.rs:396).

      Source location: add `pub source_column: Option&lt;usize&gt;` to VcLocation. In callbacks.rs, after convert_mir, iterate the function's basic_blocks to find the MIR SourceInfo spans and populate VcLocation.source_file and source_line from tcx.sess.source_map().lookup_char_pos(span.lo()). Store file as the absolute path string. The simplest correct approach: pass `tcx` into a new helper `fill_vc_locations(tcx, func, vcs)` in callbacks.rs that post-fills source info on each VcLocation.

      Cases (for tests — use unit tests in ir.rs and mir_converter.rs):
      - Function with param x: i32 → source_names["_1"] == "x"
      - Function with local let y: i32 → source_names["_N"] == "y" for the correct local index
      - source_names is empty for functions with no debug info
    </behavior>
    <implementation>
      RED: Write test asserting source_names is populated after convert_mir for a synthetic MIR body with var_debug_info entries. (Since we cannot construct rustc TyCtxt in unit tests, write an integration-style test that verifies on a real function via cargo verify; alternatively, write a unit test for the name-map building logic extracted into a standalone helper fn build_source_names(debug_infos: &[VarDebugInfo]) → HashMap&lt;String,String&gt;.)
      GREEN: Add source_names to ir::Function, implement build_source_names helper, call it from convert_mir, wire is_ghost detection via debug name prefix check, add fill_vc_locations helper in callbacks.rs.
      REFACTOR: Ensure all existing Function construction sites (in tests) compile after adding source_names field with a default empty HashMap.
    </implementation>
  </feature>
  <verify>cargo build --package rust-fv-driver 2>&amp;1 | tail -30 &amp;&amp; cargo test --package rust-fv-analysis 2>&amp;1 | tail -20 &amp;&amp; cargo test --package rust-fv-driver 2>&amp;1 | tail -20</verify>
  <done>source_names field exists on ir::Function; mir_converter populates it from var_debug_info; VcLocation.source_file/source_line are populated for real MIR bodies; all tests pass</done>
</task>

</tasks>

<verification>
cargo test --workspace 2>&amp;1 | tail -30
cargo clippy --package rust-fv-analysis --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -20
# Confirm VcOutcome::Sat no longer carries String:
grep -n "VcOutcome::Sat" crates/analysis/src/differential.rs | head -5
# Confirm source_names field exists:
grep -n "source_names" crates/analysis/src/ir.rs
# Confirm var_debug_info is used:
grep -n "var_debug_info" crates/driver/src/mir_converter.rs
</verification>

<success_criteria>
- VcOutcome::Sat(Option&lt;Vec&lt;(String,String)&gt;&gt;) — no String variant remains
- ir::Function has source_names: HashMap&lt;String,String&gt;
- mir_converter harvests var_debug_info (grep confirms)
- Fragile split(", ") model re-parser removed from callbacks.rs
- All workspace tests pass: cargo test --workspace
</success_criteria>

<output>
After completion, create `.planning/phases/19-counterexample-generation/19-01-SUMMARY.md` with:
- What was changed and why
- VcOutcome new type signature
- source_names field location
- Any open issues or deviations from plan
</output>

---
phase: 19-counterexample-generation
plan: 02
type: tdd
wave: 2
depends_on:
  - 19-01
files_modified:
  - crates/driver/src/cex_render.rs
  - crates/driver/src/lib.rs
autonomous: true
requirements:
  - CEX-02

must_haves:
  truths:
    - "Hex bitvectors like `#x00000005` are rendered as `i32: 5` (signed decimal) not raw hex in counterexample output"
    - "Bool SMT values `true`/`false` are rendered as `bool: false` in counterexample output"
    - "Struct model values are rendered as `Point { x: 3, y: -1 }` (fully recursive, no depth truncation)"
    - "Array/Vec/slice elements beyond 10 are truncated with `... (N more)` message"
    - "Enum model values are rendered in Rust Debug format: `Some(42)`, `Ok(Point { x: 3 })`"
    - "Raw pointer model values are rendered as `ptr@0x1 -> i32: 42` (symbolic address + pointee)"
    - "Ghost variables (Local.is_ghost=true) are excluded from rendered counterexample output"
    - "All variables live at point of failure (params + non-ghost locals) are shown"
  artifacts:
    - path: "crates/driver/src/cex_render.rs"
      provides: "Typed SMT value rendering to display string and serde_json::Value"
      exports: ["render_counterexample", "CexVariable", "CexValue", "render_typed_value"]
    - path: "crates/driver/src/lib.rs"
      provides: "cex_render module declaration"
      contains: "mod cex_render"
  key_links:
    - from: "crates/driver/src/cex_render.rs"
      to: "crates/analysis/src/ir.rs"
      via: "CexVariable uses ir::Ty for typed rendering dispatch"
      pattern: "ir::Ty"
    - from: "crates/driver/src/cex_render.rs"
      to: "crates/analysis/src/differential.rs"
      via: "Takes Vec<(String,String)> model pairs from VcOutcome::Sat"
      pattern: "Vec<.String.*String"
---

<objective>
Create `cex_render.rs` — the typed value rendering module that transforms raw SMT model pairs into human-readable Rust-typed counterexample values.

Purpose: CEX-02 requires that developers see `i32: 5` not `#x00000005`. This module is the single rendering engine used by both ariadne terminal output (Plan 03) and JSON output (Plan 04). TDD ensures each rendering rule is exercised before integration.

Output: New `crates/driver/src/cex_render.rs` with `render_counterexample` public API; `lib.rs` updated to declare the module.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-counterexample-generation/19-RESEARCH.md
@crates/analysis/src/ir.rs
@crates/driver/src/lib.rs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Implement cex_render.rs typed value rendering module</name>
  <files>
    crates/driver/src/cex_render.rs
    crates/driver/src/lib.rs
  </files>
  <feature>
    <name>Typed SMT value rendering</name>
    <files>crates/driver/src/cex_render.rs</files>
    <behavior>
      Public API:

      ```rust
      pub struct CexValue {
          pub display: String,
          pub raw: serde_json::Value,
      }

      pub struct CexVariable {
          pub name: String,
          pub ty: String,           // Rust type name string
          pub display: String,      // final rendered display
          pub raw: serde_json::Value,
          pub initial: Option<CexValue>,    // for SSA multi-version vars
          pub at_failure: Option<CexValue>, // for SSA multi-version vars
      }

      pub fn render_counterexample(
          model: &[(String, String)],           // raw (ssa_name, smt_value) pairs
          source_names: &HashMap<String, String>, // ssa→source name map from Plan 01
          locals: &[ir::Local],                  // typed locals for dispatch
          params: &[ir::Local],                  // typed params for dispatch
      ) -> Vec<CexVariable>
      ```

      Rendering rules (all per CONTEXT.md decisions):

      1. `ir::Ty::Int(_)` / `ir::Ty::Uint(_)`: parse bitvector.
         - `#xHEXSTRING` → parse as unsigned hex, reinterpret as signed for `Int` → decimal
         - `#bBINSTRING` → parse as binary bits → same reinterpretation
         - Fallback: use raw string as-is
         - display: `"i32: 5"` or `"u64: 18"` (type prefix then value)

      2. `ir::Ty::Bool`: display `"bool: true"` or `"bool: false"` (value is already `"true"`/`"false"` from Z3)

      3. `ir::Ty::Struct { name, fields }`: recursively render each field using its type;
         format as `"StructName { field1: val1, field2: val2 }"`. No depth limit (CONTEXT.md: fully recursive).

      4. `ir::Ty::Enum { name, .. }`: look up SMT constructor in model string; map to Rust Debug format.
         - Z3 emits constructor application like `(mk-SomeVariant value)` or `(mk-NoneVariant)`
         - Render as `"Some(42)"` or `"None"` (Rust Debug format per CONTEXT.md)
         - If format is unrecognized, fall back to raw string

      5. `ir::Ty::RawPtr(inner)` / `ir::Ty::MutPtr(inner)`: render as `"ptr@0xADDR -> TYPE: VALUE"`.
         - Extract symbolic address from model (Z3 may give `#x00000001` for abstract heap addr)
         - Recursively render pointee value using `inner` type

      6. `ir::Ty::Array` / `ir::Ty::Slice`: collect elements from model; render up to 10.
         - If more than 10: append `"... (N more)"` per CONTEXT.md decision
         - format: `"[val1, val2, ...]"`

      7. Ghost filtering: exclude any local/param where `is_ghost == true` (CONTEXT.md: ghost vars hidden).

      8. Name translation: look up SSA name in `source_names`; use source name if found, keep SSA name otherwise.

      9. SSA multi-version detection: if model contains both a base name and an `_init`-suffixed or `_0`/`_1`-suffixed version of the same source var, produce a single `CexVariable` with `initial` and `at_failure` filled. Otherwise, `display`/`raw` are set directly.

      Cases (for TDD):
      - `("_1", "#x00000005")` with `Ty::Int(4)`, source_names `{"_1": "x"}` → CexVariable { name: "x", ty: "i32", display: "i32: 5", raw: json!(5) }
      - `("_2", "false")` with `Ty::Bool` → CexVariable { name: ..., display: "bool: false", raw: json!(false) }
      - `("_3", "#x0000002a")` with `Ty::Uint(4)` → display: "u32: 42"
      - ghost local with `is_ghost=true` → excluded from output
    </behavior>
    <implementation>
      RED: Create `crates/driver/src/cex_render.rs` with public types and function signatures only. Write tests in `#[cfg(test)] mod tests` covering: bitvec i32 parsing, bool rendering, ghost exclusion, source name substitution. Run `cargo test --package rust-fv-driver -- cex_render` — MUST fail (no impl).

      GREEN: Implement `render_typed_value(smt_val: &str, ty: &ir::Ty) -> CexValue` dispatching on type variant. Implement `render_counterexample` iterating model pairs, filtering ghosts, translating names, calling render_typed_value. Run tests — MUST pass.

      REFACTOR: Extract bitvec parsing into a standalone `parse_bitvec(s: &str, signed: bool, width: usize) -> i64` helper (reuses existing `parse_bitvec_value` in `diagnostics.rs` if accessible, or re-implements cleanly). Ensure all test cases pass.

      Add `pub mod cex_render;` to `crates/driver/src/lib.rs`.
    </implementation>
  </feature>
  <verify>cargo test --package rust-fv-driver -- cex_render 2>&amp;1 | tail -30 &amp;&amp; cargo build --package rust-fv-driver 2>&amp;1 | tail -20 &amp;&amp; cargo clippy --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -20</verify>
  <done>cex_render.rs exists; all cex_render tests pass; render_counterexample returns CexVariable with `i32: 5` display for bitvec `#x00000005`; ghost locals are excluded; source names replace SSA names; no clippy warnings</done>
</task>

</tasks>

<verification>
cargo test --package rust-fv-driver -- cex_render 2>&amp;1 | tail -20
cargo test --workspace 2>&amp;1 | tail -20
cargo clippy --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -10
# Confirm cex_render module exists:
grep -n "mod cex_render" crates/driver/src/lib.rs
# Confirm render_counterexample function exists:
grep -n "pub fn render_counterexample" crates/driver/src/cex_render.rs
# Confirm bitvec parsing:
grep -n "parse_bitvec\|#x" crates/driver/src/cex_render.rs
</verification>

<success_criteria>
- `crates/driver/src/cex_render.rs` exists with `render_counterexample` public API
- `render_counterexample` returns `Vec&lt;CexVariable&gt;` with `display` containing `"i32: 5"` not `"#x00000005"` for integer bitvectors
- Ghost locals (`is_ghost=true`) are excluded from output
- Source names replace SSA names when available in `source_names` map
- All workspace tests pass: `cargo test --workspace`
- No clippy warnings: `cargo clippy --package rust-fv-driver -- -D warnings`
</success_criteria>

<output>
After completion, create `.planning/phases/19-counterexample-generation/19-02-SUMMARY.md` with:
- Public API surface of cex_render.rs
- Rendering rules implemented and any deviations
- Test coverage summary
- Any open issues for Plan 03 integration
</output>

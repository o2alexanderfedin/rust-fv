---
phase: 19-counterexample-generation
plan: 03
type: execute
wave: 3
depends_on:
  - 19-01
  - 19-02
files_modified:
  - crates/driver/src/diagnostics.rs
  - crates/driver/src/callbacks.rs
autonomous: true
requirements:
  - CEX-03

must_haves:
  truths:
    - "When verification fails with source location, ariadne renders actual source file content (not fallback text) with counterexample span labels"
    - "Each variable in the counterexample gets a separate ariadne Label at its use site in the failing spec line, formatted as `x: i32 = 5`"
    - "Variables with initial vs at-failure values get two separate Labels: one at parameter declaration site (labeled `(initial)`), one at failing line (labeled `(at failure)`)"
    - "When source_file or source_line is None, ariadne gracefully falls back to the existing text-only output"
    - "report_with_ariadne reads source file from disk and passes it to ariadne Source::from instead of unconditionally falling back to report_text_only"
  artifacts:
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Fully wired ariadne multi-label counterexample reporting"
      contains: "Source::from"
    - path: "crates/driver/src/callbacks.rs"
      provides: "source_text passed into VerificationFailure or diagnostics call site"
      contains: "source_text"
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/driver/src/diagnostics.rs"
      via: "VerificationFailure constructed with populated source_file/source_line from fill_vc_locations"
      pattern: "source_file.*source_line"
    - from: "crates/driver/src/diagnostics.rs"
      to: "crates/driver/src/cex_render.rs"
      via: "report_with_ariadne calls render_counterexample to get CexVariable list for Label messages"
      pattern: "render_counterexample"
---

<objective>
Wire ariadne to actually render counterexample values as inline source spans at the failing line. Remove the unconditional fallback to `report_text_only` in `report_with_ariadne`. Thread source text from file and counterexample rendering from `cex_render` into multi-label ariadne output.

Purpose: CEX-03 requires that terminal output shows counterexample values annotated at the failing source line via ariadne span labels. This plan completes the plumbing: source text read from disk, `CexVariable` list from `cex_render`, and per-variable `Label` spans placed at variable use sites in the spec.

Output: Updated `diagnostics.rs` with working `report_with_ariadne` (no unconditional fallback); updated `callbacks.rs` to pass `source_names`/`locals` into the diagnostic call path.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-counterexample-generation/19-RESEARCH.md
@.planning/phases/19-counterexample-generation/19-02-SUMMARY.md
@crates/driver/src/diagnostics.rs
@crates/driver/src/callbacks.rs
@crates/driver/src/cex_render.rs
@crates/analysis/src/ir.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend VerificationFailure and wire source_names into callbacks.rs</name>
  <files>
    crates/driver/src/diagnostics.rs
    crates/driver/src/callbacks.rs
  </files>
  <action>
    Extend `VerificationFailure` struct in `diagnostics.rs` with two new fields:
    ```rust
    pub source_names: std::collections::HashMap<String, String>, // ssa → source name
    pub locals: Vec<rust_fv_analysis::ir::Local>,                // typed locals for cex_render
    pub params: Vec<rust_fv_analysis::ir::Local>,                // typed params for cex_render
    ```
    These will be populated in `callbacks.rs` when constructing `VerificationFailure` for each failing VC.

    In `callbacks.rs`, locate where `VerificationFailure` is constructed (search for `VerificationFailure {`). After `convert_mir` is called and the IR function is available, pass:
    - `source_names: func.source_names.clone()` (from Plan 01 — `ir::Function.source_names`)
    - `locals: func.locals.clone()`
    - `params: func.params.clone()`

    Also ensure `fill_vc_locations` (from Plan 01) has been called so `source_file` and `source_line` on each `VcLocation` are populated before constructing the failure. If `fill_vc_locations` was not implemented in Plan 01, implement it here: iterate `func`'s basic blocks in the MIR body, find the `Terminator::Assert` at the failing VC index, call `tcx.sess.source_map().lookup_char_pos(terminator.source_info.span.lo())` to get `(file_name, line)`, and set those on `VcLocation.source_file` and `source_line`. Store `source_column` too for byte-offset computation.

    Verify: `cargo build --package rust-fv-driver 2>&1 | tail -30` — must compile cleanly.
  </action>
  <verify>cargo build --package rust-fv-driver 2>&amp;1 | tail -30 &amp;&amp; cargo test --workspace 2>&amp;1 | tail -20</verify>
  <done>VerificationFailure has source_names, locals, params fields; callbacks.rs populates them from the IR function; all existing tests still pass</done>
</task>

<task type="auto">
  <name>Task 2: Wire ariadne multi-label rendering in report_with_ariadne</name>
  <files>
    crates/driver/src/diagnostics.rs
  </files>
  <action>
    Replace the current `report_with_ariadne` body (which unconditionally falls back to `report_text_only` at line ~94) with a working implementation:

    1. Read source file from disk:
       ```rust
       let source_text = match std::fs::read_to_string(source_file) {
           Ok(text) => text,
           Err(_) => { report_text_only(failure); return; }
       };
       ```

    2. Build `byte_offset` from `source_line` and `source_column` (if available):
       - Compute byte offset by summing lengths of lines 0..source_line-1 in `source_text` (use `source_text.lines().take(source_line - 1).map(|l| l.len() + 1).sum::<usize>()` for the line start, then add column).
       - If `source_column` is `None`, use line start only.

    3. Build per-variable Labels by calling `cex_render::render_counterexample`:
       ```rust
       let cex_vars = crate::cex_render::render_counterexample(
           failure.counterexample.as_deref().unwrap_or(&[]),
           &failure.source_names,
           &failure.locals,
           &failure.params,
       );
       ```

    4. For each `CexVariable` in `cex_vars`:
       - Find the variable's use site in the spec text: search `failure.contract_text` (the spec string like `result >= 0`) for the variable name; locate that substring within `source_text` starting from the `source_line` byte offset. Use a simple byte substring search: `source_text[byte_offset..].find(var.name.as_str())`.
       - If a `CexVariable` has only `display` (single value): add one `Label` at the found span with message `"{name}: {ty} = {display}"` per CONTEXT.md format.
       - If a `CexVariable` has `initial` and `at_failure`: add TWO labels:
         - Label at parameter declaration (search backward from `byte_offset` for the param name in function signature) with message `"{name} (initial): {ty} = {initial.display}"`
         - Label at failing spec line with message `"{name} (at failure): {ty} = {at_failure.display}"`
       - Use `ColorGenerator::new()` cycling colors for each label (one color per variable).

    5. Finish with `report.finish().eprint((source_file, Source::from(&source_text))).unwrap_or(())`.

    6. Do NOT call `report_text_only` after a successful ariadne report — ariadne output replaces it.

    Import `ariadne::Source` (currently not imported — add to the use statement at line 8).

    Per CONTEXT.md decisions:
    - Label format: `x: i32 = 5` (Rust declaration syntax)
    - No cap on labels — show all variables
    - Two-value vars: two separate span labels labeled `(initial)` and `(at failure)`

    Fallback path: if source file read fails OR if `source_file`/`source_line` is None → `report_text_only(failure)`.

    Verify: run `cargo test --workspace` — all tests pass. Then do a manual smoke test: create a small test function with a failing postcondition, run `cargo verify`, confirm ariadne output shows source spans with variable values. If the test fixture from prior phases can be used, run it.
  </action>
  <verify>cargo test --workspace 2>&amp;1 | tail -30 &amp;&amp; cargo clippy --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -20 &amp;&amp; grep -n "Source::from" crates/driver/src/diagnostics.rs &amp;&amp; grep -n "render_counterexample" crates/driver/src/diagnostics.rs</verify>
  <done>report_with_ariadne reads source file from disk and calls eprint with Source::from; render_counterexample is called to get typed labels; the unconditional fallback to report_text_only at the end of report_with_ariadne is gone; all workspace tests pass; no clippy warnings</done>
</task>

</tasks>

<verification>
cargo test --workspace 2>&amp;1 | tail -30
cargo clippy --package rust-fv-driver -- -D warnings 2>&amp;1 | tail -10
# Confirm Source::from is used (ariadne wired):
grep -n "Source::from" crates/driver/src/diagnostics.rs
# Confirm render_counterexample is called:
grep -n "render_counterexample" crates/driver/src/diagnostics.rs
# Confirm the unconditional fallback is gone:
grep -n "report_text_only" crates/driver/src/diagnostics.rs
# Should show: report_text_only is only called in the fallback branches, not at end of report_with_ariadne
</verification>

<success_criteria>
- `report_with_ariadne` reads source file from disk (no unconditional `report_text_only` at bottom)
- `Source::from` from ariadne is used in `diagnostics.rs`
- `render_counterexample` from `cex_render` is called to build per-variable Labels
- Each CexVariable gets a Label with format `x: i32 = 5` at its spec use site
- Two-value variables get two Labels: `(initial)` and `(at failure)`
- Graceful fallback to text-only when source file is unreadable or source_file/source_line is None
- All workspace tests pass: `cargo test --workspace`
- No clippy warnings: `cargo clippy --package rust-fv-driver -- -D warnings`
</success_criteria>

<output>
After completion, create `.planning/phases/19-counterexample-generation/19-03-SUMMARY.md` with:
- What was changed in diagnostics.rs and callbacks.rs
- How ariadne multi-label wiring works
- Fallback behavior description
- Any deviations from the plan
- Test results
</output>

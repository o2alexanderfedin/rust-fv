---
phase: 06-recursive-functions
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/macros/src/lib.rs
  - crates/analysis/Cargo.toml
  - crates/analysis/src/ir.rs
  - crates/analysis/src/vcgen.rs
  - crates/analysis/src/call_graph.rs
  - crates/analysis/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write #[decreases(n)] annotation on a function and it compiles"
    - "Recursive functions are detected via SCC analysis of the call graph"
    - "Direct recursion (self-loops) is detected as a recursive group of size 1"
    - "Mutual recursion (even/odd) is detected as a recursive group of size 2+"
    - "VcKind::Termination exists for classifying termination VCs"
    - "Contracts struct stores decreases clause alongside requires/ensures"
  artifacts:
    - path: "crates/macros/src/lib.rs"
      provides: "#[decreases(expr)] proc macro attribute"
      contains: "pub fn decreases"
    - path: "crates/analysis/src/ir.rs"
      provides: "Contracts.decreases field for termination measures"
      contains: "decreases"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "VcKind::Termination variant"
      contains: "Termination"
    - path: "crates/analysis/src/call_graph.rs"
      provides: "SCC-based recursion detection via petgraph"
      contains: "tarjan_scc"
    - path: "crates/analysis/Cargo.toml"
      provides: "petgraph dependency"
      contains: "petgraph"
  key_links:
    - from: "crates/macros/src/lib.rs"
      to: "crates/driver/src/callbacks.rs"
      via: "doc attribute rust_fv::decreases::EXPR"
      pattern: "rust_fv::decreases::"
    - from: "crates/analysis/src/call_graph.rs"
      to: "petgraph::algo::tarjan_scc"
      via: "SCC computation"
      pattern: "tarjan_scc"
---

<objective>
Add infrastructure for recursive function verification: the `#[decreases(expr)]` proc macro, IR/VcKind extensions, petgraph dependency, and SCC-based recursion detection in the call graph.

Purpose: All downstream plans (termination VCs, encoding, diagnostics) depend on these foundational types and the ability to detect which functions are recursive via call graph SCC analysis.

Output: Compiling `#[decreases]` macro, `Contracts.decreases` field, `VcKind::Termination` variant, `RecursiveGroup` type, and `CallGraph::detect_recursion()` method using petgraph's `tarjan_scc`.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recursive-functions/06-RESEARCH.md
@crates/macros/src/lib.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/vcgen.rs
@crates/analysis/src/call_graph.rs
@crates/analysis/src/lib.rs
@crates/analysis/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add #[decreases] macro, IR extension, and VcKind::Termination (TDD)</name>
  <files>crates/macros/src/lib.rs, crates/analysis/src/ir.rs, crates/analysis/src/vcgen.rs</files>
  <action>
**RED phase -- write failing tests first:**

1. In `crates/macros/src/lib.rs` tests module, add tests following the existing `spec_attribute_impl` pattern:
   - `test_decreases_simple`: `#[decreases(n)]` on a function produces `#[doc = "rust_fv::decreases::n"]` attribute
   - `test_decreases_complex_expr`: `#[decreases(n - 1)]` produces correct doc attribute
   - `test_decreases_method_call_expr`: `#[decreases(tree.size())]` produces correct doc attribute
   - `test_decreases_preserves_function_body`: original function body is preserved

2. In `crates/analysis/src/ir.rs` tests, add:
   - `test_contracts_default_has_no_decreases`: `Contracts::default().decreases` is `None`
   - `test_contracts_with_decreases`: creating Contracts with a decreases SpecExpr stores it

3. In `crates/analysis/src/vcgen.rs` tests, add:
   - `test_vc_kind_termination_variant_exists`: assert `VcKind::Termination` can be constructed and compared

Run `cargo test -p rust-fv-macros -p rust-fv-analysis` -- all new tests MUST fail.

**GREEN phase -- implement minimally:**

1. `crates/macros/src/lib.rs`:
   - Add `#[proc_macro_attribute] pub fn decreases(attr: TokenStream, item: TokenStream) -> TokenStream` that delegates to `spec_attribute("decreases", attr, item)` -- follows exact same pattern as `requires`/`ensures`/`invariant`.

2. `crates/analysis/src/ir.rs`:
   - Add to `Contracts` struct: `pub decreases: Option<SpecExpr>` -- the termination measure expression.
   - Update `Contracts::default()` to set `decreases: None` (the `#[derive(Default)]` handles this since Option<T> defaults to None, but verify it still derives Default correctly -- add `decreases: None` in any manual Default impls if they exist).

3. `crates/analysis/src/vcgen.rs`:
   - Add `Termination` variant to `VcKind` enum: `/// Termination measure decreases check` followed by `Termination,`
   - Update `vc_kind_description` in `crates/driver/src/diagnostics.rs` to add `VcKind::Termination => "termination measure not proven to decrease"` (needed to avoid exhaustive match error)
   - Update `suggest_fix` in `crates/driver/src/diagnostics.rs` to add `VcKind::Termination => Some("Verify that #[decreases(expr)] expression strictly decreases at each recursive call site".to_string())`

Run `cargo test -p rust-fv-macros -p rust-fv-analysis` -- all new tests MUST pass, all existing tests MUST still pass.

**REFACTOR phase:** Run `cargo clippy --workspace` and `cargo fmt --all`. Fix any warnings. Zero warnings policy.

IMPORTANT: The `#[decreases]` macro uses the SAME `spec_attribute` helper as requires/ensures/invariant. Do NOT create a new helper. The pattern `#[doc = "rust_fv::decreases::EXPR"]` is how the driver will detect it.

IMPORTANT: Also update `crates/driver/src/diagnostics.rs` for the new VcKind::Termination variant to avoid match exhaustiveness errors. Add test for the new vc_kind_description and suggest_fix arms.
  </action>
  <verify>
`cargo test -p rust-fv-macros -p rust-fv-analysis --lib` passes with all new tests green.
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
`cargo fmt --all -- --check` reports no formatting issues.
  </verify>
  <done>
#[decreases(expr)] macro compiles and produces rust_fv::decreases::EXPR doc attribute.
Contracts struct has decreases: Option[SpecExpr] field defaulting to None.
VcKind::Termination variant exists and is matchable.
Diagnostics handle Termination variant with description and fix suggestion.
All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add petgraph dependency and SCC-based recursion detection (TDD)</name>
  <files>crates/analysis/Cargo.toml, crates/analysis/src/call_graph.rs, crates/analysis/src/lib.rs</files>
  <action>
**RED phase -- write failing tests first:**

In `crates/analysis/src/call_graph.rs` tests module, add tests using the existing `make_function`, `call_block`, `return_block` helpers:

1. `test_detect_recursion_empty_graph`: No functions -> empty recursive groups
2. `test_detect_recursion_no_recursion`: `a -> b -> c` (linear chain) -> no recursive groups
3. `test_detect_recursion_direct_self_loop`: `factorial` calls itself -> 1 recursive group of size 1 containing "factorial"
4. `test_detect_recursion_mutual_two_functions`: `even -> odd -> even` (cycle) -> 1 recursive group of size 2 containing both
5. `test_detect_recursion_mutual_three_functions`: `a -> b -> c -> a` -> 1 recursive group of size 3
6. `test_detect_recursion_mixed_recursive_and_non`: Graph with both recursive and non-recursive functions -> only recursive ones in groups
7. `test_detect_recursion_two_separate_sccs`: Two independent recursive groups -> 2 separate RecursiveGroup results
8. `test_detect_recursion_self_loop_in_size_one_scc`: Single node with self-edge detected correctly (pitfall #3 from research)

Also add test for the `RecursiveGroup` struct:
9. `test_recursive_group_contains`: `RecursiveGroup::contains("factorial")` returns true/false correctly
10. `test_recursive_group_is_mutual`: size > 1 means mutual recursion, size == 1 means direct

Run `cargo test -p rust-fv-analysis` -- all new tests MUST fail (methods/types don't exist yet).

**GREEN phase -- implement minimally:**

1. `crates/analysis/Cargo.toml`: Add `petgraph = "0.8"` to `[dependencies]` section.

2. `crates/analysis/src/call_graph.rs`:
   - Add `use petgraph::graph::DiGraph;` and `use petgraph::algo::tarjan_scc;` imports.
   - Add `RecursiveGroup` struct:
     ```rust
     /// A group of mutually recursive functions (or a single directly recursive function).
     #[derive(Debug, Clone)]
     pub struct RecursiveGroup {
         /// Function names in this recursive group.
         pub functions: Vec<String>,
     }

     impl RecursiveGroup {
         /// Check if a function is in this recursive group.
         pub fn contains(&self, name: &str) -> bool {
             self.functions.iter().any(|f| f == name)
         }

         /// True if this is mutual recursion (2+ functions), false if direct recursion.
         pub fn is_mutual(&self) -> bool {
             self.functions.len() > 1
         }
     }
     ```
   - Add method `pub fn detect_recursion(&self) -> Vec<RecursiveGroup>` to `CallGraph`:
     - Build a petgraph `DiGraph<String, ()>` from `self.edges` and `self.all_functions`
     - Create `node_map: HashMap<String, NodeIndex>` for lookups
     - Add edges only for calls within `self.all_functions` (same as topological_order)
     - Run `tarjan_scc(&graph)` to get SCCs
     - Filter SCCs: keep those with `scc.len() > 1` OR where the single node has a self-loop (check `graph.edges(scc[0]).any(|e| e.target() == scc[0])`)
     - Map filtered SCCs to `RecursiveGroup { functions: ... }`
     - Return the vector

   CRITICAL: The self-loop check is essential for direct recursion. `tarjan_scc` returns size-1 SCCs for ALL nodes, including non-recursive ones. Only size-1 SCCs with a self-edge are recursive.

3. No changes needed to `lib.rs` -- `call_graph` module is already public.

Run `cargo test -p rust-fv-analysis` -- all new tests MUST pass, all existing tests MUST still pass.

**REFACTOR phase:** Run `cargo clippy --workspace` and `cargo fmt --all`. Fix any warnings.
  </action>
  <verify>
`cargo test -p rust-fv-analysis --lib` passes with all new tests green.
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
Verify petgraph is in Cargo.lock: `grep petgraph Cargo.lock` returns version info.
  </verify>
  <done>
petgraph dependency added to crates/analysis/Cargo.toml.
RecursiveGroup type with contains() and is_mutual() methods.
CallGraph::detect_recursion() correctly identifies direct recursion (self-loops), mutual recursion (multi-node SCCs), and correctly ignores non-recursive functions.
10+ unit tests covering all recursion detection cases including the self-loop pitfall.
All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cargo build --workspace` compiles cleanly
2. `cargo test --workspace` passes all tests (existing + new)
3. `cargo clippy --workspace -- -D warnings` shows 0 warnings
4. `#[decreases(n)]` attribute produces correct doc string
5. `CallGraph::detect_recursion()` identifies direct and mutual recursion via SCC analysis
6. `VcKind::Termination` variant exists
7. `Contracts.decreases` field stores optional termination measure
</verification>

<success_criteria>
- #[decreases(expr)] proc macro compiles and encodes spec as doc attribute
- Contracts.decreases: Option<SpecExpr> field exists and defaults to None
- VcKind::Termination variant exists with diagnostics support
- petgraph 0.8 dependency added
- RecursiveGroup type with contains() and is_mutual()
- CallGraph::detect_recursion() uses tarjan_scc, handles self-loops
- All tests pass (existing + ~20 new tests), 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-recursive-functions/06-01-SUMMARY.md`
</output>

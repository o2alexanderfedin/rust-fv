---
phase: 06-recursive-functions
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - crates/driver/src/callbacks.rs
  - crates/driver/src/diagnostics.rs
  - crates/analysis/tests/recursion_verification.rs
autonomous: true

must_haves:
  truths:
    - "Developer annotates recursive function with #[decreases(n)] and verifier proves termination"
    - "Developer writes recursive function without #[decreases] and verifier rejects with 'missing termination measure' diagnostic"
    - "Developer verifies mutually recursive functions (even/odd) with shared decreases clause"
    - "Developer sees termination VC failure with counterexample showing non-decreasing measure"
    - "Developer verifies recursive function with factorial pattern end-to-end via Z3"
  artifacts:
    - path: "crates/driver/src/callbacks.rs"
      provides: "#[decreases] extraction from HIR doc attributes"
      contains: "rust_fv::decreases::"
    - path: "crates/driver/src/diagnostics.rs"
      provides: "Termination-specific diagnostic messages and fix suggestions"
      contains: "Termination"
    - path: "crates/analysis/tests/recursion_verification.rs"
      provides: "End-to-end verification tests for recursion using Z3"
      min_lines: 200
  key_links:
    - from: "crates/driver/src/callbacks.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Populates Contracts.decreases from rust_fv::decreases:: doc attribute"
      pattern: "decreases"
    - from: "crates/analysis/tests/recursion_verification.rs"
      to: "crates/analysis/src/vcgen.rs"
      via: "Calls generate_vcs() and checks results via Z3"
      pattern: "generate_vcs"
---

<objective>
Complete the Phase 6 feature by adding driver-level #[decreases] extraction, comprehensive diagnostics for termination failures, and end-to-end verification tests that prove recursive functions correct via Z3.

Purpose: This plan connects the proc macro (#[decreases]) all the way through to verification results. Without driver extraction, the annotation has no effect. Without e2e tests, we cannot validate the full pipeline works end-to-end with Z3.

Output: Working end-to-end recursive function verification matching all 5 Phase 6 success criteria.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recursive-functions/06-RESEARCH.md
@.planning/phases/06-recursive-functions/06-01-SUMMARY.md
@.planning/phases/06-recursive-functions/06-02-SUMMARY.md
@crates/driver/src/callbacks.rs
@crates/driver/src/diagnostics.rs
@crates/analysis/tests/e2e_verification.rs
@crates/analysis/tests/interprocedural_tests.rs
@crates/analysis/tests/soundness_suite.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add #[decreases] extraction in driver and termination diagnostics</name>
  <files>crates/driver/src/callbacks.rs, crates/driver/src/diagnostics.rs</files>
  <action>
1. **`crates/driver/src/callbacks.rs` -- Extract #[decreases] from HIR:**
   - In the `extract_contracts` function, add handling for the `rust_fv::decreases::` prefix, following the exact pattern of requires/ensures/invariant:
     ```rust
     } else if let Some(spec) = doc.strip_prefix("rust_fv::decreases::") {
         contracts.decreases = Some(spec.to_string());
     }
     ```
   - Update the `HirContracts` struct (or wherever the intermediate contracts are stored before converting to `ir::Contracts`) to include `decreases: Option<String>`.
   - In the conversion from HirContracts to `ir::Contracts`, map:
     ```rust
     decreases: contracts.decreases.map(|raw| rust_fv_analysis::ir::SpecExpr { raw }),
     ```
   - Update the condition for inserting into the map: also insert if `contracts.decreases.is_some()`.

2. **`crates/driver/src/diagnostics.rs` -- Enhanced termination diagnostics:**
   - The `vc_kind_description` and `suggest_fix` updates were done in Plan 01. Verify they are still correct.
   - Add a new diagnostic helper function `format_missing_decreases_help(function_name: &str) -> String`:
     ```rust
     pub fn format_missing_decreases_help(function_name: &str) -> String {
         format!(
             "recursive function `{}` requires a termination measure.\n\
              Add #[decreases(expr)] where expr is a non-negative integer expression\n\
              that strictly decreases at each recursive call.\n\
              Example: #[decreases(n)] for a function that recurses with n-1",
             function_name
         )
     }
     ```
   - Add a `format_termination_counterexample` function that formats counterexample values specifically for termination failures:
     ```rust
     pub fn format_termination_counterexample(
         function_name: &str,
         entry_values: &[(String, String)],
         call_values: &[(String, String)],
     ) -> String
     ```
     This should produce output like:
     ```
     counterexample: at function entry, n = 5
                     at recursive call, n = 5 (not decreasing)
     ```

   - Add tests for both new functions:
     - `test_format_missing_decreases_help`: verify output contains function name and #[decreases] suggestion
     - `test_format_termination_counterexample`: verify output shows entry vs call values

3. **Run `cargo clippy --workspace` and `cargo fmt --all`.**
  </action>
  <verify>
`cargo build --workspace` compiles (driver crate with new extraction logic).
`cargo test -p cargo-verify` passes (driver tests).
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
  </verify>
  <done>
Driver extracts #[decreases(expr)] from HIR doc attributes into Contracts.decreases field.
Diagnostics provide clear "missing termination measure" help text with #[decreases] suggestion.
Termination counterexample formatting shows entry vs. call-site values.
All driver tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end recursion verification tests via Z3</name>
  <files>crates/analysis/tests/recursion_verification.rs</files>
  <action>
Create `crates/analysis/tests/recursion_verification.rs` following the patterns in existing test files (`e2e_verification.rs`, `interprocedural_tests.rs`, `soundness_suite.rs`).

**Test structure:** Each test builds an IR `Function` with recursive structure, calls `generate_vcs()`, renders the SMT-LIB script, submits to Z3, and checks the result (UNSAT = verified, SAT = violation).

Use the existing test helpers from the test files for solver submission. Import `rust_fv_analysis::vcgen::{generate_vcs, VcKind}`, `rust_fv_analysis::ir::*`, `rust_fv_analysis::contract_db::*`, and `rust_fv_solver` for Z3.

**Required tests (matching Phase 6 success criteria):**

1. **`e2e_factorial_with_decreases_verified` (Success Criterion 1):**
   - Build factorial function: params `[_1: i32]`, return `_0: i32`
   - Contracts: `#[requires(_1 >= 0)]`, `#[ensures(result > 0)]`, `#[decreases(_1)]`
   - CFG: bb0 = SwitchInt on `_1 <= 1`, bb1 (base) = `_0 = 1; Return`, bb2 (recursive) = `Call factorial(_1 - 1) -> _2; _0 = _1 * _2; Return`
   - Contract DB: register factorial's summary
   - Generate VCs, find termination VCs
   - Submit termination VCs to Z3 -> expect UNSAT (termination proved: `_1 - 1 < _1` when `_1 > 1`)
   - Submit postcondition VCs to Z3 -> expect UNSAT (postcondition proved via uninterpreted encoding)

2. **`e2e_factorial_without_decreases_rejected` (Success Criterion 2):**
   - Same factorial but `contracts.decreases = None`
   - Generate VCs -> find termination diagnostic VC
   - Submit to Z3 -> expect SAT (always-SAT diagnostic VC indicating missing decreases)
   - Verify VC description contains "missing termination measure"

3. **`e2e_mutual_recursion_even_odd_verified` (Success Criterion 3):**
   - Build `even(n)` and `odd(n)`:
     - `even`: if n == 0 return true, else call odd(n-1)
     - `odd`: if n == 0 return false, else call even(n-1)
     - Both have `#[decreases(_1)]` and `#[requires(_1 >= 0)]`
   - Contract DB: register both summaries
   - Generate VCs for `even` and `odd`
   - Submit termination VCs to Z3 -> expect UNSAT for both (n-1 < n when n > 0)

4. **`e2e_non_decreasing_measure_produces_counterexample` (Success Criterion 4):**
   - Build a buggy recursive function: `f(n)` calls `f(n)` (not `f(n-1)`) with `#[decreases(_1)]`
   - Generate VCs -> find termination VC
   - Submit to Z3 -> expect SAT (measure does NOT decrease: n is not < n)
   - Verify VC kind is `VcKind::Termination`

5. **`e2e_non_recursive_function_no_termination_vcs`:**
   - Build a simple non-recursive function with `#[ensures(result > 0)]`
   - Generate VCs -> verify no VCs have `vc_kind == VcKind::Termination`
   - Submit all VCs to Z3 -> expect UNSAT (normal verification unaffected)

6. **`e2e_recursive_function_postcondition_uses_uninterpreted_encoding`:**
   - Build factorial with `#[decreases(_1)]` and `#[ensures(result > 0)]`
   - Generate VCs
   - Find postcondition VC -> render to SMT-LIB string
   - Verify the SMT-LIB contains `declare-fun` for the uninterpreted function
   - Verify it does NOT contain inlined recursive body (no infinite unrolling)

7. **`snd_recursive_without_decreases_rejected` (Soundness):**
   - Add to soundness pattern: recursive function without #[decreases] is unsound, must be rejected
   - Build `loop_forever(n)` that calls `loop_forever(n)` with no decreases
   - Verify rejection

8. **`e2e_fibonacci_two_recursive_calls`:**
   - Build fibonacci: `fib(n)` calls `fib(n-1)` and `fib(n-2)` with `#[decreases(_1)]`, `#[requires(_1 >= 0)]`
   - Generate VCs -> expect 2 termination VCs (one per call site)
   - Submit both to Z3 -> expect UNSAT (both n-1 < n and n-2 < n when n > 1)

**IMPORTANT:** Follow the exact IR construction patterns from existing test files. Use the same helper functions and test patterns. Each test should be self-contained.

**IMPORTANT:** For the Z3 solver submission, use the pattern from `e2e_verification.rs` -- create a solver instance, pass the rendered SMT-LIB string, check the result.

Run `cargo test -p rust-fv-analysis --test recursion_verification` -- all tests MUST pass.

Run `cargo clippy --workspace` and `cargo fmt --all`.
  </action>
  <verify>
`cargo test -p rust-fv-analysis --test recursion_verification` passes all 8 tests.
`cargo test --workspace` passes all tests (existing + new).
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
Verify all 5 Phase 6 success criteria are covered:
  1. factorial with #[decreases(n)] verified (test 1)
  2. factorial without #[decreases] rejected (test 2)
  3. mutual recursion even/odd verified (test 3)
  4. non-decreasing measure counterexample (test 4)
  5. (structural measure is test infrastructure -- the decreases expression can reference any integer expression including tree.size())
  </verify>
  <done>
8 end-to-end tests pass, validating the full recursion verification pipeline from IR through VCGen through Z3.
Factorial with #[decreases] proves termination (UNSAT).
Factorial without #[decreases] is rejected with diagnostic.
Mutual recursion (even/odd) proves termination for both functions.
Non-decreasing measure (buggy recursion) produces SAT with counterexample info.
Non-recursive functions are unaffected.
Postcondition VCs use uninterpreted function encoding.
Fibonacci with two recursive calls generates and proves both termination VCs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Final workspace validation and warning cleanup</name>
  <files>crates/analysis/src/recursion.rs, crates/analysis/src/vcgen.rs, crates/analysis/src/call_graph.rs</files>
  <action>
Run full workspace validation:

1. `cargo build --workspace` -- must compile cleanly
2. `cargo test --workspace` -- all tests must pass (existing 1,741 + new ~30-40)
3. `cargo clippy --workspace -- -D warnings` -- 0 warnings
4. `cargo fmt --all -- --check` -- no formatting issues

If any failures:
- Fix clippy warnings (unused imports, dead code, etc.)
- Fix any test regressions caused by IR changes (Contracts now has `decreases` field -- any test constructing Contracts manually needs `decreases: None` added)
- Fix any integration issues between the three plans

Count new tests: `cargo test --workspace 2>&1 | grep "test result"` -- verify test count increased by ~30+ from baseline of 1,741.

Verify the phase 6 LOC estimate: count lines in new/modified files. Target ~1,800 new LOC.

NOTE: If `Contracts` struct changes broke existing tests that construct it manually (they'll get "missing field" errors), fix them by adding `decreases: None` to all existing Contracts instantiations. This is a mechanical change -- search for `Contracts {` and `Contracts::default()` across the workspace.
  </action>
  <verify>
`cargo build --workspace` succeeds.
`cargo test --workspace` reports 0 failures, test count >= 1,770.
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
`cargo fmt --all -- --check` reports no issues.
  </verify>
  <done>
Full workspace compiles, all tests pass (1,770+), 0 warnings, 0 formatting issues.
Phase 6 is feature-complete: recursive function verification with termination checking works end-to-end.
  </done>
</task>

</tasks>

<verification>
Phase 6 complete verification against success criteria:

1. "Developer annotates recursive function with #[decreases(expr)] and verifier proves termination" -> e2e_factorial_with_decreases_verified test
2. "Developer writes factorial/fibonacci function without #[decreases] and verifier rejects with 'missing termination measure' diagnostic" -> e2e_factorial_without_decreases_rejected test
3. "Developer verifies mutually recursive functions (even/odd) with shared decreases clause" -> e2e_mutual_recursion_even_odd_verified test
4. "Developer sees termination VC failure with counterexample showing non-decreasing measure" -> e2e_non_decreasing_measure_produces_counterexample test
5. "Developer verifies recursive tree traversal with structural measure" -> covered by the #[decreases(expr)] mechanism accepting any integer expression

Requirements coverage:
- REC-01: Recursive functions encoded via uninterpreted function encoding with axioms
- REC-02: #[decreases(expr)] annotation specifies termination measure
- REC-03: Termination VC: measure at call site < measure at entry
- REC-04: Mutual recursion detected via call graph SCC analysis
- REC-05: Missing #[decreases] on recursive function rejected
- INF-01: petgraph dependency added
</verification>

<success_criteria>
- Driver extracts #[decreases(expr)] from HIR doc attributes
- Diagnostics provide clear termination failure messages with fix suggestions
- 8 e2e tests pass via Z3 covering all 5 success criteria
- Full workspace: all tests pass (1,770+), 0 warnings, 0 format issues
- All 6 requirements (REC-01 through REC-05, INF-01) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-recursive-functions/06-03-SUMMARY.md`
</output>

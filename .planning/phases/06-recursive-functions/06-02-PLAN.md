---
phase: 06-recursive-functions
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/analysis/src/recursion.rs
  - crates/analysis/src/lib.rs
  - crates/analysis/src/vcgen.rs
autonomous: true

must_haves:
  truths:
    - "Recursive function with #[decreases(n)] has termination VC generated proving n decreases at each recursive call"
    - "Recursive function without #[decreases] is detected and flagged as missing termination measure"
    - "Recursive function is encoded as uninterpreted SMT function with axioms for base/recursive cases"
    - "Mutual recursion group has termination VCs generated for all functions in the SCC"
    - "Termination VC is: measure_at_call_site < measure_at_entry (negated for UNSAT check)"
  artifacts:
    - path: "crates/analysis/src/recursion.rs"
      provides: "Recursion analysis module: termination VC generation, uninterpreted function encoding, missing-decreases detection"
      min_lines: 200
    - path: "crates/analysis/src/lib.rs"
      provides: "pub mod recursion export"
      contains: "pub mod recursion"
    - path: "crates/analysis/src/vcgen.rs"
      provides: "Integration point calling recursion module during VC generation"
      contains: "recursion"
  key_links:
    - from: "crates/analysis/src/recursion.rs"
      to: "crates/analysis/src/call_graph.rs"
      via: "Uses CallGraph::detect_recursion() to find recursive groups"
      pattern: "detect_recursion"
    - from: "crates/analysis/src/recursion.rs"
      to: "crates/analysis/src/spec_parser.rs"
      via: "Parses decreases expression via parse_spec_expr"
      pattern: "parse_spec_expr"
    - from: "crates/analysis/src/vcgen.rs"
      to: "crates/analysis/src/recursion.rs"
      via: "Calls recursion module to generate termination VCs and encode recursive functions"
      pattern: "generate_termination_vcs\\|encode_recursive_function"
---

<objective>
Implement the core recursion verification logic: a `recursion.rs` module that generates termination VCs and encodes recursive functions as uninterpreted SMT functions with axioms, integrated into the VCGen pipeline.

Purpose: This is the heart of Phase 6 -- without termination VCs, recursive functions cannot be soundly verified (postconditions are meaningless for non-terminating functions). Without uninterpreted function encoding, recursive calls would cause infinite SMT unrolling.

Output: Working `recursion.rs` module with `generate_termination_vcs()`, `encode_recursive_function()`, and `check_missing_decreases()` functions, integrated into `generate_vcs()`.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recursive-functions/06-RESEARCH.md
@.planning/phases/06-recursive-functions/06-01-SUMMARY.md
@crates/analysis/src/vcgen.rs
@crates/analysis/src/call_graph.rs
@crates/analysis/src/ir.rs
@crates/analysis/src/spec_parser.rs
@crates/analysis/src/encode_sort.rs
@crates/analysis/src/encode_term.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recursion.rs with termination VC generation and missing-decreases detection (TDD)</name>
  <files>crates/analysis/src/recursion.rs, crates/analysis/src/lib.rs</files>
  <action>
**RED phase -- write failing tests first:**

Create `crates/analysis/src/recursion.rs` with a `#[cfg(test)] mod tests` block containing:

1. `test_check_missing_decreases_flags_recursive_without_decreases`:
   - Build a `Function` for `factorial` with a self-calling `Terminator::Call` and `contracts.decreases = None`
   - Build a `CallGraph` from it, get `RecursiveGroup`s
   - Call `check_missing_decreases(functions, recursive_groups)` -> expect 1 `MissingDecreasesError` with function name "factorial"

2. `test_check_missing_decreases_ok_with_decreases`:
   - Same factorial function but with `contracts.decreases = Some(SpecExpr { raw: "n".to_string() })`
   - Call `check_missing_decreases` -> expect 0 errors

3. `test_check_missing_decreases_mutual_both_missing`:
   - Build `even` and `odd` functions calling each other, both without decreases
   - Expect 2 errors (one per function)

4. `test_generate_termination_vcs_factorial`:
   - Build factorial function with `#[decreases(n)]`, `#[requires(n >= 0)]`, recursive call `factorial(n-1)`
   - Call `generate_termination_vcs` for this function
   - Expect 1 termination VC (one recursive call site)
   - Verify the VC description mentions "termination"
   - Verify `vc.location.vc_kind == VcKind::Termination`

5. `test_generate_termination_vcs_two_recursive_calls`:
   - Build fibonacci function with `#[decreases(n)]`, two recursive calls: `fib(n-1)` and `fib(n-2)`
   - Expect 2 termination VCs (one per recursive call site)

6. `test_generate_termination_vcs_no_decreases_returns_empty`:
   - Recursive function without `#[decreases]` -> 0 termination VCs (handled by missing-decreases check instead)

7. `test_generate_termination_vcs_non_recursive_returns_empty`:
   - Non-recursive function with `#[decreases(n)]` -> 0 termination VCs (nothing to check)

Also add `pub mod recursion;` to `crates/analysis/src/lib.rs`.

Run `cargo test -p rust-fv-analysis` -- all new tests MUST fail.

**GREEN phase -- implement minimally:**

Create `crates/analysis/src/recursion.rs`:

```rust
//! Recursion analysis: termination checking and recursive function encoding.
//!
//! Provides three core capabilities:
//! 1. **Missing decreases detection**: Flag recursive functions without `#[decreases]`
//! 2. **Termination VC generation**: Prove decreases measure strictly decreases at each recursive call
//! 3. **Uninterpreted function encoding**: Encode recursive functions as SMT uninterpreted functions with axioms
```

Implement:

1. **`MissingDecreasesError`** struct:
   ```rust
   pub struct MissingDecreasesError {
       pub function_name: String,
       pub recursive_group: Vec<String>,  // names of all functions in the SCC
   }
   ```

2. **`check_missing_decreases()`**:
   - Takes `&[(String, &Function)]` and `&[RecursiveGroup]`
   - For each recursive group, check each function in the group
   - If `function.contracts.decreases.is_none()`, emit `MissingDecreasesError`
   - Return `Vec<MissingDecreasesError>`

3. **`generate_termination_vcs()`**:
   - Takes `func: &Function`, `recursive_groups: &[RecursiveGroup]`, `contract_db: Option<&ContractDatabase>`
   - First check: is this function in any recursive group? If not, return empty Vec.
   - Second check: does it have `contracts.decreases`? If not, return empty Vec (missing-decreases handles this separately).
   - Parse the decreases expression via `spec_parser::parse_spec_expr(&decreases.raw, func)` to get the entry measure Term.
   - Iterate over `func.basic_blocks` looking for `Terminator::Call` where the callee is in the same recursive group (self-calls or mutual calls).
   - For each such recursive call site:
     - Build argument substitution: map formal param names to actual argument operands at the call site.
     - Substitute into the decreases expression to get call-site measure Term.
     - Build a fresh SMT `Script`:
       a. Declare variables for function parameters
       b. Assume preconditions (from `func.contracts.requires`)
       c. Encode path conditions up to the call site (from prior assignments/branches)
       d. Assert `NOT (call_measure < entry_measure)` (negated: if UNSAT, measure decreases; if SAT, counterexample shows non-decreasing)
       e. Add `check-sat` and `get-model`
     - Create `VerificationCondition` with `vc_kind: VcKind::Termination`
   - Return `Vec<VerificationCondition>`

   IMPORTANT: For the substitution of the decreases expression at the call site, use the actual arguments. For example, if decreases is `n` and the call is `factorial(n - 1)`, the call-site measure is `n - 1`. This substitution maps the parameter `_1` (which is `n`) to the actual argument at the call site.

   IMPORTANT: The entry measure uses the original parameter values. The call-site measure uses the substituted argument values. The VC checks `call_measure < entry_measure`.

   NOTE: For this task, focus on getting the VC structure correct. The actual SMT encoding details (variable declarations, path conditions) can be simplified for unit tests -- use mock/minimal scripts. The full integration with the VCGen's path enumeration happens in Task 2.

Run `cargo test -p rust-fv-analysis` -- all new tests MUST pass.

**REFACTOR phase:** Run `cargo clippy --workspace` and `cargo fmt --all`.
  </action>
  <verify>
`cargo test -p rust-fv-analysis --lib` passes with all new tests green.
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
`recursion.rs` module is exported in lib.rs.
  </verify>
  <done>
recursion.rs module exists with MissingDecreasesError, check_missing_decreases(), and generate_termination_vcs().
Missing decreases detection correctly flags recursive functions without #[decreases].
Termination VCs are generated for each recursive call site with VcKind::Termination.
Non-recursive functions and functions without decreases handled correctly.
7+ unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate recursion module into VCGen and add uninterpreted function encoding (TDD)</name>
  <files>crates/analysis/src/recursion.rs, crates/analysis/src/vcgen.rs</files>
  <action>
**RED phase -- write failing tests first:**

Add integration tests in `crates/analysis/src/vcgen.rs` test module:

1. `test_generate_vcs_recursive_function_produces_termination_vc`:
   - Build a factorial function: `#[requires(_1 >= 0)]`, `#[ensures(result > 0)]`, `#[decreases(_1)]`
   - Two basic blocks: bb0 has SwitchInt on `_1 <= 1`, bb1 (base case) returns 1, bb2 (recursive case) calls `factorial(_1 - 1)` and returns `_1 * result`
   - Call `generate_vcs(func, Some(&contract_db))` where contract_db has factorial's summary
   - Assert that at least one VC has `vc_kind == VcKind::Termination`

2. `test_generate_vcs_non_recursive_no_termination_vc`:
   - Build a simple non-recursive function
   - Call `generate_vcs` -> no VCs with `vc_kind == VcKind::Termination`

3. `test_recursive_function_encoded_as_uninterpreted`:
   - Build factorial with decreases
   - Generate VCs
   - Check that the postcondition VC script contains `declare-fun` for the uninterpreted function (not the inlined body)

Add tests in `crates/analysis/src/recursion.rs`:

4. `test_encode_recursive_function_declares_uninterpreted_fun`:
   - Call `encode_recursive_function(func, script)` for factorial
   - Verify that `script` contains a `Command::DeclareFun` with name containing "factorial" (or the uninterpreted version)

5. `test_encode_recursive_function_adds_base_case_axiom`:
   - Verify script contains an `Assert` for the base case: when `n <= 1`, `factorial_uninterp(n) = 1`

6. `test_encode_recursive_function_adds_recursive_case_axiom`:
   - Verify script contains an `Assert` for the recursive case: when `n > 1`, `factorial_uninterp(n) = n * factorial_uninterp(n-1)`

Run `cargo test -p rust-fv-analysis` -- all new tests MUST fail.

**GREEN phase -- implement:**

1. **Add `encode_recursive_function()` to `recursion.rs`:**
   - Takes `func: &Function`, returns `Vec<Command>` (SMT commands to add to any script using this function)
   - Declare uninterpreted function: `(declare-fun {func.name}_uninterp ({param_sorts}...) {return_sort})`
     - Use `encode_type` from `encode_sort` module for param and return sorts
   - Generate axioms by analyzing the function's basic blocks:
     - For each path through the function (simplified: look at SwitchInt branches):
       - Base case path (no recursive call): `(assert (forall ((params...)) (=> base_condition (= (func_uninterp params) base_value))))`
       - Recursive case path (has recursive call): `(assert (forall ((params...)) (=> recursive_condition (= (func_uninterp params) recursive_expr))))`
         where `recursive_expr` references `func_uninterp(modified_args)` for the recursive call
   - NOTE: Use quantified axioms (`forall`) with explicit triggers for the function application. This prevents infinite instantiation.
   - For Phase 6 scope, support functions with a single integer parameter and straightforward branching. Complex multi-parameter recursive functions will naturally work with the same encoding pattern.

2. **Integrate into `generate_vcs()` in `vcgen.rs`:**
   - After the existing path enumeration and before postcondition VC generation:
     a. Build a `CallGraph` from the single function being verified (and any functions in the contract_db)
     b. Call `detect_recursion()` to find recursive groups
     c. If the current function is in a recursive group:
        - Call `check_missing_decreases` -- if errors, create diagnostic VCs (always SAT, with error message)
        - If decreases is present, call `generate_termination_vcs()` and add results to `conditions`
        - Call `encode_recursive_function()` and add the uninterpreted function commands to the postcondition VC scripts (so the postcondition is proved using the axiomatized uninterpreted function, not the inlined body)

   IMPORTANT: For recursive functions, the postcondition VC must use the uninterpreted function encoding, NOT the inlined body. This means:
   - At call sites to recursive functions, instead of the existing opaque encoding, use `(func_uninterp actual_args)` as the return value
   - The axioms ensure the function semantics are encoded correctly

   IMPORTANT: Build the CallGraph for recursion detection using:
   - The function being verified
   - Plus all functions in the ContractDatabase (to detect mutual recursion where `even` calls `odd` and vice versa)
   - Pass the full function list to `CallGraph::from_functions`

3. **Handle the missing-decreases case in VCGen:**
   - When a recursive function lacks `#[decreases]`, generate a special VC:
     - Description: "recursive function `{name}` missing termination measure"
     - Script: `(assert true) (check-sat)` -- always SAT, indicating a "failure"
     - VcKind: `VcKind::Termination`
     - contract_text: `Some("add #[decreases(expr)] annotation")`
   - This ensures the verification pipeline reports the error through the normal VC result pathway

Run `cargo test -p rust-fv-analysis` -- all new tests MUST pass.

**REFACTOR phase:** Run `cargo clippy --workspace` and `cargo fmt --all`.
  </action>
  <verify>
`cargo test -p rust-fv-analysis` passes (both lib and integration tests).
`cargo clippy --workspace -- -D warnings` reports 0 warnings.
For a recursive factorial with `#[decreases(_1)]`: VCs include at least one Termination VC.
For a recursive factorial without `#[decreases]`: VCs include a Termination VC that is always SAT (error).
For a non-recursive function: no Termination VCs generated.
  </verify>
  <done>
encode_recursive_function() generates uninterpreted function declaration + axioms for base/recursive cases.
generate_vcs() integrates recursion detection: builds call graph, detects SCCs, generates termination VCs.
Missing #[decreases] on recursive functions produces always-SAT diagnostic VC.
Postcondition VCs for recursive functions use uninterpreted function encoding (not inlined body).
6+ new integration tests pass.
All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cargo build --workspace` compiles cleanly
2. `cargo test --workspace` passes all tests (existing + new)
3. `cargo clippy --workspace -- -D warnings` shows 0 warnings
4. Recursive function with #[decreases(n)] generates termination VCs at each recursive call site
5. Recursive function without #[decreases] is flagged via always-SAT diagnostic VC
6. Recursive functions are encoded as uninterpreted SMT functions with axioms
7. Non-recursive functions are unaffected by the new recursion analysis
</verification>

<success_criteria>
- recursion.rs module with check_missing_decreases(), generate_termination_vcs(), encode_recursive_function()
- Termination VCs generated: measure_at_call < measure_at_entry (negated for UNSAT = valid)
- Missing decreases flagged as always-SAT diagnostic VC
- Uninterpreted function encoding with base/recursive case axioms
- VCGen integration: recursive functions detected and handled during generate_vcs()
- 13+ new tests pass, all existing tests pass, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-recursive-functions/06-02-SUMMARY.md`
</output>

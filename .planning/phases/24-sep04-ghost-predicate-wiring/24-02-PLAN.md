---
phase: 24-sep04-ghost-predicate-wiring
plan: 02
type: tdd
wave: 2
depends_on: [24-01]
files_modified:
  - crates/driver/tests/ghost_predicate_e2e.rs
autonomous: true
requirements: [SEP-04]
gap_closure: true

must_haves:
  truths:
    - "A driver-level integration test calls verify_functions_parallel() with a VerificationTask containing a ghost predicate in its requires spec"
    - "The test confirms a precondition VC is generated (not silently dropped as with the severed db-less path)"
    - "The test is distinct from Phase 20 tests which call parse_spec_expr_with_db directly — this test goes through the full driver pipeline"
    - "cargo test -p rust-fv-driver -- ghost_predicate passes"
  artifacts:
    - path: "crates/driver/tests/ghost_predicate_e2e.rs"
      provides: "Driver-level E2E integration test for SEP-04 production wiring"
      contains: "verify_functions_parallel"
      min_lines: 60
  key_links:
    - from: "crates/driver/tests/ghost_predicate_e2e.rs"
      to: "crates/driver/src/parallel.rs verify_functions_parallel()"
      via: "VerificationTask with ghost_pred_db: Arc::new(db) passed to verify_functions_parallel"
      pattern: "verify_functions_parallel"
    - from: "crates/driver/tests/ghost_predicate_e2e.rs VerificationTask"
      to: "crates/driver/src/parallel.rs VerificationTask.ghost_pred_db"
      via: "ghost_pred_db field set to Arc::new(GhostPredicateDatabase with test predicate)"
      pattern: "ghost_pred_db: Arc::new"
---

<objective>
Driver-level E2E integration test proving `#[ghost_predicate]` expands in the production path through `verify_functions_parallel()`.

Purpose: Phase 20 tests validated `parse_spec_expr_with_db()` in isolation. This test validates the complete pipeline: `VerificationTask` → `verify_single()` → `generate_vcs_with_db()` → `parse_spec()` → `parse_spec_expr_with_db()`. Without this test, the SEP-04 wiring could be severed again without detection.
Output: `crates/driver/tests/ghost_predicate_e2e.rs` with at least one E2E test using `verify_functions_parallel()`.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-sep04-ghost-predicate-wiring/24-RESEARCH.md
@.planning/phases/24-sep04-ghost-predicate-wiring/24-01-SUMMARY.md
</context>

<feature>
  <name>Ghost Predicate E2E Driver Integration Test</name>
  <files>crates/driver/tests/ghost_predicate_e2e.rs</files>
  <behavior>
    Given: A GhostPredicateDatabase with predicate "is_positive(x)" := "x > 0"
    And: An IR Function named "test_ghost_e2e" with requires: ["is_positive(_1)"] and a single i32 param
    And: A VerificationTask wrapping that function with ghost_pred_db: Arc::new(db)
    When: verify_functions_parallel(vec![task], &mut cache, 1, false, false) is called
    Then: The result contains at least one VerificationResult for "test_ghost_e2e"
    And: At least one VerificationResult has a condition containing "precondition" or "requires" or "is_positive"
    (This proves ghost predicate "is_positive(_1)" was not silently dropped — it produced a VC)

    Contrast: Without Plan 01's wiring, ghost_pred_db is missing from VerificationTask.
    The db-less parse_spec_expr("is_positive(_1)", func) returns None for the ghost pred call.
    Zero precondition VCs are generated. The test would fail — confirming the RED state.

    Test cases:
    1. ghost_predicate_expands_to_vc_via_driver_path — main E2E test described above
    2. ghost_predicate_empty_db_is_backward_compatible — VerificationTask with GhostPredicateDatabase::new()
       and a plain spec like "_1 > 0" still produces the expected precondition VC (no regression)
  </behavior>
  <implementation>
    Follow TDD: RED → GREEN → REFACTOR.

    RED phase — create the test file calling a non-existent API path first.
    The test will fail compilation because VerificationTask doesn't yet have ghost_pred_db
    (this is intentional — Plan 01 adds it). But since Plan 01 is a dependency, by the
    time Plan 02 executes, VerificationTask already has the field. Instead, write the test
    first and confirm it FAILS at runtime (not compile-time) because zero precondition VCs
    are generated — simulate by temporarily using an empty GhostPredicateDatabase.

    Create `crates/driver/tests/ghost_predicate_e2e.rs`:

    ```rust
    //! End-to-end driver-level integration tests for SEP-04 ghost predicate production wiring.
    //!
    //! These tests exercise the FULL pipeline: VerificationTask → verify_functions_parallel()
    //! → verify_single() → generate_vcs_with_db() → parse_spec() → parse_spec_expr_with_db().
    //!
    //! Distinct from Phase 20 tests in crates/analysis/tests/sep_logic_integration.rs which
    //! call parse_spec_expr_with_db() directly (bypassing the driver path).

    use rust_fv_analysis::ghost_predicate_db::{GhostPredicate, GhostPredicateDatabase};
    use rust_fv_analysis::ir::{
        BasicBlock, Contracts, Function, IntTy, Local, SpecExpr, Statement, Terminator, Ty,
    };
    use rust_fv_driver::cache::VcCache;
    use rust_fv_driver::invalidation::{InvalidationDecision, InvalidationReason};
    use rust_fv_driver::parallel::{VerificationTask, verify_functions_parallel};
    use std::collections::HashMap;
    use std::path::PathBuf;
    use std::sync::Arc;

    fn temp_cache_dir(name: &str) -> PathBuf {
        let mut dir = std::env::temp_dir();
        dir.push(format!("rust-fv-ghost-e2e-{}-{}", name, std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        dir
    }

    fn make_ghost_test_func(requires_spec: &str) -> Function {
        Function {
            name: "test_ghost_e2e".to_string(),
            params: vec![Local::new("_1", Ty::Int(IntTy::I32))],
            return_local: Local::new("_0", Ty::Int(IntTy::I32)),
            locals: vec![],
            basic_blocks: vec![BasicBlock {
                statements: vec![Statement::Nop],
                terminator: Terminator::Return,
            }],
            contracts: Contracts {
                requires: vec![SpecExpr { raw: requires_spec.to_string() }],
                ensures: vec![],
                invariants: vec![],
                is_pure: false,
                decreases: None,
                fn_specs: vec![],
            },
            loops: vec![],
            generic_params: vec![],
            prophecies: vec![],
            lifetime_params: vec![],
            outlives_constraints: vec![],
            borrow_info: vec![],
            reborrow_chains: vec![],
            unsafe_blocks: vec![],
            unsafe_operations: vec![],
            unsafe_contracts: None,
            is_unsafe_fn: false,
            thread_spawns: vec![],
            atomic_ops: vec![],
            sync_ops: vec![],
            lock_invariants: vec![],
            concurrency_config: None,
            source_names: HashMap::new(),
        }
    }

    fn make_task(func: Function, db: GhostPredicateDatabase) -> VerificationTask {
        VerificationTask {
            name: func.name.clone(),
            ir_func: func,
            contract_db: Arc::new(rust_fv_analysis::contract_db::ContractDatabase::new()),
            ghost_pred_db: Arc::new(db),
            cache_key: [0u8; 32],
            mir_hash: [0u8; 32],
            contract_hash: [0u8; 32],
            dependencies: vec![],
            invalidation_decision: InvalidationDecision {
                should_verify: true,
                reason: InvalidationReason::Fresh,
            },
            source_locations: HashMap::new(),
        }
    }

    /// Main E2E test: ghost predicate in requires produces a VC through the driver pipeline.
    ///
    /// If ghost_pred_db is severed (not wired into VerificationTask or not passed to
    /// generate_vcs), parse_spec returns None for "is_positive(_1)" and zero precondition
    /// VCs are generated. This test fails in that case — proving the wiring is required.
    #[test]
    fn ghost_predicate_expands_to_vc_via_driver_path() {
        let mut db = GhostPredicateDatabase::new();
        db.insert(
            "is_positive".to_string(),
            GhostPredicate {
                param_names: vec!["x".to_string()],
                body_raw: "x > 0".to_string(),
            },
        );

        let func = make_ghost_test_func("is_positive(_1)");
        let task = make_task(func, db);

        let cache_dir = temp_cache_dir("expand");
        let mut cache = VcCache::new(cache_dir);

        let results = verify_functions_parallel(vec![task], &mut cache, 1, false, false);

        assert_eq!(results.len(), 1, "Must have one result for test_ghost_e2e");
        let task_results = &results[0].results;
        assert!(
            !task_results.is_empty(),
            "Must produce at least one VC result — ghost predicate was silently dropped if empty"
        );

        // The ghost predicate "is_positive(_1)" expands to "_1 > 0".
        // A precondition VC is generated and checked by Z3.
        // We assert a VC with precondition/requires in description exists.
        let has_pre_vc = task_results.iter().any(|r| {
            r.condition.to_lowercase().contains("precondition")
                || r.condition.to_lowercase().contains("requires")
                || r.condition.to_lowercase().contains("is_positive")
        });
        assert!(
            has_pre_vc,
            "Ghost predicate in requires must produce a precondition VC. Got: {:?}",
            task_results.iter().map(|r| &r.condition).collect::<Vec<_>>()
        );
    }

    /// Regression test: plain specs (no ghost predicates) still work with empty DB.
    ///
    /// Ensures generate_vcs_with_db with GhostPredicateDatabase::new() is backward-compatible
    /// and doesn't break existing plain requires specs.
    #[test]
    fn empty_ghost_pred_db_is_backward_compatible() {
        let func = make_ghost_test_func("_1 > 0");
        let task = make_task(func, GhostPredicateDatabase::new());

        let cache_dir = temp_cache_dir("compat");
        let mut cache = VcCache::new(cache_dir);

        let results = verify_functions_parallel(vec![task], &mut cache, 1, false, false);

        assert_eq!(results.len(), 1);
        let has_pre_vc = results[0].results.iter().any(|r| {
            r.condition.to_lowercase().contains("precondition")
                || r.condition.to_lowercase().contains("requires")
        });
        assert!(
            has_pre_vc,
            "Plain requires spec must still produce VC with empty ghost pred DB. Got: {:?}",
            results[0].results.iter().map(|r| &r.condition).collect::<Vec<_>>()
        );
    }
    ```

    RED: Run `cargo test -p rust-fv-driver -- ghost_predicate` and confirm test exists but
    may fail if InvalidationDecision struct fields differ. Inspect and adjust field names to
    match the actual struct. Commit: `test(24-02): RED — E2E driver integration test for SEP-04`

    GREEN: Fix any field name issues from the actual VerificationTask/InvalidationDecision
    structs (inspect crates/driver/src/parallel.rs and crates/driver/src/invalidation.rs for
    exact field names and constructors). Run tests until both pass.
    Commit: `feat(24-02): GREEN — E2E ghost predicate driver integration tests pass`

    REFACTOR: Run `cargo fmt --all` and `cargo clippy -p rust-fv-driver -- -D warnings`.
    Commit: `refactor(24-02): fmt and cleanup for ghost_predicate_e2e tests`
  </implementation>
</feature>

<verification>
```bash
cargo test -p rust-fv-driver -- ghost_predicate
cargo clippy -p rust-fv-driver -- -D warnings
cargo fmt --all --check
```

Both tests must pass:
- `ghost_predicate_expands_to_vc_via_driver_path` — PASS
- `empty_ghost_pred_db_is_backward_compatible` — PASS

Confirm the test file exercises verify_functions_parallel (not parse_spec_expr_with_db directly):
```bash
grep "verify_functions_parallel" /Users/alexanderfedin/Projects/hapyy/rust-fv/crates/driver/tests/ghost_predicate_e2e.rs
```
Must return at least one match.

Run full test suite to ensure no regressions from Phase 20/21/22:
```bash
cargo test -p rust-fv-analysis -p rust-fv-driver 2>&1 | tail -20
```
</verification>

<success_criteria>
- crates/driver/tests/ghost_predicate_e2e.rs exists
- ghost_predicate_expands_to_vc_via_driver_path test passes — confirms SEP-04 wiring end-to-end
- empty_ghost_pred_db_is_backward_compatible test passes — confirms no regression for plain specs
- Tests go through verify_functions_parallel(), NOT directly calling parse_spec_expr_with_db
- Full cargo test suite passes with zero new failures
- SEP-04 requirement marked complete in REQUIREMENTS.md
</success_criteria>

<output>
After completion, create `.planning/phases/24-sep04-ghost-predicate-wiring/24-02-SUMMARY.md`

Also update `.planning/REQUIREMENTS.md` to mark SEP-04 as `[x]` complete.
</output>

---
phase: 29.1-for-loop-iterator-range-vcgen
plan: "03"
subsystem: analysis/for_loop_vcgen
tags: [vcgen, for-loop, mir-detection, iterator, classification]
dependency_graph:
  requires: [29.1-02]
  provides: [VCGEN-01-FORLOOP]
  affects: [crates/analysis/src/for_loop_vcgen.rs, crates/analysis/tests/vcgen_completeness29_1.rs]
tech_stack:
  added: []
  patterns:
    - MIR substring matching for into_iter/::next/SwitchInt pattern detection
    - find_map + is_some_and chains for collapsible-if-safe pattern matching
    - Synthetic LoopInfo injection when no DFS back-edges detected
key_files:
  created: []
  modified:
    - crates/analysis/src/for_loop_vcgen.rs
    - crates/analysis/tests/vcgen_completeness29_1.rs
decisions:
  - classify_for_loop_iterators() uses detect_loops() as base, then fills None iterator_kind entries from MIR scan
  - Substring matching on callee name (not exact match) for nightly MIR robustness
  - Synthetic LoopInfo created when loops empty but pattern found — enables production driver path
  - derive_switchint_header() extracted as helper to avoid nested if-let chains (clippy collapsible_if)
  - Conservative fallback to Unknown IteratorKind rather than skipping — always emits at least one VC
metrics:
  duration: 540
  completed: "2026-02-26"
  tasks_completed: 2
  files_modified: 2
---

# Phase 29.1 Plan 03: MIR-Level For-Loop Detection Summary

**One-liner:** MIR into_iter+next+SwitchInt pattern detection in classify_for_loop_iterators() closes the gap between unit-test path (pre-populated loops) and production driver path (empty loops).

## What Was Built

### Task 1: classify_for_loop_iterators() + updated generate_for_loop_vcs()

Added `classify_for_loop_iterators(func: &Function) -> Vec<LoopInfo>` to `crates/analysis/src/for_loop_vcgen.rs`:

1. Calls `crate::vcgen::detect_loops(func)` to get the base loop list
2. Scans `func.basic_blocks` for the for-loop MIR desugaring pattern:
   - Block with `Terminator::Call` where callee contains `"into_iter"`
   - Whose target block has `Terminator::Call` where callee contains `"::next"`
   - Whose target block has `Terminator::SwitchInt`
3. When pattern found and loops empty: creates synthetic `LoopInfo` with the SwitchInt block as header
4. When pattern found and loops non-empty: fills in `None` iterator_kind entries
5. When no pattern found: returns loops unchanged

Iterator kind classification from callee name:
- `"Range"` or `"range"` in callee → `IteratorKind::Range { start: Literal(0), end: Local("n") }`
- `"slice"` or `"Iter"` in callee → `IteratorKind::SliceIter`
- `"vec"` or `"Vec"` in callee → `IteratorKind::VecIter`
- `"Enumerate"` in callee → `IteratorKind::Enumerate { inner: Unknown }`
- Otherwise → `IteratorKind::Unknown { description: callee }`

Updated `generate_for_loop_vcs()` to call `classify_for_loop_iterators(func)` instead of iterating `func.loops` directly.

Added helpers:
- `operand_local_name(op: &Operand) -> String` — extracts Place.local for collection classification
- `derive_switchint_header(func: &Function) -> usize` — traverses into_iter chain to find SwitchInt block index

### Task 2: Test 09 (vcgen_for_09_mir_range_detection)

Added `vcgen_for_09_mir_range_detection` to `crates/analysis/tests/vcgen_completeness29_1.rs`.

Constructs a 5-block function with the full MIR for-loop desugaring pattern:
- bb0: Call(into_iter) -> bb1
- bb1: Call(::next) -> bb2
- bb2: SwitchInt (loop header) -> [body: bb3, exit: bb4]
- bb3: Goto(bb1) (back-edge)
- bb4: Return

`func.loops` is empty (forces MIR classification path). Asserts that `generate_for_loop_vcs()` returns at least one VC.

## Test Results

```
running 9 tests
test vcgen_for_01_range_half_open ... ok
test vcgen_for_02_range_inclusive ... ok
test vcgen_for_03_range_literal ... ok
test vcgen_for_04_bounded_unrolling ... ok
test vcgen_for_05_slice_iter ... ok
test vcgen_for_06_enumerate ... ok
test vcgen_for_07_unknown_iterator ... ok
test vcgen_for_08_element_bounds_check ... ok
test vcgen_for_09_mir_range_detection ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

Full `cargo test -p rust-fv-analysis`: all test suites pass (0 failures).
`cargo clippy -p rust-fv-analysis -- -D warnings`: 0 errors.
`cargo fmt`: clean (no diffs).

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 1 - Bug] Operand::Const vs Operand::Constant**
- **Found during:** Task 1 build
- **Issue:** Plan specified `Operand::Const(_)` but the actual ir.rs enum variant is `Operand::Constant(_)`
- **Fix:** Changed to `Operand::Constant(_)` in `operand_local_name()`
- **Files modified:** `crates/analysis/src/for_loop_vcgen.rs`
- **Commit:** auto-fixed before first commit

**2. [Rule 2 - Clippy] 4 collapsible-if warnings → let-chain and find_map refactor**
- **Found during:** Task 1 clippy
- **Issue:** Nested `if let ... { if ... { } }` patterns triggered `clippy::collapsible_if` with `-D warnings`
- **Fix:** Rewrote all 4 patterns using `find_map`, `is_some_and`, and let-chain syntax (`&&` in if-let)
- **Extracted:** `derive_switchint_header()` as separate fn to avoid deep nesting
- **Files modified:** `crates/analysis/src/for_loop_vcgen.rs`
- **Commit:** included in Task 1 commit (cab150a)

## Commits

| Task | Commit | Message |
|------|--------|---------|
| 1 | cab150a | feat(29.1-03): add classify_for_loop_iterators() and update generate_for_loop_vcs() |
| 2 | db8b11c | test(29.1-03): add vcgen_for_09_mir_range_detection — MIR pattern integration test |

## Self-Check: PASSED

- [x] `crates/analysis/src/for_loop_vcgen.rs` — FOUND
- [x] `crates/analysis/tests/vcgen_completeness29_1.rs` — FOUND
- [x] Commit cab150a — FOUND (feat(29.1-03): add classify_for_loop_iterators()...)
- [x] Commit db8b11c — FOUND (test(29.1-03): add vcgen_for_09_mir_range_detection...)
- [x] All 9 vcgen_completeness29_1 tests GREEN
- [x] Full cargo test -p rust-fv-analysis: 0 failures
- [x] clippy -D warnings: 0 errors
- [x] rustfmt: clean

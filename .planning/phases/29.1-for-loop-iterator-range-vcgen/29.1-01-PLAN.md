---
phase: 29.1-for-loop-iterator-range-vcgen
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/analysis/src/ir.rs
  - crates/analysis/tests/vcgen_completeness29_1.rs
autonomous: true
requirements:
  - VCGEN-01-FORLOOP
must_haves:
  truths:
    - "8 RED tests exist in vcgen_completeness29_1.rs and all fail to compile or fail at runtime"
    - "IteratorKind enum exists in ir.rs with Range/RangeInclusive/SliceIter/VecIter/Enumerate/StdAdapter/Unknown variants"
    - "RangeBound enum exists in ir.rs with Literal(i128) and Local(String) variants"
    - "LoopInfo struct in ir.rs has iterator_kind: Option<IteratorKind> and loop_var: Option<String> fields"
    - "All existing tests still compile and pass after LoopInfo extension"
  artifacts:
    - path: "crates/analysis/tests/vcgen_completeness29_1.rs"
      provides: "8 RED TDD tests for for-loop VCGen"
    - path: "crates/analysis/src/ir.rs"
      provides: "IteratorKind, RangeBound enums; LoopInfo extended with iterator_kind and loop_var"
  key_links:
    - from: "crates/analysis/tests/vcgen_completeness29_1.rs"
      to: "crates/analysis/src/ir.rs"
      via: "use rust_fv_analysis::ir::IteratorKind"
      pattern: "IteratorKind"
---

<objective>
Create the TDD scaffold for Phase 29.1 and extend the IR with `IteratorKind` classification.

Purpose: All 8 tests must fail RED before any for-loop VCGen code is written (TDD discipline). The IR extension is required for test construction (tests reference `IteratorKind` variants) and is backward-compatible via `Option<>` fields.

Output:
- `crates/analysis/tests/vcgen_completeness29_1.rs` — 8 RED tests
- `crates/analysis/src/ir.rs` — `IteratorKind`, `RangeBound` enums; `LoopInfo` extended
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-CONTEXT.md
@.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-RESEARCH.md

<interfaces>
<!-- From crates/analysis/src/ir.rs — current LoopInfo (to be extended): -->
```rust
#[derive(Debug, Clone)]
pub struct LoopInfo {
    pub header_block: BlockId,
    pub back_edge_blocks: Vec<BlockId>,
    pub invariants: Vec<SpecExpr>,
    // Fields to ADD: iterator_kind: Option<IteratorKind>, loop_var: Option<String>
}
```

<!-- From crates/analysis/tests/vcgen_completeness29.rs — make_func helper pattern: -->
```rust
fn make_func(name: &str, return_ty: Ty, params: Vec<Local>, locals: Vec<Local>, basic_blocks: Vec<BasicBlock>) -> Function {
    Function {
        name: name.to_string(),
        return_local: Local::new("_0", return_ty),
        params, locals, basic_blocks,
        contracts: Contracts::default(),
        loops: vec![],
        generic_params: vec![], prophecies: vec![],
        lifetime_params: vec![], outlives_constraints: vec![],
        borrow_info: vec![], reborrow_chains: vec![],
        unsafe_blocks: vec![], unsafe_operations: vec![],
        unsafe_contracts: None, is_unsafe_fn: false,
        thread_spawns: vec![], atomic_ops: vec![],
        sync_ops: vec![], lock_invariants: vec![],
        concurrency_config: None,
        source_names: std::collections::HashMap::new(),
        coroutine_info: None,
    }
}
```

<!-- From crates/analysis/src/vcgen.rs — VcKind variants in use: -->
```rust
pub enum VcKind {
    LoopInvariantExit,
    MemorySafety,
    // ... others
}
```
</interfaces>
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Extend LoopInfo with IteratorKind (IR extension — RED prerequisite)</name>
  <files>crates/analysis/src/ir.rs</files>
  <action>
Add the following to `crates/analysis/src/ir.rs` BEFORE the `LoopInfo` struct definition (search for `pub struct LoopInfo`):

```rust
/// Classification of the iterator source for a for-loop.
#[derive(Debug, Clone, PartialEq)]
pub enum IteratorKind {
    /// Integer range: `start..end` (half-open)
    Range { start: RangeBound, end: RangeBound },
    /// Integer range: `start..=end` (closed/inclusive)
    RangeInclusive { start: RangeBound, end: RangeBound },
    /// Slice or array iteration by reference: `slice.iter()` / `&arr`
    SliceIter { collection_local: String },
    /// Vec iteration by reference: `vec.iter()`
    VecIter { collection_local: String },
    /// Enumerated iteration: `.enumerate()` over any of the above
    Enumerate { inner: Box<IteratorKind> },
    /// Known std adapter: `.map()`, `.filter()`, `.zip()`, `.take()`, `.skip()`, etc.
    StdAdapter { name: String, inner: Box<IteratorKind> },
    /// Unknown/custom iterator — conservative BoolLit(true) VC
    Unknown { description: String },
}

/// A range bound: either a statically-known integer or a runtime local variable.
#[derive(Debug, Clone, PartialEq)]
pub enum RangeBound {
    /// Compile-time known integer constant
    Literal(i128),
    /// Runtime local (e.g., function parameter or computation result).
    /// Uses `{local}_len` naming for slice/vec lengths (consistent with Phase 28).
    Local(String),
}
```

Then extend `LoopInfo` by adding two optional fields at the end of the struct:
```rust
    /// For-loop iterator classification (None for while/loop)
    pub iterator_kind: Option<IteratorKind>,
    /// Loop variable local name (e.g., "_5") when classified as for-loop
    pub loop_var: Option<String>,
```

Fix all construction sites of `LoopInfo { .. }` in the codebase by adding `iterator_kind: None, loop_var: None`. Search for `LoopInfo {` in both `vcgen.rs` and test files to find all construction sites.

Run `cargo clippy -p rust-fv-analysis 2>&1 | head -50` to find remaining construction errors and fix them.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis detect_loops 2>&1 | tail -5</automated>
  </verify>
  <done>ir.rs compiles; IteratorKind and RangeBound enums exist; LoopInfo has iterator_kind and loop_var fields; all existing detect_loops tests pass</done>
</task>

<task type="tdd">
  <name>Task 2: Write 8 RED tests in vcgen_completeness29_1.rs</name>
  <files>crates/analysis/tests/vcgen_completeness29_1.rs</files>
  <action>
Create `crates/analysis/tests/vcgen_completeness29_1.rs` with 8 RED tests. All tests must reference `generate_for_loop_vcs` which does not yet exist — they will be RED by compilation failure or by explicit `#[should_panic]`/`todo!()` pattern.

Follow the pattern from `vcgen_completeness29.rs` exactly (same helper functions, same imports, same `script_to_text` helper).

The file must:
1. Import `rust_fv_analysis::ir::*` and `rust_fv_analysis::vcgen` (same as vcgen_completeness29.rs)
2. Import `rust_fv_analysis::for_loop_vcgen::generate_for_loop_vcs` (this will fail to compile until Plan 02 creates the module — that is CORRECT for RED state)
3. Include the standard `make_func` helper copied from vcgen_completeness29.rs
4. Include `script_to_text` helper copied from vcgen_completeness29.rs

Tests to write (all reference `generate_for_loop_vcs`):

**vcgen_for_01_range_half_open**: Build a Function with a LoopInfo containing `IteratorKind::Range { start: RangeBound::Literal(0), end: RangeBound::Local("n".to_string()) }`. Call `generate_for_loop_vcs(&func, &GhostPredicateDatabase::default())`. Assert that at least one VC is returned and that at least one VC's script text contains `"AUFLIA"` and `"forall"`.

**vcgen_for_02_range_inclusive**: Same but with `IteratorKind::RangeInclusive { start: RangeBound::Literal(0), end: RangeBound::Local("n".to_string()) }`. Assert script contains `"AUFLIA"` and `"forall"`. The end-bound guard must use `<=` (IntLe) not `<` (IntLt) — assert script text contains `"<="` but NOT `"(< i n)"` for the end bound (use a regex or substring check appropriate to your SMT rendering).

**vcgen_for_03_range_literal**: Use `IteratorKind::Range { start: RangeBound::Literal(0), end: RangeBound::Literal(5) }`. Assert that NO `DeclareConst` for a bound variable appears in the script (literal 5 is embedded inline, not declared as a constant).

**vcgen_for_04_bounded_unrolling**: Same as test 01 but check that at least one VC's script contains `"QF_LIA"` (the bounded unrolling VC, separate from the AUFLIA quantified VC). Two VCs total for a range loop.

**vcgen_for_05_slice_iter**: Use `IteratorKind::SliceIter { collection_local: "arr".to_string() }`. Assert at least one VC's script contains `"arr_len"` (the Phase 28 `{arr}_len` naming).

**vcgen_for_06_enumerate**: Use `IteratorKind::Enumerate { inner: Box::new(IteratorKind::SliceIter { collection_local: "arr".to_string() }) }`. Assert at least one VC declares both `"index_"` and `"elem_"` SMT constants.

**vcgen_for_07_unknown_iterator**: Use `IteratorKind::Unknown { description: "CustomIter".to_string() }`. Assert exactly one VC is returned and its script contains `"true"` (conservative BoolLit(true) VC).

**vcgen_for_08_element_bounds_check**: Use `IteratorKind::SliceIter { collection_local: "data".to_string() }`, and set `loop_var: Some("_5".to_string())` on the LoopInfo. Assert that at least one VC has `vc_kind == VcKind::MemorySafety`.

Import `GhostPredicateDatabase` from `rust_fv_analysis::ghost_predicate_db::GhostPredicateDatabase`.

The file should NOT have `#![allow(dead_code)]` — let rustc flag unused items normally. All 8 tests use `#[test]` (not `#[ignore]`).

After writing, confirm RED state:
```
cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1 | tail -20
```
Expected: compilation failure because `for_loop_vcgen` module does not exist yet. This is correct RED state.
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1 | grep -E "error\[|cannot find module|unresolved import|FAILED|error" | head -10</automated>
  </verify>
  <done>vcgen_completeness29_1.rs exists with 8 tests; cargo test fails with compilation error about missing for_loop_vcgen module (RED state confirmed); all other tests still pass</done>
</task>

</tasks>

<verification>
```
cargo test -p rust-fv-analysis detect_loops 2>&1 | tail -5
cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1 | grep -E "error|cannot find" | head -5
cargo test -p rust-fv-analysis vcgen_completeness28 2>&1 | tail -5
```
Expected: detect_loops tests PASS, vcgen_completeness29_1 fails compilation (RED), vcgen_completeness28 PASS.
</verification>

<success_criteria>
- IteratorKind and RangeBound enums exist in ir.rs
- LoopInfo has iterator_kind and loop_var optional fields
- All existing tests compile and pass
- vcgen_completeness29_1.rs has 8 tests that fail compilation (RED) due to missing for_loop_vcgen module
</success_criteria>

<output>
After completion, create `.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-01-SUMMARY.md`
</output>

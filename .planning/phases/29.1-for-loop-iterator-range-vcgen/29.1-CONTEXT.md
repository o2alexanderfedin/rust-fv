# Phase 29.1: For-loop Iterator Range VCGen - Context

**Gathered:** 2026-02-25
**Status:** Ready for planning

<domain>
## Phase Boundary

Add VCGen support for `for` loops over ranges and iterators so the SMT-LIB generator produces
verification conditions for loop bodies, bounds, and iterator-based patterns. VCGEN-01 was
partial — for/range/slice handling was deferred from v0.5. This phase closes that gap.

Scope: Range (`0..n`, `0..=n`), slice/Vec iteration, `.enumerate()`, and all standard library
iterator adapters. Custom/unknown iterator types and loop invariant annotations are handled
conservatively (see below). Loop termination proofs and non-standard iterator types are out of scope.

</domain>

<decisions>
## Implementation Decisions

### Loop invariant strategy
- Annotations (`#[invariant(...)]`, `#[ensures(...)]` on loops) are **always optional and
  second-class** — VCGen must produce sound output from AST/MIR alone with zero annotations.
- **Dual encoding**: use universal quantification (`forall i in [start, end): body_vc(i)`) for
  postcondition VCs (soundness/completeness), and bounded unrolling (configurable N, default 5)
  for counterexample generation (concreteness).
- When an `#[invariant]` annotation IS present, Claude decides how to incorporate it (inductive
  style: assume at entry, verify preservation, verify it implies postcondition — but never required).
- Logic: AUFLIA (consistent with Phase 22 HOF VCs which already use universal quantification).

### Range encoding in SMT
- Loop variable `i` encoded as QF_LIA `Int` with explicit bounds constraints — consistent with
  Phase 23 async VCs which use QF_LIA for bounded enumeration.
- Half-open range `0..n`: `assert(0 <= i && i < n)`.
- Closed range `0..=n`: `assert(0 <= i && i <= n)` — distinct from half-open.
- Range bound `n` when statically known: use concrete literal. When runtime variable: derive
  the value where possible from the MIR/IR; if not derivable, declare as uninterpreted Int
  constant (consistent with `{arr}_len` pattern from Phase 28).
- Slice/Vec length reuses `{arr}_len` named constant from Phase 28 `Rvalue::Len` encoding —
  same constant, same semantics.

### Iterator abstraction scope
- **In scope for Phase 29.1:**
  - `Range`: `0..n` and `0..=n` (integer ranges)
  - Slice iteration: `slice.iter()`, `&arr` (by reference)
  - Vec iteration: `vec.iter()` (by reference)
  - `.enumerate()` — tuple destructured at VCGen level into two SMT constants:
    `index_i: Int` and `elem_i: T` (consistent with aggregate decomposition in existing VCGen)
  - All std iterator adapters: `.map()`, `.filter()`, `.zip()`, `.take()`, `.skip()`,
    `.flat_map()`, `.chain()`, `.peekable()`, etc.
- **Adapter fallback:** When an adapter's SMT encoding is complex or unclear, emit
  `BoolLit(true)` (conservative VC) with a `// TODO: encode {adapter_name}` comment —
  consistent with Phase 22 best-effort stub pattern. Does not block surrounding verification.
- **Bounds-check VCs:** Element access inside loop body emits bounds-check VC
  (`0 <= i < {arr}_len`) — consistent with Phase 28 `BoundsCheck` VCs using `VcKind::MemorySafety`.
- **MIR-level recognition:** Detect the desugared MIR pattern for `for` loops
  (`IntoIterator::into_iter()` + loop block + `.next()` + `Option` `SwitchInt`) — consistent
  with how all existing VCGen operates at the `after_analysis` MIR hook.

### Unsupported / unknown iterator behavior
- **Custom/unknown iterator types** (not Range, slice, Vec, or std adapters): emit
  `BoolLit(true)` conservative VC **plus** a structured diagnostic warning visible in
  verification output (e.g., "iterator pattern not fully supported — VC is conservative for
  this loop").
- **Loop termination:** Assume all supported iterator types are finite (Range/slice/Vec/std
  adapters are provably finite). Claude decides whether to emit a trivial `assert(len >= 0)`
  termination VC for documentation purposes.
- **Option::None branch** (desugared loop exit): no separate VC — handled as part of the
  loop bound constraint.

### Claude's Discretion
- Exact SMT logic selection per VC type (AUFLIA vs QF_LIA depending on whether quantifiers
  appear in that specific VC).
- How `#[invariant]` annotations are incorporated when present (inductive style is the intent).
- Whether a trivial termination VC is emitted for supported iterators.
- Exact adapter encoding for each std adapter (`.map()` element transform, `.filter()` predicate
  guard, `.zip()` pair modeling, etc.).
- Integration with existing `encode_*` / `generate_vcs_with_db` APIs.

</decisions>

<specifics>
## Specific Ideas

- Consistency is paramount: reuse `{arr}_len` from Phase 28, `VcKind::MemorySafety` for bounds
  checks, AUFLIA for quantified VCs (Phase 22), QF_LIA for non-quantified integer constraints (Phase 23).
- "Reasonably choose towards safety, precision, and completeness" — the user's consistent
  preference means: when in doubt, emit a VC rather than skip it; use quantification rather
  than unsound abstraction; preserve the forall+bounded-unroll duality.
- Annotations are second-class throughout the entire codebase, not just this phase. VCGen should
  be complete without them.

</specifics>

<deferred>
## Deferred Ideas

- Non-std / custom iterator type encoding beyond conservative VC — future phase
- Iterator adapter chains with complex semantics (e.g., `.flat_map()` full encoding) — may be
  partially stubbed in this phase per the BoolLit(true) fallback rule
- Mutable iteration (`iter_mut()`, `into_iter()` with ownership transfer) — separate phase
- Loop termination proofs for custom iterators — separate phase

</deferred>

---

*Phase: 29.1-for-loop-iterator-range-vcgen*
*Context gathered: 2026-02-25*

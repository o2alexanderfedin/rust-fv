# Phase 29.1: For-loop Iterator Range VCGen - Research

**Researched:** 2026-02-25
**Domain:** Rust MIR for-loop VCGen — SMT-LIB encoding of iterator-based loops
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Loop invariant strategy:**
- Annotations (`#[invariant(...)]`, `#[ensures(...)]` on loops) are always optional and second-class — VCGen must produce sound output from AST/MIR alone with zero annotations.
- **Dual encoding**: use universal quantification (`forall i in [start, end): body_vc(i)`) for postcondition VCs (soundness/completeness), and bounded unrolling (configurable N, default 5) for counterexample generation (concreteness).
- When an `#[invariant]` annotation IS present, Claude decides how to incorporate it (inductive style: assume at entry, verify preservation, verify it implies postcondition — but never required).
- Logic: AUFLIA (consistent with Phase 22 HOF VCs which already use universal quantification).

**Range encoding in SMT:**
- Loop variable `i` encoded as QF_LIA `Int` with explicit bounds constraints.
- Half-open range `0..n`: `assert(0 <= i && i < n)`.
- Closed range `0..=n`: `assert(0 <= i && i <= n)` — distinct from half-open.
- Range bound `n` when statically known: use concrete literal. When runtime variable: declare as uninterpreted Int constant (consistent with `{arr}_len` pattern from Phase 28).
- Slice/Vec length reuses `{arr}_len` named constant from Phase 28 `Rvalue::Len` encoding.

**Iterator abstraction scope (in scope):**
- `Range`: `0..n` and `0..=n` (integer ranges)
- Slice iteration: `slice.iter()`, `&arr` (by reference)
- Vec iteration: `vec.iter()` (by reference)
- `.enumerate()` — tuple destructured into two SMT constants: `index_i: Int` and `elem_i: T`
- All std iterator adapters: `.map()`, `.filter()`, `.zip()`, `.take()`, `.skip()`, `.flat_map()`, `.chain()`, `.peekable()`, etc.
- **Adapter fallback:** BoolLit(true) conservative VC with `// TODO: encode {adapter_name}` comment
- **Bounds-check VCs:** Element access inside loop body emits bounds-check VC (`0 <= i < {arr}_len`) using `VcKind::MemorySafety`
- **MIR-level recognition:** Detect desugared MIR pattern for `for` loops (`IntoIterator::into_iter()` + loop block + `.next()` + `Option` `SwitchInt`)

**Unsupported / unknown iterator behavior:**
- Custom/unknown iterator types: emit `BoolLit(true)` conservative VC plus structured diagnostic warning
- Loop termination: assume all supported iterator types are finite (Range/slice/Vec/std adapters are provably finite)
- `Option::None` branch (desugared loop exit): no separate VC — handled as part of loop bound constraint

### Claude's Discretion
- Exact SMT logic selection per VC type (AUFLIA vs QF_LIA depending on whether quantifiers appear in that specific VC)
- How `#[invariant]` annotations are incorporated when present (inductive style is the intent)
- Whether a trivial termination VC is emitted for supported iterators
- Exact adapter encoding for each std adapter (`.map()` element transform, `.filter()` predicate guard, `.zip()` pair modeling, etc.)
- Integration with existing `encode_*` / `generate_vcs_with_db` APIs

### Deferred Ideas (OUT OF SCOPE)
- Non-std / custom iterator type encoding beyond conservative VC — future phase
- Iterator adapter chains with complex semantics (e.g., `.flat_map()` full encoding) — may be partially stubbed in this phase per the BoolLit(true) fallback rule
- Mutable iteration (`iter_mut()`, `into_iter()` with ownership transfer) — separate phase
- Loop termination proofs for custom iterators — separate phase
</user_constraints>

---

## Summary

Phase 29.1 adds VCGen support for Rust `for` loops over iterators and ranges. This closes the VCGEN-01 gap deferred from v0.5: the current VCGen completely skips for-loop bodies, producing no verification conditions for their contents. The existing `detect_loops()` / `generate_loop_invariant_vcs()` infrastructure handles `while`/`loop` with user-supplied invariants but has no for-loop-specific encoding.

The implementation requires two complementary strategies: (1) a **quantified (AUFLIA) VC** that uses `forall i in [start, end): body_vc(i)` for soundness, and (2) a **bounded unrolling VC** (default depth 5) for counterexample generation. Both operate on the existing IR's `LoopInfo` struct. The key new work is: (a) detecting for-loop patterns in the CFG (by recognizing the `IntoIterator::into_iter()` + `.next()` + `SwitchInt(Option)` MIR desugaring), (b) classifying the iterator source (Range, slice/Vec, enumerate, adapters), and (c) emitting appropriate SMT terms.

The phase fits cleanly into the existing architecture: a new `for_loop_vcgen.rs` module (following `async_vcgen.rs` and `hof_vcgen.rs` patterns) provides `generate_for_loop_vcs(func)` that is called from `generate_vcs_with_db()`. IR extensions are minimal: `LoopInfo` needs an optional `iterator_kind: Option<IteratorKind>` field and `ForLoopInfo` for range bounds. A TDD scaffold of 6-8 tests in `vcgen_completeness29_1.rs` should be written RED-first.

**Primary recommendation:** Implement `for_loop_vcgen.rs` as a self-contained module parallel to `async_vcgen.rs`. Extend `LoopInfo` with `IteratorKind`. Wire in `generate_vcs_with_db`. TDD-first with `vcgen_completeness29_1.rs`.

---

## Standard Stack

### Core
| Component | Version/Location | Purpose | Why This |
|-----------|-----------------|---------|---------|
| `rust_fv_smtlib::term::Term` | crates/smtlib | SMT-LIB term algebra | All VCGen uses this; `Term::Forall` already exists |
| `rust_fv_smtlib::command::Command` | crates/smtlib | SMT-LIB command building | Same as all other VCGen modules |
| `rust_fv_smtlib::sort::Sort::Int` | crates/smtlib | Sort for loop index variable | QF_LIA/AUFLIA integer sort for loop index |
| `crate::vcgen::{VcKind, VcLocation, VerificationCondition}` | analysis/src/vcgen.rs | VC struct reuse | All VC modules return these same types |
| `crate::ir::{LoopInfo, Function, Terminator, Statement, Rvalue}` | analysis/src/ir.rs | IR types for loop detection | Existing loop structure |

### Supporting
| Component | Version/Location | Purpose | When to Use |
|-----------|-----------------|---------|-------------|
| `crate::encode_term::len_constant_name()` | analysis/src/encode_term.rs | Generates `{arr}_len` constant name | Slice/Vec iteration bounds |
| `crate::encode_term::bounds_check_term()` | analysis/src/encode_term.rs | Generates `0 <= idx && idx < len` VC | Element access bounds checks in loop body |
| `crate::spec_parser::parse_spec_expr` | analysis/src/spec_parser.rs | Parse invariant annotation strings | When `#[invariant]` present |
| `detect_loops()` (existing) | analysis/src/vcgen.rs:2610 | Returns `Vec<LoopInfo>` | For-loop detection builds on this |
| AUFLIA logic | SMT standard | Universal quantification over Int | Postcondition quantified VCs |
| QF_LIA logic | SMT standard | Non-quantified integer VCs | Bounded unrolling VCs |

### No New Dependencies Required

This phase requires zero new Cargo dependencies. All SMT building blocks exist in `crates/smtlib/`. All IR types exist in `crates/analysis/src/ir.rs`. All VC infrastructure exists in `crates/analysis/src/vcgen.rs`.

---

## Architecture Patterns

### Recommended File Structure
```
crates/analysis/src/
├── for_loop_vcgen.rs         # NEW: Main module for for-loop VCs
├── vcgen.rs                  # MODIFIED: call generate_for_loop_vcs() from generate_vcs_with_db()
├── ir.rs                     # MODIFIED: add IteratorKind enum and extend LoopInfo
└── ...

crates/analysis/tests/
└── vcgen_completeness29_1.rs  # NEW: TDD scaffold (RED-first)
```

### Pattern 1: Module Structure (Mirror async_vcgen.rs)

**What:** Self-contained module with one public entry point called from `generate_vcs_with_db()`.
**When to use:** All new VC generation categories.

```rust
// Source: crates/analysis/src/async_vcgen.rs (established pattern)
// crates/analysis/src/for_loop_vcgen.rs

pub fn generate_for_loop_vcs(
    func: &Function,
    ghost_pred_db: &GhostPredicateDatabase,
) -> Vec<VerificationCondition> {
    let detected = detect_for_loops(func);
    if detected.is_empty() {
        return vec![];
    }

    let mut vcs = Vec::new();
    for fl in &detected {
        // 1. Quantified (AUFLIA) VC: forall i in [start, end): body_vc(i)
        vcs.extend(generate_quantified_vc(func, fl, ghost_pred_db));
        // 2. Bounded unrolling VC (default N=5) for counterexample
        vcs.extend(generate_bounded_unrolling_vc(func, fl, ghost_pred_db, 5));
        // 3. Bounds-check VCs for element accesses inside body
        vcs.extend(generate_loop_bounds_vcs(func, fl));
    }
    vcs
}
```

### Pattern 2: IR Extension — IteratorKind and LoopInfo

**What:** Extend `LoopInfo` with an optional `iterator_kind` field; add `IteratorKind` enum.
**When to use:** Phase 29.1 needs to classify loop sources. Future phases build on this.

```rust
// Source: crates/analysis/src/ir.rs — extend existing LoopInfo

/// Classification of the iterator source for a for-loop.
#[derive(Debug, Clone, PartialEq)]
pub enum IteratorKind {
    /// Integer range: `start..end` (half-open)
    Range { start: RangeBound, end: RangeBound },
    /// Integer range: `start..=end` (closed/inclusive)
    RangeInclusive { start: RangeBound, end: RangeBound },
    /// Slice or array iteration by reference: `slice.iter()` / `&arr`
    SliceIter { collection_local: String },
    /// Vec iteration by reference: `vec.iter()`
    VecIter { collection_local: String },
    /// Enumerated iteration: `.enumerate()` over any of the above
    Enumerate { inner: Box<IteratorKind> },
    /// Known std adapter: `.map()`, `.filter()`, `.zip()`, `.take()`, `.skip()`, etc.
    StdAdapter { name: String, inner: Box<IteratorKind> },
    /// Unknown/custom iterator — conservative BoolLit(true) VC
    Unknown { description: String },
}

/// A range bound: either a statically-known integer or a runtime local variable.
#[derive(Debug, Clone, PartialEq)]
pub enum RangeBound {
    /// Compile-time known integer constant
    Literal(i128),
    /// Runtime local (e.g., function parameter or computation result)
    /// Uses `{local}_len` naming for slice/vec lengths (consistent with Phase 28)
    Local(String),
}

// Extend existing LoopInfo:
pub struct LoopInfo {
    pub header_block: BlockId,
    pub back_edge_blocks: Vec<BlockId>,
    pub invariants: Vec<SpecExpr>,
    /// For-loop iterator classification (None for while/loop)
    pub iterator_kind: Option<IteratorKind>,  // NEW
    /// Loop variable local name (e.g., "_5") when classified as for-loop
    pub loop_var: Option<String>,              // NEW
}
```

### Pattern 3: Quantified VC (AUFLIA)

**What:** `forall i: Int. (start <= i < end) => body_vc(i)` negated to check violations.
**When to use:** Postcondition VCs for all classified for-loops. Uses AUFLIA (consistent with Phase 22).

```rust
// Source: mirrors hof_vcgen.rs AUFLIA pattern + Phase 22 decision
fn generate_quantified_vc(
    func: &Function,
    fl: &ForLoopInfo,
    ghost_pred_db: &GhostPredicateDatabase,
) -> Vec<VerificationCondition> {
    let mut script = Script::new();

    // AUFLIA for universal quantification (consistent with Phase 22)
    script.push(Command::SetLogic("AUFLIA".to_string()));

    // Declare range bounds as Int constants if runtime
    // (consistent with {arr}_len pattern from Phase 28)
    let start_term = declare_range_bound(&fl.start, "start", &mut script);
    let end_term   = declare_range_bound(&fl.end, "end", &mut script);

    // Loop body VC as a function of i
    // (not (forall ((i Int)) (=> (and (<= start i) (< i end)) body_vc)))
    let i_var = ("i".to_string(), Sort::Int);
    let range_guard = Term::And(vec![
        Term::IntLe(Box::new(start_term.clone()), Box::new(Term::Const("i".to_string()))),
        Term::IntLt(Box::new(Term::Const("i".to_string())), Box::new(end_term.clone())),
    ]);
    let body_vc = encode_loop_body_vc(func, fl, &Term::Const("i".to_string()), ghost_pred_db);

    let forall_term = Term::Forall(
        vec![i_var],
        Box::new(Term::Implies(Box::new(range_guard), Box::new(body_vc))),
    );
    script.push(Command::Assert(Term::Not(Box::new(forall_term))));
    script.push(Command::CheckSat);
    // ...
}
```

### Pattern 4: Bounded Unrolling VC (QF_LIA, N=5 default)

**What:** Unroll loop N times with concrete i=start, start+1, ..., start+N-1 and check body_vc each time.
**When to use:** Counterexample generation (concreteness). Uses QF_LIA (no quantifiers needed).

```rust
// QF_LIA for bounded unrolling — consistent with Phase 23 async VCs
fn generate_bounded_unrolling_vc(
    func: &Function,
    fl: &ForLoopInfo,
    ghost_pred_db: &GhostPredicateDatabase,
    unroll_depth: usize,
) -> Vec<VerificationCondition> {
    let mut script = Script::new();
    script.push(Command::SetLogic("QF_LIA".to_string()));
    // Unroll: for each k in 0..unroll_depth, assert (start + k < end) => body_vc(start + k)
    // Bounded — does not need quantifiers
    // ...
}
```

### Pattern 5: MIR Pattern Recognition for For-loops

**What:** Detect the desugared `for` loop pattern in MIR CFG: `into_iter()` call + loop-back `SwitchInt` on `Option` discriminant.
**When to use:** `detect_for_loops()` in `for_loop_vcgen.rs`.

```
MIR desugaring of `for x in collection { body }`:
  bb0: _iter = IntoIterator::into_iter(collection)  [Terminator::Call]
  bb1: _opt  = Iterator::next(&mut _iter)            [Terminator::Call]
       SwitchInt(_opt.discriminant) -> [1: bb2(body), otherwise: bb3(exit)]
  bb2: _x    = _opt.field(0)  // Some(x)
       ... body ...
       Goto(bb1)              // back-edge to loop header
  bb3: return
```

Detection strategy:
1. Find blocks where `Terminator::Call { func: "..::into_iter..", .. }` — these are loop entries
2. Find the successor block's `SwitchInt` on a discriminant
3. The back-edge target of the SwitchInt is the loop header
4. The callee name determines `IteratorKind`:
   - `core::ops::range::Range` / `..` → `IteratorKind::Range`
   - `slice::Iter` → `IteratorKind::SliceIter`
   - `vec::IntoIter` / `Vec::iter` → `IteratorKind::VecIter`
   - `Enumerate` → `IteratorKind::Enumerate`
   - Known adapter names → `IteratorKind::StdAdapter`
   - Unknown → `IteratorKind::Unknown`

### Pattern 6: Call-site Wiring in generate_vcs_with_db

**What:** Add `generate_for_loop_vcs` call immediately after the existing `detect_loops()` / `generate_loop_invariant_vcs()` block.
**When to use:** This is the integration point — consistent with how `async_vcgen` and `hof_vcgen` are wired.

```rust
// Source: crates/analysis/src/vcgen.rs — generate_vcs_with_db()
// ADD AFTER existing loop invariant block (line ~735):

// FOR-01 / FOR-02: Generate for-loop iterator VCs
{
    let for_vcs = crate::for_loop_vcgen::generate_for_loop_vcs(func, ghost_pred_db);
    if !for_vcs.is_empty() {
        tracing::debug!(
            function = %func.name,
            for_vc_count = for_vcs.len(),
            "Generated for-loop iterator VCs"
        );
        conditions.extend(for_vcs);
    }
}
```

### Anti-Patterns to Avoid

- **Modifying enumerate_paths() for loops:** The existing path enumeration handles non-looping CFGs. For-loop VCs should be generated as a separate pass, not by trying to enumerate infinite paths. Use the dedicated `generate_for_loop_vcs()` pattern.
- **Emitting BV sort in AUFLIA scripts:** AUFLIA is arrays + uninterpreted functions + linear integer arithmetic. BitVec sorts are invalid. Use `encode_type_for_auflia()` (established in Phase 22, decision: "encode_type_for_auflia() replaces encode_type() for AUFLIA safety").
- **Mixing quantified and non-quantified VCs in same script:** Quantified (AUFLIA) VCs and bounded unrolling (QF_LIA) VCs are separate scripts/separate `VerificationCondition` instances.
- **Panicking on unknown iterator:** Always return `BoolLit(true)` conservative VC plus diagnostic warning, never panic. Consistent with Phase 22 best-effort stub pattern.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Slice/Vec length constant naming | Custom `len_` prefix scheme | `encode_term::len_constant_name(arr_local)` | Phase 28 established `{arr}_len` — reuse for consistency |
| Bounds check VC generation | Custom `0 <= i < len` term | `encode_term::bounds_check_term(idx, idx_bits, len)` | Phase 28 implemented this; semantics tested |
| SMT sort for Int | Custom sort handling | `Sort::Int` from smtlib | Standard; QF_LIA/AUFLIA both accept it |
| Loop back-edge detection | Custom DFS | `detect_loops()` in vcgen.rs | Already implemented and tested |
| AUFLIA script scaffolding | New script builder | Mirror `hof_vcgen::build_fn_vc_script()` | AUFLIA pattern with `Command::SetLogic("AUFLIA")` + `Term::Forall` is proven |
| Invariant annotation parsing | New parser | `spec_parser::parse_spec_expr()` | Existing spec parser handles invariant strings |
| VC struct construction | New struct | `VerificationCondition { description, script, location }` | Same struct as all other VCs |

**Key insight:** This phase is primarily about *gluing existing building blocks correctly*, not building new infrastructure. The SMT encoding primitives (sorts, terms, quantifiers, bounds checks) all exist.

---

## Common Pitfalls

### Pitfall 1: AUFLIA Encodes Loop Variable as Int, But Body Uses BV Operations

**What goes wrong:** Loop body may reference integer arithmetic that was originally encoded as BitVec in the function's main declarations. When the AUFLIA VC substitutes `i: Int`, BV terms leak into the AUFLIA script.
**Why it happens:** The main function declarations use `QF_BV` sorts; AUFLIA scripts need `Int` sorts.
**How to avoid:** Use `encode_type_for_auflia()` (Phase 22 decision) for all type encoding inside for-loop quantified VCs. Loop body VC terms must be re-encoded in AUFLIA mode, not reused from BV mode.
**Warning signs:** SMT output contains `(_ BitVec N)` inside an AUFLIA script — Z3 will reject with logic error.

### Pitfall 2: MIR Pattern Recognition Fragility

**What goes wrong:** The `for` loop desugaring in rustc MIR involves multiple callee names depending on the concrete iterator type (e.g., `core::ops::range::<impl Iterator for Range<usize>>::next` vs shortened names). Pattern matching on exact callee name strings fails on nightly toolchain changes.
**Why it happens:** Rustc's def_path_str changes with toolchain versions (seen in Phase 29 with NullaryOp removal and RawPtr rename).
**How to avoid:** Match on callee name *substrings* (e.g., `contains("into_iter")`, `contains("::next")`) or match on the Terminator::Call pattern + Option discriminant SwitchInt pattern structurally, not by name alone. Document the nightly toolchain version being targeted.
**Warning signs:** `detect_for_loops()` returns empty for functions that clearly have `for` loops.

### Pitfall 3: LoopInfo Extension Breaks Existing Tests

**What goes wrong:** Adding `iterator_kind: Option<IteratorKind>` and `loop_var: Option<String>` to `LoopInfo` breaks all test sites that construct `LoopInfo { header_block, back_edge_blocks, invariants }`.
**Why it happens:** Rust struct construction requires all fields.
**How to avoid:** Use `Option<IteratorKind>` defaulting to `None` (for while/loop) so existing construction sites set `iterator_kind: None, loop_var: None`. Or use `..Default::default()` pattern in tests.
**Warning signs:** Compilation errors at `LoopInfo { .. }` construction sites in test files.

### Pitfall 4: Bounded Unrolling With Unknown Bound

**What goes wrong:** If range end is `Unknown` (runtime-derived), the bounded unrolling VC must guard each unrolled iteration: `assert(start + k < end) => body_vc(start + k)`. Omitting the guard produces spurious violations when the bound happens to be smaller than N.
**Why it happens:** The unrolling assumes the loop actually executes N times.
**How to avoid:** Always wrap unrolled body VCs with `(=> (< (+ start k) end) body_vc)` implication guard when end is a non-literal bound.
**Warning signs:** `cargo test` reports bounded unrolling VC is UNSAT when a loop with N=3 elements is checked with unroll depth 5 — last 2 iterations are spurious.

### Pitfall 5: Slice/Vec Elem Access Bounds Check Double-Counting

**What goes wrong:** `generate_index_bounds_vcs()` already emits bounds-check VCs for any `Projection::Index` access in the function. For-loop bodies also access elements by index. This produces duplicate VCs.
**Why it happens:** `generate_index_bounds_vcs()` is a function-wide scan, not loop-aware.
**How to avoid:** For-loop VCs should *not* emit separate bounds-check VCs for index accesses already covered by `generate_index_bounds_vcs()`. The existing function-level bounds check is sufficient. For-loop VCs add *loop-range constraints* (i in [start, end)) as additional context, not new bounds-check VCs from scratch.
**Warning signs:** Each loop body element access gets 2 bounds-check VCs instead of 1.

---

## Code Examples

### Example 1: Range Loop VC Structure (AUFLIA quantified)

```rust
// Source: established pattern — mirrors hof_vcgen.rs build_fn_vc_script + Phase 22 decisions

// For: for i in 0..n { assert!(i < n); }
// Generates: (set-logic AUFLIA)
//            (declare-const n Int)
//            (assert (not (forall ((i Int)) (=> (and (<= 0 i) (< i n)) (< i n)))))
//            (check-sat)

let mut script = Script::new();
script.push(Command::SetLogic("AUFLIA".to_string()));
script.push(Command::DeclareConst("n".to_string(), Sort::Int));
let i_var = ("i".to_string(), Sort::Int);
let range_guard = Term::And(vec![
    Term::IntLe(Box::new(Term::IntLit(0)), Box::new(Term::Const("i".to_string()))),
    Term::IntLt(Box::new(Term::Const("i".to_string())), Box::new(Term::Const("n".to_string()))),
]);
let body_vc = Term::IntLt(  // placeholder for encoded body assertion
    Box::new(Term::Const("i".to_string())),
    Box::new(Term::Const("n".to_string()))
);
let forall_term = Term::Forall(
    vec![i_var],
    Box::new(Term::Implies(Box::new(range_guard), Box::new(body_vc))),
);
script.push(Command::Assert(Term::Not(Box::new(forall_term))));
script.push(Command::CheckSat);
```

### Example 2: Closed Range Encoding

```rust
// Source: CONTEXT.md locked decision
// 0..=n (inclusive) uses IntLe for end comparison:
let range_guard_inclusive = Term::And(vec![
    Term::IntLe(Box::new(Term::IntLit(0)), Box::new(Term::Const("i".to_string()))),
    Term::IntLe(  // <= instead of < for inclusive range
        Box::new(Term::Const("i".to_string())),
        Box::new(Term::Const("n".to_string()))
    ),
]);
```

### Example 3: Bounded Unrolling VC (QF_LIA)

```rust
// Source: Phase 23 QF_LIA pattern (async VCs use QF_LIA for bounded enumeration)
// Unroll depth 5 for `for i in 0..n { body }`:
let mut script = Script::new();
script.push(Command::SetLogic("QF_LIA".to_string()));
script.push(Command::DeclareConst("n".to_string(), Sort::Int));
for k in 0..5usize {
    let k_lit = Term::IntLit(k as i128);
    let guard = Term::IntLt(Box::new(k_lit.clone()), Box::new(Term::Const("n".to_string())));
    let body_at_k = encode_body_at_concrete_i(k as i128); // placeholder
    script.push(Command::Assert(
        Term::Implies(Box::new(guard), Box::new(body_at_k))
    ));
}
script.push(Command::CheckSat);
```

### Example 4: Conservative VC for Unknown Iterator

```rust
// Source: Phase 22 best-effort stub pattern
// Conservative VC: BoolLit(true) = "skip this loop, assume it's fine"
let conservative_vc = VerificationCondition {
    description: format!(
        "{}: for-loop over unknown iterator — conservative VC (BoolLit(true))",
        func.name
    ),
    script: {
        let mut s = Script::new();
        s.push(Command::SetLogic("QF_LIA".to_string()));
        // TODO: encode <iterator_name> iterator
        s.push(Command::Comment(
            format!("TODO: encode {} iterator", iterator_name)
        ));
        s.push(Command::Assert(Term::BoolLit(true)));
        s.push(Command::CheckSat);
        s
    },
    location: VcLocation {
        function: func.name.clone(),
        block: loop_header,
        statement: 0,
        source_file: None,
        source_line: None,
        source_column: None,
        contract_text: Some(format!(
            "loop over {} (conservative)", iterator_name
        )),
        vc_kind: VcKind::LoopInvariantExit,  // closest existing kind
    },
};
```

### Example 5: Enumerate Decomposition

```rust
// Source: CONTEXT.md decision — tuple destructured into two SMT constants
// for (idx, elem) in slice.iter().enumerate() { ... }
// Decompose into:
//   index_i: Int   (the enumeration index, same as loop index i)
//   elem_i: T      (the slice element at position i)
// These are declared as SMT constants:
script.push(Command::DeclareConst(
    format!("index_{}", i_var_name),
    Sort::Int,
));
script.push(Command::DeclareConst(
    format!("elem_{}", i_var_name),
    encode_type_for_auflia(&elem_ty),
));
// Bind index to loop variable:
script.push(Command::Assert(Term::Eq(
    Box::new(Term::Const(format!("index_{}", i_var_name))),
    Box::new(Term::Const(i_var_name.clone())),
)));
```

---

## Architecture Patterns: Existing Infrastructure Reuse

### What Phase 29.1 Builds On

| Phase | Mechanism | How 29.1 Reuses It |
|-------|-----------|-------------------|
| Phase 22 (HOF VCs) | AUFLIA + `Term::Forall` | Quantified for-loop postcondition VCs use identical AUFLIA pattern |
| Phase 22 | `encode_type_for_auflia()` | Must be used for all type encoding inside AUFLIA loop VCs |
| Phase 22 | BoolLit(true) stub fallback | Unknown/complex adapters get conservative VC |
| Phase 23 (Async VCs) | QF_LIA + bounded enumeration | Bounded unrolling VCs use QF_LIA (same motivation: bounded, no quantifiers) |
| Phase 24 | `generate_vcs_with_db` call pattern | New `generate_for_loop_vcs` wired identically to `generate_async_vcs` |
| Phase 28 | `{arr}_len` named constants | Slice/Vec iteration bounds declare `{arr}_len: Int` |
| Phase 28 | `VcKind::MemorySafety` | Bounds check VCs for element accesses inside loop body |
| Phase 28 | `encode_term::bounds_check_term()` | Element access `0 <= i < {arr}_len` generation |
| Existing | `detect_loops()` / `LoopInfo` | For-loop detection extends the existing loop infrastructure |

---

## State of the Art

| Old Behavior | New Behavior (Phase 29.1) | Impact |
|-------------|--------------------------|--------|
| `detect_loops()` emits warning "Loop without invariant annotation -- skipping verification" | `generate_for_loop_vcs()` emits both quantified + bounded unrolling VCs without annotation | All for-loops get verified without annotation burden |
| For-loop bodies have zero VCs | For-loop bodies have: (a) quantified AUFLIA VC, (b) bounded unrolling QF_LIA VC, (c) element bounds-check VCs | Meaningful verification of loop bodies |
| Range/slice/Vec patterns unrecognized at VCGen level | `IteratorKind` enum classifies iterator source; each gets appropriate encoding | Type-specific SMT encoding |
| `LoopInfo` has no iterator classification | `LoopInfo` extended with `iterator_kind: Option<IteratorKind>` | Future phases can extend per-iterator encoding |

**Not changing:**
- The `detect_loops()` back-edge DFS algorithm (used for while/loop)
- The `generate_loop_invariant_vcs()` function (user-supplied invariants still work)
- Any existing VC kinds (no new `VcKind` variants needed — use `LoopInvariantExit` or `MemorySafety`)

---

## Open Questions

1. **Should a new `VcKind::ForLoopBody` be added, or reuse existing kinds?**
   - What we know: Existing `VcKind::LoopInvariantExit` is semantically close; `VcKind::MemorySafety` is used for bounds checks (Phase 28 decision).
   - What's unclear: Whether diagnostics tooling needs to distinguish for-loop VCs from other loop VCs.
   - Recommendation: Reuse `VcKind::LoopInvariantExit` for quantified VCs and `VcKind::MemorySafety` for bounds checks. Add `VcKind::ForLoopBody` only if diagnostics layer needs it (deferred to later).

2. **How does the MIR callee name look for `into_iter` on nightly-2026-02-11?**
   - What we know: Phase 29 fixed several MIR API changes (NullaryOp removed, RawPtr renamed). Callee name format changes have been encountered before.
   - What's unclear: Exact string produced by `tcx.def_path_str()` for `IntoIterator::into_iter()` on the current nightly.
   - Recommendation: Wave 0 should add a diagnostic test that prints the callee name for a simple `for i in 0..5` loop in the integration test suite, to calibrate the string matching.

3. **Does `Function.ir::LoopInfo` need extending, or should `detect_for_loops()` maintain a separate Vec?**
   - What we know: `LoopInfo` is the established struct for loop info (used by `detect_loops()`). Extending it with `iterator_kind: Option<IteratorKind>` adds backward compat via `None` default.
   - What's unclear: Whether `detect_for_loops()` should be fused with `detect_loops()` or remain separate.
   - Recommendation: Extend `LoopInfo` with `Option<IteratorKind>` and `Option<String>` (loop var). Keep `detect_loops()` as-is (back-edge DFS). Add `classify_for_loop_iterators(func, &mut Vec<LoopInfo>)` that post-processes the loops to fill in `iterator_kind`. This is the most additive, least-invasive approach.

---

## Validation Architecture

### Test Framework
| Property | Value |
|----------|-------|
| Framework | cargo test (Rust built-in) |
| Config file | Cargo.toml workspace |
| Quick run command | `cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1` |
| Full suite command | `cargo test -p rust-fv-analysis 2>&1` |

### Test File
`crates/analysis/tests/vcgen_completeness29_1.rs` — new TDD scaffold (all tests RED before implementation).

### Proposed Test Map
| Test Name | Behavior | Type | Status |
|-----------|----------|------|--------|
| `vcgen_for_01_range_half_open` | `for i in 0..n` emits AUFLIA forall VC | unit | RED (Wave 0) |
| `vcgen_for_02_range_inclusive` | `for i in 0..=n` emits AUFLIA forall VC with IntLe end guard | unit | RED (Wave 0) |
| `vcgen_for_03_range_literal` | `for i in 0..5` uses concrete IntLit(5) not named constant | unit | RED (Wave 0) |
| `vcgen_for_04_bounded_unrolling` | `for i in 0..n` emits QF_LIA bounded unrolling VC | unit | RED (Wave 0) |
| `vcgen_for_05_slice_iter` | slice.iter() emits `{arr}_len` based bounds constraint | unit | RED (Wave 0) |
| `vcgen_for_06_enumerate` | `.enumerate()` emits `index_i: Int` + `elem_i: T` constants | unit | RED (Wave 0) |
| `vcgen_for_07_unknown_iterator` | Custom iterator emits BoolLit(true) conservative VC | unit | RED (Wave 0) |
| `vcgen_for_08_element_bounds_check` | Element access inside loop body emits VcKind::MemorySafety VC | unit | RED (Wave 0) |

### Wave 0 Gaps
- [ ] `crates/analysis/tests/vcgen_completeness29_1.rs` — all 8 tests above (RED scaffold)
- [ ] `IteratorKind` enum in `ir.rs` (needed by test construction)
- [ ] `ForLoopInfo` struct or `LoopInfo` extension (needed by test construction)

---

## Sources

### Primary (HIGH confidence)
- `crates/analysis/src/ir.rs` — `LoopInfo`, `Function`, `Terminator`, `Statement`, `Rvalue` structures inspected directly
- `crates/analysis/src/vcgen.rs` — `detect_loops()`, `generate_loop_invariant_vcs()`, `generate_vcs_with_db()`, `generate_index_bounds_vcs()` inspected directly (lines 235–785, 711–735, 1361–1435, 2601–2697)
- `crates/analysis/src/hof_vcgen.rs` — AUFLIA pattern with `Term::Forall` inspected directly
- `crates/analysis/src/async_vcgen.rs` — QF_LIA bounded enumeration pattern inspected directly
- `crates/smtlib/src/term.rs` — `Term::Forall`, `Term::IntLe`, `Term::IntLt`, `Sort::Int` confirmed present
- `.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-CONTEXT.md` — all locked decisions
- `.planning/STATE.md` — Phase 22/23/28 decisions relevant to logic selection and naming

### Secondary (MEDIUM confidence)
- `crates/analysis/tests/vcgen_completeness29.rs` — TDD scaffold pattern confirmed (make_func helper, RED test pattern)
- `crates/analysis/tests/vcgen_completeness28.rs` — TDD scaffold pattern confirmed

### Tertiary (LOW confidence)
- MIR desugaring pattern for `for` loops: based on knowledge of rustc MIR internals (training data). Actual callee name strings on nightly-2026-02-11 should be verified in Wave 0 diagnostic test. See Open Question 2.

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all existing infrastructure inspected directly in codebase
- Architecture patterns: HIGH — established patterns (hof_vcgen, async_vcgen) confirmed directly
- Pitfalls: HIGH for items derived from codebase inspection; MEDIUM for MIR callee name fragility (training data)
- Test map: HIGH — follows vcgen_completeness28/29 pattern exactly

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (stable project; main risk is nightly toolchain changes to MIR API)

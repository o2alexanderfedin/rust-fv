---
phase: 29.1-for-loop-iterator-range-vcgen
plan: 03
type: execute
wave: 3
depends_on:
  - 29.1-02
files_modified:
  - crates/analysis/src/for_loop_vcgen.rs
  - crates/analysis/tests/vcgen_completeness29_1.rs
autonomous: true
requirements:
  - VCGEN-01-FORLOOP
must_haves:
  truths:
    - "classify_for_loop_iterators() detects the MIR for-loop desugaring pattern from basic_blocks"
    - "generate_for_loop_vcs() internally calls detect_loops+classify so it works from both test (pre-populated loops) and driver (empty loops) paths"
    - "A function with for i in 0..5 basic_block pattern produces AUFLIA+QF_LIA VCs when called via generate_vcs_with_db"
    - "An integration test vcgen_for_09_mir_range_detection passes GREEN"
    - "All previous 8 tests remain GREEN"
    - "clippy -D warnings passes"
  artifacts:
    - path: "crates/analysis/src/for_loop_vcgen.rs"
      provides: "classify_for_loop_iterators() + updated generate_for_loop_vcs() with auto-classification"
    - path: "crates/analysis/tests/vcgen_completeness29_1.rs"
      provides: "vcgen_for_09_mir_range_detection integration test"
  key_links:
    - from: "crates/analysis/src/for_loop_vcgen.rs"
      to: "crates/analysis/src/ir.rs"
      via: "Terminator::Call { func } substring matching for into_iter + next"
      pattern: "classify_for_loop_iterators"
---

<objective>
Add MIR-level for-loop detection to `for_loop_vcgen.rs` so VCs are generated even when `func.loops` is not pre-populated (the production driver path). Adds `classify_for_loop_iterators()` that scans `func.basic_blocks` for the desugared `for` loop pattern.

Purpose: Without this, VCs only appear in tests (manually populated loops) but not when `cargo verify` runs on real Rust code with for-loops. This plan closes the gap between the unit-test path and the production driver path.

Output:
- `crates/analysis/src/for_loop_vcgen.rs` — updated with `classify_for_loop_iterators()` and unified entry point
- `crates/analysis/tests/vcgen_completeness29_1.rs` — test 09 added (MIR-pattern integration test)
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-CONTEXT.md
@.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-RESEARCH.md
@.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-02-SUMMARY.md

<interfaces>
<!-- From crates/analysis/src/ir.rs — Terminator::Call structure: -->
```rust
pub enum Terminator {
    Call {
        func: String,   // callee name string — use substring matching (not exact)
        args: Vec<Operand>,
        destination: Place,
        target: BlockId,
    },
    SwitchInt {
        discr: Operand,
        targets: Vec<(i128, BlockId)>,  // (discriminant_value, target_block)
        otherwise: BlockId,
    },
    Goto(BlockId),
    Return,
    Assert { cond: Operand, expected: bool, target: BlockId, kind: AssertKind },
    Unreachable,
}
```

<!-- From crates/analysis/src/ir.rs — Operand and Place: -->
```rust
pub enum Operand {
    Copy(Place),
    Move(Place),
    Const(ConstValue),
}

pub struct Place {
    pub local: String,
    pub projection: Vec<ProjectionElem>,
}
```

<!-- MIR desugaring of `for x in collection { body }` (from RESEARCH.md): -->
/*
  bb0: _iter = IntoIterator::into_iter(collection)   [Terminator::Call containing "into_iter"]
  bb1: _opt  = Iterator::next(&mut _iter)             [Terminator::Call containing "next"]
       -> target: bb2
  bb2: SwitchInt(_opt.discriminant) -> [1: bb3(body), otherwise: bb4(exit)]
  bb3: _x = _opt.field(0)  // Some(x)
       ... body ...
       Goto(bb1)   // back-edge to loop header
  bb4: return

  Detection: find Terminator::Call where func contains "into_iter"
  Then find successor's Call containing "::next"
  Then find that call's successor's SwitchInt
  Iterator kind: from the into_iter callee args or callee name
*/

<!-- From crates/analysis/src/vcgen.rs — detect_loops signature: -->
```rust
pub fn detect_loops(func: &Function) -> Vec<LoopInfo>
// Returns func.loops.clone() if pre-populated; otherwise DFS back-edge detection
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add classify_for_loop_iterators() and update generate_for_loop_vcs() to auto-classify</name>
  <files>crates/analysis/src/for_loop_vcgen.rs</files>
  <action>
Add a `classify_for_loop_iterators(func: &Function) -> Vec<LoopInfo>` function to `for_loop_vcgen.rs` that:

1. Calls `crate::vcgen::detect_loops(func)` to get the base loop list (back-edge DFS or pre-populated)
2. For each loop, if `iterator_kind` is already `Some(_)` (from tests or future driver wiring), keep it
3. If `iterator_kind` is `None`, scan `func.basic_blocks` around `header_block` to detect the for-loop MIR desugaring pattern:
   - Find a block with `Terminator::Call { func }` where `func.contains("into_iter")`
   - Check if that call's `target` block has `Terminator::Call { func }` where `func.contains("::next")`
   - Check if THAT call's `target` has `Terminator::SwitchInt` — this is the loop header
   - If the desugaring pattern is found, classify the `IteratorKind` from the callee name:
     - callee contains `"Range"` or the args suggest integer range → `IteratorKind::Range { start: RangeBound::Literal(0), end: RangeBound::Local("n".to_string()) }` (conservative: use Local("n") as placeholder)
     - callee contains `"slice"` or `"Iter"` → `IteratorKind::SliceIter { collection_local: args[0].local_name() }` (extract from first arg)
     - callee contains `"vec"` or `"Vec"` → `IteratorKind::VecIter { collection_local: args[0].local_name() }`
     - callee contains `"Enumerate"` → `IteratorKind::Enumerate { inner: Box::new(IteratorKind::Unknown { description: "inner".to_string() }) }` (conservative)
     - otherwise → `IteratorKind::Unknown { description: callee.to_string() }`
4. Return the classified `Vec<LoopInfo>`

Then update `generate_for_loop_vcs` to call `classify_for_loop_iterators(func)` instead of iterating `func.loops` directly:

```rust
pub fn generate_for_loop_vcs(
    func: &Function,
    ghost_pred_db: &GhostPredicateDatabase,
) -> Vec<VerificationCondition> {
    let classified_loops = classify_for_loop_iterators(func);
    let mut vcs = Vec::new();

    for loop_info in &classified_loops {
        let Some(iter_kind) = &loop_info.iterator_kind else {
            continue;
        };
        // ... rest of match unchanged
    }
    vcs
}
```

**Helper to extract local name from Operand (needed for collection_local):**

```rust
fn operand_local_name(op: &crate::ir::Operand) -> String {
    match op {
        crate::ir::Operand::Copy(place) | crate::ir::Operand::Move(place) => place.local.clone(),
        crate::ir::Operand::Const(_) => "_const".to_string(),
    }
}
```

**Robustness rules for MIR scanning:**
- Use substring matching (`func_name.contains("into_iter")`, `func_name.contains("::next")`) — NOT exact match (nightly MIR callee names change)
- When block index is out of bounds, skip that loop (don't panic)
- When pattern doesn't match clearly, set `iterator_kind: Some(IteratorKind::Unknown { description: callee.clone() })` — always emit conservative VC rather than skipping
- The classifier is best-effort: it's better to emit a conservative VC (BoolLit(true)) than to miss a loop

**Pitfall 3 mitigation:** Since `detect_loops` returns pre-populated loops when `func.loops` is non-empty, the classifier preserves existing `iterator_kind` values (from tests) and only fills in `None` entries. This ensures tests with manually constructed `LoopInfo` still work exactly.

After implementing, run:
```
cargo build -p rust-fv-analysis 2>&1 | tail -10
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | head -20
```
Fix all errors.
  </action>
  <verify>
    <automated>cargo build -p rust-fv-analysis 2>&1 | tail -5</automated>
  </verify>
  <done>for_loop_vcgen.rs compiles with classify_for_loop_iterators() and updated generate_for_loop_vcs(); all previous 8 tests still pass</done>
</task>

<task type="auto">
  <name>Task 2: Add test 09 (MIR range detection) and run full suite</name>
  <files>crates/analysis/tests/vcgen_completeness29_1.rs</files>
  <action>
Add `vcgen_for_09_mir_range_detection` test to `crates/analysis/tests/vcgen_completeness29_1.rs`.

This test verifies that `generate_for_loop_vcs` produces VCs even when `func.loops` is empty (i.e., the MIR classification path is used):

```rust
#[test]
fn vcgen_for_09_mir_range_detection() {
    // Simulate a function with a for-loop MIR desugaring pattern:
    //   bb0: _iter = into_iter(0..5)  [Terminator::Call with "into_iter"]
    //   bb1: _opt  = _iter.next()      [Terminator::Call with "::next"]
    //   bb2: SwitchInt(_opt) -> [1: bb3, otherwise: bb4]  (loop header)
    //   bb3: body  [Goto(bb1)]   (back-edge)
    //   bb4: Return
    let blocks = vec![
        BasicBlock {
            statements: vec![],
            terminator: Terminator::Call {
                func: "core::iter::traits::collect::IntoIterator::into_iter".to_string(),
                args: vec![Operand::Copy(Place::local("_range"))],
                destination: Place::local("_iter"),
                target: 1,
            },
        },
        BasicBlock {
            statements: vec![],
            terminator: Terminator::Call {
                func: "core::iter::traits::iterator::Iterator::next".to_string(),
                args: vec![Operand::Copy(Place::local("_iter"))],
                destination: Place::local("_opt"),
                target: 2,
            },
        },
        BasicBlock {
            statements: vec![],
            terminator: Terminator::SwitchInt {
                discr: Operand::Copy(Place::local("_opt")),
                targets: vec![(1, 3)],   // Some branch -> body
                otherwise: 4,             // None -> exit
            },
        },
        BasicBlock {
            statements: vec![],
            terminator: Terminator::Goto(1),  // back-edge to "loop header" (bb1/bb2)
        },
        BasicBlock {
            statements: vec![],
            terminator: Terminator::Return,
        },
    ];
    // loops is EMPTY — forces classify_for_loop_iterators to scan basic_blocks
    let mut func = make_func("range_loop_fn", Ty::Bool, vec![], vec![], blocks);
    // func.loops is already vec![] from make_func

    let vcs = rust_fv_analysis::for_loop_vcgen::generate_for_loop_vcs(
        &func,
        &rust_fv_analysis::ghost_predicate_db::GhostPredicateDatabase::default(),
    );

    // Should produce at least one VC (either classified or conservative Unknown)
    assert!(
        !vcs.is_empty(),
        "Expected at least one VC for for-loop detected from MIR pattern; got 0"
    );
}
```

After adding the test, run the full suite:
```
cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1
```

All 9 tests should pass. If test 09 fails because the MIR pattern detection returns 0 VCs (detection too strict), adjust the classifier to be more lenient:
- If any block's terminator is a `Call` containing `"into_iter"` and a successor has a `SwitchInt`, that is sufficient to classify as `Unknown` (conservative VC)
- The test only requires at least one VC, not a specific VC kind

Then run the full analysis test suite:
```
cargo test -p rust-fv-analysis 2>&1 | tail -20
```

Then run clippy and rustfmt:
```
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | head -20
cargo fmt -p rust-fv-analysis 2>&1
```

Fix all warnings. Then run the full workspace test to ensure nothing regressed:
```
cargo test 2>&1 | grep -E "FAILED|error\[" | head -20
```
  </action>
  <verify>
    <automated>cargo test -p rust-fv-analysis vcgen_completeness29_1 2>&1 | tail -15</automated>
  </verify>
  <done>All 9 vcgen_completeness29_1 tests pass; full cargo test -p rust-fv-analysis passes; clippy -D warnings passes; rustfmt shows no diffs</done>
</task>

</tasks>

<verification>
```
cargo test -p rust-fv-analysis 2>&1 | grep -E "test result|FAILED" | tail -10
cargo clippy -p rust-fv-analysis -- -D warnings 2>&1 | grep "^error" | head -5
cargo test 2>&1 | grep -E "FAILED" | head -5
```
Expected: all tests pass, no clippy errors, no workspace regressions.
</verification>

<success_criteria>
- classify_for_loop_iterators() scans basic_blocks for into_iter + ::next + SwitchInt MIR pattern
- generate_for_loop_vcs() auto-classifies loops from MIR when func.loops is empty
- Test 09 (vcgen_for_09_mir_range_detection) passes GREEN with empty func.loops
- All 9 vcgen_completeness29_1 tests pass
- Full workspace cargo test passes with no regressions
- cargo clippy -p rust-fv-analysis -- -D warnings passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/29.1-for-loop-iterator-range-vcgen/29.1-03-SUMMARY.md`
</output>

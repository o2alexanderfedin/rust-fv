# Requirements Archive: v0.4 Full Rust Verification

**Archived:** 2026-02-23
**Status:** SHIPPED

For current requirements, see `.planning/REQUIREMENTS.md`.

---

# Requirements: rust-fv v0.4

**Defined:** 2026-02-19
**Core Value:** Sound, automated verification of Rust code properties with minimal developer burden — if the tool says "verified", it must be mathematically correct; if a developer can write a spec, the tool should prove it automatically 80-90% of the time for safe Rust.

## v0.4 Requirements

Requirements for v0.4 Full Rust Verification milestone. Each maps to roadmap phases.

### Counterexample Generation

- [x] **CEX-01**: User sees Rust variable names (not SSA names like `_param_x_1`) in counterexample output when verification fails
- [x] **CEX-02**: User sees typed Rust values (e.g. `i32: 5`, `bool: false`) not raw hex bitvectors in counterexample output
- [x] **CEX-03**: User sees counterexample values annotated at the failing source line via ariadne inline labels in terminal output
- [x] **CEX-04**: Machine consumers receive structured `counterexample` field in `--output-format=json` output on verification failure

### Separation Logic

- [x] **SEP-01**: User can write `pts_to(p, v)` ownership predicate in `#[requires]`/`#[ensures]` to specify raw pointer ownership
- [x] **SEP-02**: User can write separating conjunction (`H1 * H2`) in specs to prove disjoint ownership and aliasing freedom
- [x] **SEP-03**: Frame rule is automatically applied during function calls so unchanged heap portions are not required to be manually re-specified
- [x] **SEP-04**: User can define recursive heap predicates via `#[ghost_predicate]` (e.g. `linked_list(p, n)`) with bounded unfolding (depth 3)

### Weak Memory Models

- [x] **WMM-01**: User can verify programs using `Relaxed`, `Acquire`, `Release`, and `AcqRel` atomic orderings with full RC11 coherence axioms (`mo`, `rf`, `co`)
- [x] **WMM-02**: The 8 canonical C11 litmus tests (IRIW, SB, LB, MP, CoRR, CoRW, CoWR, CoWW) pass as the soundness specification for the weak memory encoding
- [x] **WMM-03**: Data race detection extends to cover weak memory orderings (not just SeqCst)
- [x] **WMM-04**: All weak memory axioms are scoped to `WeakMemory*` VcKind — existing SeqCst verification proofs are not regressed

### Higher-Order Closures

- [x] **HOF-01**: User can write `fn_spec(f, |x| pre => post)` specification entailments to verify that a closure `f` satisfies given pre/postconditions
- [x] **HOF-02**: Stateful closures (`FnMut`) track environment mutation across calls via SSA-versioned environment (`env_v0 → env_v1`)

### Async/Await Verification

- [x] **ASY-01**: User can annotate `async fn` with `#[requires]`/`#[ensures]` and have functional properties verified under sequential polling model
- [x] **ASY-02**: User can write `#[state_invariant]` to specify invariants that must hold at every `.await` suspension point in an `async fn`

## Future Requirements (v0.5+)

### Deferred from v0.4

- **SEP-05**: Magic wand (`-*`) operator in separation logic — complex encoding, rarely needed
- **WMM-05**: SeqCst memory fences as distinct from SeqCst stores — vanishingly rare in Rust
- **HOF-03**: Async closures (`async |x| { ... }`, Rust 2024) — third complexity axis on top of closures + async
- **ASY-03**: Concurrent async verification (multi-threaded async + weak memory combined) — current research frontier
- **ASY-04**: Async liveness properties / termination — requires temporal logic, out of SMT scope
- **SEP-06**: Recursive SL predicates with full induction (not bounded) — bounded unfolding depth 3 covers practical cases

## Out of Scope

| Feature | Reason |
|---------|--------|
| Async liveness / termination | Requires temporal logic or ranking functions; outside SMT decision procedures |
| Multi-threaded async (async + weak memory combined) | Current research frontier; no practical tool exists; defer to v0.5+ |
| Magic wands in separation logic | Complex encoding, rarely needed, no SMT automation precedent |
| SeqCst fences vs stores distinction | Vanishingly rare in real Rust; SeqCst stores (v0.3) cover 99% of cases |
| Async closures (Rust 2024 edition) | Three-way orthogonality with closures+async; defer to v0.5 |
| Recursive SL predicates with full induction | Bounded unfolding depth 3 covers practical linked lists / trees |
| Automatic contract inference | Undecidable for general programs; explicit annotations required |
| Windows support | Focus on macOS/Linux; add post-v1.0 when core is stable |

## Traceability

Which phases cover which requirements. Updated during roadmap creation.

| Requirement | Phase | Status |
|-------------|-------|--------|
| CEX-01 | Phase 19 | Complete (19-01) |
| CEX-02 | Phase 19 / Phase 25 (IDE gap) | Complete (CLI) / Pending (IDE) |
| CEX-03 | Phase 19 | Complete |
| CEX-04 | Phase 19 / Phase 25 (IDE gap) | Complete (CLI) / Pending (IDE) |
| SEP-01 | Phase 20 | Complete |
| SEP-02 | Phase 20 | Complete |
| SEP-03 | Phase 20 | Complete |
| SEP-04 | Phase 24 | Complete |
| WMM-01 | Phase 21 | Complete |
| WMM-02 | Phase 21 | Complete |
| WMM-03 | Phase 26 (gap closure) | Complete |
| WMM-04 | Phase 21 | Complete |
| HOF-01 | Phase 22 | Complete |
| HOF-02 | Phase 22 | Complete |
| ASY-01 | Phase 23 | Complete |
| ASY-02 | Phase 23 | Complete |

**Coverage:**
- v0.4 requirements: 16 total
- Mapped to phases: 16
- Unmapped: 0 ✓
- Pending (gap closure): WMM-03 (Phase 26)

---
*Requirements defined: 2026-02-19*
*Last updated: 2026-02-22 — gap closure phase 26 added from v0.4 audit (WMM-03 soundness gap)*

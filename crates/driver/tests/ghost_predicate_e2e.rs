//! End-to-end driver-level integration tests for SEP-04 ghost predicate production wiring.
//!
//! These tests exercise the FULL pipeline: VerificationTask → verify_functions_parallel()
//! → verify_single() → generate_vcs_with_db() → parse_spec() → parse_spec_expr_with_db().
//!
//! Distinct from Phase 20 tests in crates/analysis/tests/sep_logic_integration.rs which
//! call parse_spec_expr_with_db() directly (bypassing the driver path).
//!
//! Architecture note: VcKind::Precondition is generated for *call-site* precondition checks
//! (caller must satisfy callee's requires). The function's own `requires` is used as an
//! *assumption* in postcondition VCs. Therefore tests include both `requires` and `ensures`
//! to trigger VC generation — the ghost predicate in `requires` expands and is assumed
//! during the postcondition check.

use rust_fv_analysis::ghost_predicate_db::{GhostPredicate, GhostPredicateDatabase};
use rust_fv_analysis::ir::{
    BasicBlock, Contracts, Function, IntTy, Local, SpecExpr, Statement, Terminator, Ty,
};
use rust_fv_driver::cache::VcCache;
use rust_fv_driver::invalidation::{InvalidationDecision, InvalidationReason};
use rust_fv_driver::parallel::{VerificationTask, verify_functions_parallel};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

fn temp_cache_dir(name: &str) -> PathBuf {
    let mut dir = std::env::temp_dir();
    dir.push(format!("rust-fv-ghost-e2e-{}-{}", name, std::process::id()));
    let _ = std::fs::remove_dir_all(&dir);
    dir
}

/// Build a minimal IR function with the given requires and ensures specs.
///
/// The function has a single i32 param `_1` and return local `_0: i32`.
/// Body is a single Nop + Return (trivial function).
fn make_ghost_test_func(requires_spec: &str, ensures_spec: &str) -> Function {
    Function {
        name: "test_ghost_e2e".to_string(),
        params: vec![Local::new("_1", Ty::Int(IntTy::I32))],
        return_local: Local::new("_0", Ty::Int(IntTy::I32)),
        locals: vec![],
        basic_blocks: vec![BasicBlock {
            statements: vec![Statement::Nop],
            terminator: Terminator::Return,
        }],
        contracts: Contracts {
            requires: vec![SpecExpr {
                raw: requires_spec.to_string(),
            }],
            ensures: vec![SpecExpr {
                raw: ensures_spec.to_string(),
            }],
            invariants: vec![],
            is_pure: false,
            decreases: None,
            fn_specs: vec![],
        },
        loops: vec![],
        generic_params: vec![],
        prophecies: vec![],
        lifetime_params: vec![],
        outlives_constraints: vec![],
        borrow_info: vec![],
        reborrow_chains: vec![],
        unsafe_blocks: vec![],
        unsafe_operations: vec![],
        unsafe_contracts: None,
        is_unsafe_fn: false,
        thread_spawns: vec![],
        atomic_ops: vec![],
        sync_ops: vec![],
        lock_invariants: vec![],
        concurrency_config: None,
        source_names: HashMap::new(),
    }
}

fn make_task(func: Function, db: GhostPredicateDatabase) -> VerificationTask {
    VerificationTask {
        name: func.name.clone(),
        ir_func: func,
        contract_db: Arc::new(rust_fv_analysis::contract_db::ContractDatabase::new()),
        ghost_pred_db: Arc::new(db),
        cache_key: [0u8; 32],
        mir_hash: [0u8; 32],
        contract_hash: [0u8; 32],
        dependencies: vec![],
        invalidation_decision: InvalidationDecision::verify(InvalidationReason::Fresh),
        source_locations: HashMap::new(),
    }
}

/// Main E2E test: ghost predicate in requires is used as assumption in postcondition VC.
///
/// The function has:
///   requires: is_positive(_1)   — ghost predicate that expands to "_1 > 0"
///   ensures:  _1 > 0            — provable IF the ghost predicate was expanded and assumed
///
/// The postcondition VC is generated by generate_vcs_with_db via verify_functions_parallel.
/// If ghost_pred_db is severed (not wired from VerificationTask into generate_vcs_with_db),
/// parse_spec returns None for "is_positive(_1)" and the assumption is not added. The VC
/// then queries Z3 without the precondition assumption — and may produce SAT or fail differently.
///
/// Crucially: without the wiring, zero precondition assumptions are encoded for the ghost
/// predicate, and `generate_contract_vcs` may generate an empty conditions list if parse_spec
/// returns None for an otherwise-only-requires-based fact. This test validates that VCs ARE
/// generated when ghost_pred_db is properly threaded through the driver path.
#[test]
fn ghost_predicate_expands_to_vc_via_driver_path() {
    let mut db = GhostPredicateDatabase::new();
    db.insert(
        "is_positive".to_string(),
        GhostPredicate {
            param_names: vec!["x".to_string()],
            body_raw: "x > 0".to_string(),
        },
    );

    // Function: requires is_positive(_1), ensures _1 > 0
    // With ghost predicate expanded: requires "_1 > 0", ensures "_1 > 0"
    // The postcondition VC is generated and verified (UNSAT with ghost pred assumption).
    let func = make_ghost_test_func("is_positive(_1)", "_1 > 0");
    let task = make_task(func, db);

    let cache_dir = temp_cache_dir("expand");
    let mut cache = VcCache::new(cache_dir);

    let results = verify_functions_parallel(vec![task], &mut cache, 1, false, false);

    assert_eq!(results.len(), 1, "Must have one result for test_ghost_e2e");
    let task_results = &results[0].results;

    // The postcondition VC must be generated (ensures is present → generate_contract_vcs fires).
    // The ghost predicate in requires must expand and be assumed so the postcondition verifies.
    assert!(
        !task_results.is_empty(),
        "Must produce at least one VC result — ghost predicate wiring failed if empty. Got: {:?}",
        task_results
            .iter()
            .map(|r| &r.condition)
            .collect::<Vec<_>>()
    );

    // All VCs must verify: is_positive(_1) expands to _1 > 0 which is exactly the ensures.
    // If ghost predicate was NOT expanded, the assumption is missing and Z3 may return SAT
    // (cannot prove the postcondition), making verified=false.
    let all_verified = task_results.iter().all(|r| r.verified);
    assert!(
        all_verified,
        "All VCs must verify when ghost predicate assumption enables the postcondition. \
        If ghost predicate was silently dropped, Z3 returns SAT (violation). Got: {:?}",
        task_results
            .iter()
            .map(|r| (&r.condition, r.verified))
            .collect::<Vec<_>>()
    );
}

/// Regression test: plain specs (no ghost predicates) still work with empty DB.
///
/// Ensures generate_vcs_with_db with GhostPredicateDatabase::new() is backward-compatible
/// and doesn't break existing plain requires + ensures specs.
#[test]
fn empty_ghost_pred_db_is_backward_compatible() {
    // Function: requires _1 > 0, ensures _1 > 0 — trivially provable.
    let func = make_ghost_test_func("_1 > 0", "_1 > 0");
    let task = make_task(func, GhostPredicateDatabase::new());

    let cache_dir = temp_cache_dir("compat");
    let mut cache = VcCache::new(cache_dir);

    let results = verify_functions_parallel(vec![task], &mut cache, 1, false, false);

    assert_eq!(results.len(), 1);

    let task_results = &results[0].results;
    assert!(
        !task_results.is_empty(),
        "Plain requires+ensures spec must produce VCs with empty ghost pred DB. Got: {:?}",
        task_results
            .iter()
            .map(|r| &r.condition)
            .collect::<Vec<_>>()
    );

    let all_verified = task_results.iter().all(|r| r.verified);
    assert!(
        all_verified,
        "Plain requires+ensures spec must verify (backward compat). Got: {:?}",
        task_results
            .iter()
            .map(|r| (&r.condition, r.verified))
            .collect::<Vec<_>>()
    );
}
